pdf//ArtChain_Blockchain-Enabled_Platform_for_Art_Marketplace.pdf;It is expected to provide a complete solution towards these challenges by creating a new ecosystem for the art keeping, trading and transferring.;It is expected to provide a complete solution towards these challenges by creating a new ecosystem for the art keeping, trading and transferring.;This means that participants will have the opportunity to develop an extensive range of art-related applications for speciÔ¨Åc scenarios based on the foundation of ArtChain.;It is expected to provide a complete solution towards these challenges by creating a new ecosystem for the art keeping, trading and transferring.;[('blockchain', 52), ('art', 40), ('transaction', 37), ('artchain', 33), ('node', 33), ('system', 31), ('artwork', 28), ('trading', 27), ('datum', 26), ('contract', 25)];2019.0;In future, we plan to work on anti-counterfeiting for the original works of art by integrating with the smart modules of IoT, and activating relevant smart hardware and other functionality (e.g. positioning/location tracking) as required by artists or collectors.;"ArtChain: Blockchain-enabled Platform for Art Marketplace
Ziyuan Wang, Lin Yang, Qin Wang, Donghai Liu, Zhiyu Xu, Shigang Liu
Blockchain Innovation Centre
Swinburne University of Technology
Abstract‚ÄîBlockchain is an emerging technology that has
the potential to revolutionize the global industry and create a
trusted relationship in a multi-party business network. There
are a number of practical use cases where blockchain has been
applied. One speciÔ¨Åc area is the Art industry, where it is a
natural Ô¨Åt in the way that art forensics and transactions are
conducted, tracked and recorded. This motivates us to develop
the ArtChain platform to assist the Art Industry. In this paper,
we present ArtChain, which is an integrated trading system
based on blockchain. It includes the front end, the back end,
the services, the smart contract, the chain connection and the
deployment scripts from the bottom to the top. To the best of
our knowledge, this is the Ô¨Årst deployed blockchain-enabled
art trading platform in Australia. It provides a transparent
yet privacy-preserving, and tamper-proof transaction history
for registration, provenance, and traceability of art assets.
Our objective analysis and evaluation show that the ArtChain
platform is applicable and practical. For the interest of other
researchers, our system implementation related resources are
open-sourced on Github1.
I. INTRODUCTION
Blockchain, also known as distributed ledger technol-
ogy (DLT) [1], is designed to support veriÔ¨Åcation-driven
transaction services within a generally un-trusted ecosystem.
The design of blockchain technology ensures that no one
business entity can modify, delete, or even append any
record to the ledger without consensus from other network
participants, ensuring the immutability of data stored on the
ledger. Blockchain is now being used in several industry
applications such as blockchain-enabled traceability and
provenance for food safety [2] documentation and cross-
organization workÔ¨Çow management in trading and logistics
[3].
With $200 billion of annual trading, the art market is one
of the largest unregulated markets in the world, accounting
for one-third of the amount of crime just behind drugs and
guns [4]. Tens of millions of dollars are transferred with little
or no documentation and transparency. Current challenges
and issues in the art market are: (1) lack of transparency on
prices and ownership history (provenance) and inadequate
control of transaction data due to the information asymme-
try; (2) the authenticity and appraisal of high-value works of
art is difÔ¨Åcult; (3) lack of the value of artworks at the primary
art market and transparency trading at the secondary auction
market (both online and ofÔ¨Çine); (4) lack of recognition,
1https://github.com/ArtChainGlobal
public attention and care for a large number of artists; (5)
it is difÔ¨Åcult for the artists to get royalty payment from the
secondary market.
Blockchain technology possesses a natural Ô¨Åt to improve
the transparency, keep records and reduce illicit activities
in the art market, due to its inherent properties [5] [6]. In
this paper, we present our project work, called ArtChain, a
blockchain-based art trading system, which has been piloted
and operated as a working product in practice. It is expected
to provide a complete solution towards these challenges by
creating a new ecosystem for the art keeping, trading and
transferring. ArtChain fundamentally builds up the underly-
ing architecture of blockchain to support a commercial-level
trading platform centered around art assets. The core value
proposition of the platform lies in:
‚Ä¢ Privacy Protection Shared ledger along with permis-
sioned control ensures the transparency of each trans-
action which guarantees the privacy protection in art
trading and provenance.
‚Ä¢ Traceability Real-time tracking of individual artworks
combined with the blockchain ledger assists in the Ô¨Åght
against counterfeit artworks.
‚Ä¢ Irreversibility The on-chain registration of collectors
ofÔ¨Çine assets provides an immutable digital record of
the artwork, which guarantees the true ownership, the
provenance and the value of the artwork.
‚Ä¢ Transparency Publicly displaying artworks to a wider
range of professional investors, leveraging the openness
of art ecosystem.
II. BLOCKCHAIN SOLUTION TOWARDS ART TRADING
In this section, we start with the rationale behind the use
of blockchain for an art marketplace, and then discuss the
beneÔ¨Åts of this blockchain-enabled platform.
A. Rationale behind Using Blockchain
The major entities or participants in our solution are
described in the following.
‚Ä¢ Artist Established artists along with new generation
artists all have equal opportunities for professional
evaluation and to publish their artworks. Published
items will be available for trade.
‚Ä¢ Art gallery After artwork is registered on the blockchain
system, it can be tracked and located in real-time giving
an additional level of security to galleries.
447
2019 IEEE International Conference on Blockchain (Blockchain)
978-1-7281-4693-5/19/$31.00 ¬©2019 IEEE
DOI 10.1109/Blockchain.2019.00068
Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA. Downloaded on July 14,2025 at 16:59:39 UTC from IEEE Xplore.  Restrictions apply. 
'%-""
()')%$
%$
	)""(
('#$'%$)
$

		

'$
')$
%"""")%$
')
,"""")

%$)$)
')+%'!$#$)
()'
""(
+$'(&'-)%$
+$'(&$$
%&&$$
"""")$#$)
""$
'$('
'$()%$
)'+

		

%""
%,""%""
+'$
%$)'%""""'
 (
#')%$)')

)'*#
Figure 1.
System architecture
‚Ä¢ Auction house Data stored on blockchain can be syn-
chronized with auction houses, opening up new chan-
nels for a greater global audience participation. More
trafÔ¨Åc equals more opportunities for all involved.
‚Ä¢ Collector Online synchronization of collectors ofÔ¨Çine
art assets. This proves ownership and sets the prove-
nance of the pieces for future generations ensuring the
value is preserved. Access to a global database with
extensive Ô¨Åltering capabilities.
B. BeneÔ¨Åts of a Blockchain-enabled Art Marketplace
Firstly, the artwork authenticity and traceable data can be
simply achieved. Provenance is crucial when it comes to
collecting art. Not having a record of the ownership history
for a masterpiece often raises suspicion that it could be
stolen or fake, hence a distributed ledger can be used to trace
the transfer of ownership over a period of time, and serve as
a decentralized database securing provenance data and other
important information related to artworks. This allows for
quick and indisputable ownership transfer in trading.
Secondly, royalty payment from the secondary market for
artists can be achieved. A 5% royalty will be payable to
visual artists on certain commercial sales of their work. This
entitlement is created by the Resale Royalty Right for Visual
Artists Act 2009.However, due to the difÔ¨Åculty in tracking
the resales in the current art market, often artists do not
necessarily get the royalty [7].
Thirdly, Blockchain audit trail helps in detecting tax
evasion and money laundering. Add-on analytics or AI
services can predict the current value of an artwork based on
shared transparent data. This helps primary market valuation,
which is more difÔ¨Åcult and more speculative than secondary
market due to a lack of market history.
Furthermore, our solution is designed to become an open,
expandable infrastructure orientated towards the art industry.
This means that participants will have the opportunity to
develop an extensive range of art-related applications for
speciÔ¨Åc scenarios based on the foundation of ArtChain.
III. SYSTEM OVERVIEW
In this section, we Ô¨Årst present the foundational principles
the architecture is based on, the high-level architecture and
its main components. Then, we present basic data model
design and the trading process of the platform. In addition,
we discuss the trust and security issues.
A. High-level Architecture Design
We Ô¨Årst evaluate several blockchain platforms to inform
our decision on which platform to apply. Based on the
business requirements and technical assessment we decide to
use the Ethereum private blockchain and Proof of Authority
(PoA) [8] as the consensus algorithm. Initially, we consid-
ered to use Hyperledger Fabric to implement our system due
to its capability, popularity and maturity. However, it lacks
support in native token, which is a key business requirement
in our design as the art trading platform hopes to integrate
the payment process and the ownership transfer process. We
design and implement a utility token called ACGT to achieve
the high performance requirement. Refer to Section IV-A
Tokenization for more details.
Here, we adopt microservices architecture for the fol-
lowing beneÔ¨Åts: (1) Allows quick parallel development of
various components in the application landscape; (2) Re-
duces discussion time between various groups developing
various components; (3) When done properly, provides
clean reusable interfaces; (4) When done properly, reduces
handshaking in interfaces; (5) Reduces the risk and time of
integration/chain testing. The architecture design is shown
in Figure 1.
There are three layers in the system: the user front end,
the trading back end, and the ArtChain blockchain layer.
‚Ä¢ User Front End: includes the following functions:
managing ProÔ¨Åle for user registration, login and user
details; displaying art Collection; shopping Cart; user
Wallet; and CMS (Content Management System) to
create and manage web content.
‚Ä¢ Trading Back End: consists of Artwork Management,
Shopping/biding, and Wallet Management. Artwork
Management includes artwork registration, ownership
veriÔ¨Åcation and ownership transfer. Artists or collectors
conduct the registration of their artworks through the
assessment system of professional institutions within
ArtChain. Their works of art will then be eligible for
trading and participating in the ecosystem.
‚Ä¢ ArtChain: including the following components: (1)
Royalty model: responsible for artists royalty payment
in the resale of their artworks. (2) POI model: manage
Proof of Interaction (POI) agreements, which are used
as incentives to grow the ecosystem of applications.
448
Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA. Downloaded on July 14,2025 at 16:59:39 UTC from IEEE Xplore.  Restrictions apply. 
Figure 2.
Data model: User Class
More details are described in Section IV-A. (3)Re-
warding Controller: based on POI model to manage
the rewarding to participants. The details are business
conÔ¨Ådential information, which is out of the scope of
this paper.
B. Design of Data Model
There are three major groups of data objects stored in the
distributed ledger as illustrated as follow:
‚Ä¢ User: contains all information related to a user‚Äôs proÔ¨Åle,
login, wallet, and auction events attended. An artist is
also a user, with additional information and veriÔ¨Åcation.
The detail is shown in Figure 2
‚Ä¢ Artwork: consists of details, tag, history of ownership
transfer, and order details. These class represents the
workÔ¨Çow related to the masterpiece. The detail is
shown in Figure 3.
Figure 3.
Data model: Artwork Class
Figure 4.
Data model: Trading Class
‚Ä¢ Trading: combines an order with the artwork and the
buyer‚Äôs basic information and the shipping address. The
detail is shown in Figure 4.
The trading process is shown in Figure 5. When the user‚Äôs
trading request is received, ProÔ¨Åle Services and Trading
Services are triggered to retrieve the customer info and
trade info. After checking the trading conditions, Payment
Services are responsible for handling payment. Then Reward
Services are called to request and receive the reward infor-
mation. In the end, Shipping Services handle the shipping
information.
C. Trust Establishment
ArtChain co-operates with specialized or high-proÔ¨Åle part-
ners in the primary or secondary markets of the art industry,
including museums, art galleries, and auction houses, to
establish the original ledger nodes and provide core func-
tions such as validating, ordering and generating blocks of
transactions. These ledger nodes and other agent or routing
nodes work together to protect the blockchain network.
We use Proof-of-Authority (PoA) as the trust model of
ArtChain network. PoA is well-suited to regulated industries
where entities are responsible for maintaining the network
(known as authorities), rather than remain anonymous as in
mining-based chains.
For our practical purpose, well-known museums and art
galleries are acting as authorities in ArtChain network to
conduct authenticity and price assessment for an artwork.
They are called SuperNode. Supernodes perform validating,
block generation and publishing.
449
Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA. Downloaded on July 14,2025 at 16:59:39 UTC from IEEE Xplore.  Restrictions apply. 
%#""&$%
#%#
#%( ### $$ (
#'$
""&$%'
 # 
 !' 
	

	
# +
#'


$%#%
""&$%'
$!! 

""&$%'
%# 
""&$%'
&$% 
* #
#
#'
!!
#'
*%
#'
(#
#'
&&#
)!#$$

	
Figure 5.
Trading Process
Any node attempting to engage in malicious conducts
or falling under attack will be immediately detected by
other nodes in the network once it shows unusual behaviour
(e.g., sending illegal transactions, trafÔ¨Åc attacks, and data
tampering). The network will immediately isolate the partic-
ular node and send out warnings. ArtChain deploys ledger
nodes throughout the primary and secondary art markets,
including internet companies, cloud service providers and
a large number of collectors of works of art and artists,
which, from a probability point of view, can eliminate the
possibilities where the majority of nodes fall under attack
or collude to engage in malicious conducts.
Initially, we set up 100 nodes to provide sufÔ¨Åcient re-
dundancy and Ô¨Åght against 51% attack. Currently, they are
deployed at AWS and Ali cloud and not activate all at the
same time. We monitor the nodes behaviour and dynamically
replace the crashed nodes. We plan to extend the deployment
to be more decentralized on other clouds. In this regard,
an important issue to consider is the trade-off between
decentralization and performance.
IV. SCALABLE BLOCKCHAIN IMPLEMENTATION
In this section, we present the implementation of ArtChain
network. We Ô¨Årst introduce tokenization and how it works
in our system. Then we describe the design and imple-
mentation of the upgradable smart contract for the purpose
of improving function and Ô¨Åxing bugs. Finally, we discuss
how to preserve privacy and conÔ¨Ådentiality as required by
regulations and business needs.
A. Tokenizaiton
Tokenization refers to converting an asset into a digital
token on the blockchain system, so that ownership of the
asset can be transferred via smart contracts. Smart con-
tracts have functions for automatic transactions, formulas
for calculating asset prices and other speciÔ¨Åc features [9],
[10]. Tokenization is not simply the creation of a token.
Instead, it is about the design of the whole system, including
understanding the various rights and issues.
There are two types of token in ArtChain: the security
token ACG2 and the utility token ACGT.
ACG token comes with the essential technical features
of digital currencies, including a steady issue curve, free
trading, immunity to double-spending attacks, and traceable
transaction history. These features are secured through the
ledger architecture and smart contracts. We develop rele-
vant E-wallets for corporate or institutional users, which
incorporate all essential functions for interactions with the
applications on ArtChain.
ACG token provides incentives for maintaining the
ArtChain network and the ecosystem of ArtChain applica-
tions.
‚Ä¢ Network Maintenance: the consistency of ArtChain net-
work is jointly assured by ledger nodes. Ledger nodes
will have the opportunity to be awarded with ACG
as block rewards and transaction fees, to encourage
them to contribute to the security and stability of the
ArtChain network.
‚Ä¢ Ecosystem of Applications: ArtChain will award users
with newly added ACG in positive correlation within
a certain cycle based on a number of indicators such
as their frequency of interaction with the ArtChain
ecosystem, levels of contribution, inÔ¨Çuence and the
number of ACG coins they hold. All indicators of
ecosystem incentives are quantiÔ¨Åable and veriÔ¨Åable,
which are collected and calculated by ledger nodes.
Incentives will be allocated under Proof of Interaction
(POI) agreements.
The ratio of the incentives for ArtChain network main-
tenance and the incentives for the ecosystem of ArtChain
applications will be dynamically adjusted by using a negative
feedback mechanism to maintain the balance and stability of
the ArtChain network and the ecosystem of applications.
The speciÔ¨Åc indicators and algorithms will be published
before any main relevant applications go online, and will be
implemented and operated through open rules of contracts.
Relevant institutional users of the ecosystem (art galleries,
museums, auction houses and artists) will be consulted.
The utility token ACGT is only used internally to facilitate
payment in art trading. It is a kind of stable coins, which are
designed to have a stable price or value over a period of time,
therefore, less volatile. These coins aim to mimic the relative
price stability of Ô¨Åat currencies on one hand, but keep the
core values of cryptocurrencies such as decentralization and
security, on the other hand. Each ACGT token is collateral-
ized by an equal amount of Ô¨Åat currency (1 AUD) held by
2https://etherscan.io/token/0x984c134a8809571993fd1573fb99f06dc61e216f
450
Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA. Downloaded on July 14,2025 at 16:59:39 UTC from IEEE Xplore.  Restrictions apply. 
	






	
	
	
	




	

			

		
	
			
	

	

				
	

Figure 6.
Zepplin proxy architecture pattern
a central custodian. Holders are guaranteed to redeem their
token at any point for the stable value denominated in Ô¨Åat.
B. Upgradable Smart Contracts
Smart contract, once deployed into the blockchain, is
immutable literally. In consideration of bug Ô¨Åx and function
improvement, lots of work has been done to propose an
upgradeable design pattern of the smart contract [11].
The typical methods include:
‚Ä¢ Separate logic and data
‚Ä¢ Partially upgradable smart contracts system
‚Ä¢ Separate logic and data in key-value pairs.
‚Ä¢ Eternal storage with proxy contract
Among these methods, the proxy mechanism is most
Ô¨Çexible and guarantees a 100% upgradable mechanism i.e.,
the logic could be completely modiÔ¨Åed while remaining the
existing data state. In our system, we refer to Zeppelin‚Äôs
proxy patterns [12] and implement the so-called Unstruc-
tured Storage Pattern. The contract structure is shown in
Fig 6.
By using this pattern, the system achieves following
features:
‚Ä¢ General user is unaware about upgrade of the contract.
‚Ä¢ Implementation of logic contract is 100% upgradable.
‚Ä¢ Data is stored in proxy contract. New data Ô¨Åelds
could be added by the upgraded logic contract, without
touching existing data structure.
This design has also been chosen for the ZeppelinOS
smart contract system, and gone through a full security audit.
C. Initializing Issue
In our implementation, we also address the initializing
issue. This is a long-standing problem of upgradability solu-
tions for Ethereum. Our aim is to create an upgradable logic
contract, and we practically deploy a proxy contract which
delegates to a pre-existing deployment of logic contract on
the blockchain. Therefore the proxy contract has no chance
to establish the initializing steps in the constructor of logic
contract, and thus we need to do something special in order
to correctly initialize the proxy contract.
Our workaround for it is to use an initializer function
instead of the constructor, and make sure it is only executed
once for a necessary initializing process. Other proposals
could be found as Initializer Contracts [13] [14].
D. Safety Control
Transaction security: ArtChain network assures the se-
curity of users‚Äô accounts and funds by using blockchain
consensus, digital signatures and end-users encrypted wal-
lets. The artwork trading platform provides security services
that are likened to those offered by Ô¨Ånancial institutions. It
integrates data, applications and transactions in blockchain
clouds through the efÔ¨Åcient integration of data storage, net-
work and other resources, so as to create a secure transaction
environment.
Financial Management: ArtChain maintains high stan-
dards of integrity and ethical business conduct and is in
compliance with relevant laws and regulations, as well as
self-regulatory principles of the industry. We also implement
a component to conduct the regulatory duty of Know-You-
Customer (KYC).
E. Privacy and ConÔ¨Ådentiality
ArtChain makes public all ledger nodes and their state
in the network in real time. The transaction history (block
content) and state information in ArtChain are publicly vis-
ible. However, in case of any privacy requirements for some
transactions, such privacy information will be processed.
In the data model design, we carefully decide what data
to be stored on-chain and what off-chain. The design has
been evolved along business needs and regulatory needs.
Currently, the on-chain data store contains information on
artist, the hash of ownership, price, and history. The hash
of ownership protects the privacy for owners who do not
want to be known to the public, as well as in compliance
with privacy regulations, such as the General Data Protection
Regulation (GDPR)3.
V. PERFORMANCE EVALUATION
We conduct an extensive performance testing of the
system. We identify that the performance bottleneck of the
system is the low-level I/O efÔ¨Åciency of the Ethereum client,
i.e. Geth4 in our system.
ArtChain private chain, based on POA consensus and
5-second block interval and deployed on 6 cloud nodes
(8x2.5GHz CPUs, 32G memory), supports up to 1500 TPS,
i.e., 1500 raw transactions on the chain, far more superior to
Ethereum mainnet (about 15 TPS nowadays). Integrated user
actions, like post new artwork or top up tokens, are usually
comprised of a series of transactions/queries on the chain.
ArtChain on average processes about 40-70 user actions per
second.
3https://eugdpr.org/
4https://geth.ethereum.org/
451
Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA. Downloaded on July 14,2025 at 16:59:39 UTC from IEEE Xplore.  Restrictions apply. 
A. Environment Setup
The private chain is composed of 3 Ali cloud servers (8x
2.5GHz CPUs, 32GB memory, 64GB hard disc), and 3 AWS
cloud servers (8x 2.5GHz CPUs, 32GB memory, 8GB hard
disc). Geth version 1.8.17, startup parameter is tuned as:
‚Ä¢ --targetgaslimit 4294967295: increase the gas limit to
0xFFFFFFFF to seal as many transactions as in one
block. Note this need to coordinate with the gasLimit
in the genesis.json Ô¨Åle when creating the chain.
‚Ä¢ --txpool.lifetime 24h --txpool.accountslots 65536 --
txpool.globalslots 65536 --txpool.accountqueue 64 --
txpool.globalqueue 65536: increase txpool so that it
stores as many transactions both account speciÔ¨Åcally
and globally as we submitted.
This paper employ web3.js5 to communicate with the
chain, and to monitor its performance, Wireshark6 is applied
to capture packet for analysis.
B. Throughput Analysis
Basically, blockchain throughput is limited by: a) How
long it needs to generate a block, and b) How many
transactions can be sealed in a block. And theoretical
throughput = (number of transactions in a block)/(block
interval). But in a large-scale network, the throughput is
also restricted by the broadcast speed. An explicit example is
Ethereum mainnet, with network congestion, its throughput
dramatically degrades as nodes need more time to keep
synchronized. This is why Ethereum is considered to have
issues on network scalability.
As for our private chain, we tried following steps to
tune up the system performance: (1) Speed up the block
generation by changing the block interval when generating
the genesis.json. To summary, the chain with 1-second
interval shows the best performance, but 5-second is also
acceptable. (2) Improve the gas limit of the chain. It does not
shows signiÔ¨Åcant improvement on the performance, because
the gas limit is not the bottleneck of the system.
As our chain is only maintained by 6 cloud servers, we
can ignore the effect of network scalability mentioned above.
As long as the transactions are sealed, the nodes always
have adequate time to keep sync. On the contrary, it is the
node‚Äôs hardware conÔ¨Åguration that determines the system
performance. We observe frequently crash of Geth client
on the node with only 8GB memory originally. Using the
node with 32GB memory, the performance is signiÔ¨Åcantly
improved, but the crash still occurs in certain scenarios.
Geth is thought as a memory monster whose design
follows a ‚ÄúI use up what I have‚Äù idea, and will use up
all available memory on the server. By default, our node
servers disable the swap and will kill Geth process if it tries
to use up the memory. Unfortunately, this always occurs.
5https://web3js.readthedocs.io/en/1.0/
6https://www.wireshark.org/
We observed it used up 8Gb memory when trying to create
70 new accounts. A suggestion is to enable the swap on the
node, in terms of the sacriÔ¨Åce of the performance. Note the
AWS cloud server has only 8GB disc space, and so the swap
space is restricted on AWS servers.
C. Test Results
1) Raw transaction test: The chain is conÔ¨Ågured with 5-
second block interval and we get that (1) Transaction carries
data of 50 bytes, it is a typical value for general transactions.
(2) Establishes 2000 transactions in about 6-8 seconds per
node. (3) Establishes 20000 general transaction queries in
2-5 seconds per node.
2) API
based
test:
APIs
such
as
check user(),
check transaction() and check artwork() only query
information from the chain and do not include any
practical transactions. So they show as high throughput
as general queries. It only depends on the processor
and network performance. APIs such as buy tokens(),
post new artworks() and freeze tokens() combine a se-
ries of queries and transactions, and these operations usually
depend on the result of the precedent, so those APIs have
bad parallel performance. For example, post new artwork
includes 16 low-level operations:
‚Ä¢ 2x eth.sendTransaction
‚Ä¢ 1x personal.unlockAccount
‚Ä¢ 1x eth.estimatesGas
‚Ä¢ 2x eth.gasPrice
‚Ä¢ 6x eth.getTransactionReceipt
‚Ä¢ 2x eth.subscribe
‚Ä¢ 2x eth.unsubscribe
Some test results are listed below:
‚Ä¢ Establish 116 times API post new artworks() within
about 18-20 seconds per node.
‚Ä¢ Establish 58 times API buy tokens() within about 5-6
seconds per node.
API add new user() contains a low-level operation of
personal.newAccount, which uses signiÔ¨Åcant memory and
CPU cycles. A typical result is listed below:
‚Ä¢ Establish 64 times API add new user() within about
20 seconds per node.
3) Test on different block interval: We tested on different
block intervals of 1 second, 2 seconds, 5 seconds and 15
seconds. The comparison of API based throughput with
different block intervals is summarized in Figure 7.
As all the APIs are called at the same time during the
test, we observe actually all transactions are sealed in one
block. Our chain is fully capable of guarantee that. So be-
sides the block interval difference, those calling procedures
need almost the same processing time on the network and
processes. That is why the different block interval practically
results in different throughput.
452
Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA. Downloaded on July 14,2025 at 16:59:39 UTC from IEEE Xplore.  Restrictions apply. 




%ORFNLQWHUYDOVVHFRQG











1XPEHURIRSHUDWLRQVQRGHVHFRQG
SRVWBQHZBDUWZRUN
EX\BWRNHQV
Figure 7.
Test under different block interval
4) Test on node crash: Geth client crashes under cer-
tain scenarios. What we notice is that transactions like
personal.newAccount(included in API add new user())
make Geth consume lots of memory. Got in tests:
‚Ä¢ On the node conÔ¨Ågured with 32GB memory, Geth could
support up to 70 concurrent add new user() calls.
‚Ä¢ Geth
crash
when
submitting
more
than
70
add new user() calls. It is killed by OS after
using up all 8GB memory.
We then try to enable 32GB swap on the server,
and Ô¨Ånd that Geth succeeds processing 96 concurrent
add new user() calls. During the process, it used up 32GB
physical memory, and then 9.1GB swap memory. As a result,
it uses as long as 914 seconds to establish all the calls.
As a comparison, it needs only about 20 seconds for 64
calls without using swap memory. Performance degradation
is obvious.
D. Bottleneck of the System
Based on our performance test, we Ô¨Ånd out that: (1) The
performance bottleneck of our system is at the Geth IO
execution. (2) The way to improve the system performance
is to improve node hardware conÔ¨Åguration.
According to [15], Ethereum uses LevelDB as the
database to store key/value. The key to accessing database
is irregular on account of the discreteness of hash. The
LevelDB has an excellent performance in reading/writing
continuously, while bad for the random key. Therefore, the
time t for accessing LevelDB would be longer as the amount
of data storage increases. In fact, the test results show that
if n is large enough, the value of t will increase and the
eciency will degrade largely for some data which not hit
LevelDB cache at times.
Geth consumes huge memory on certain transactions,
e.g., personal.newAccount, and will crash when receiv-
ing multiple concurrent memory-consuming transactions. A
suggestion is to enable swap memory on the node to improve
system stability, at the sacriÔ¨Åce of the performance (See
performance degradation when memory is swapped). We
suggest 4GB of swap space on the nodes, based on the
performance test result. This improves the system stability
and does not degrade the performance signiÔ¨Åcantly.
VI. RELATED WORK
In this section, we mainly review the work that closely
related to this work, for more work about blockchain and
the related applications, please refer to [1], [16].
Art as Digital Assets: Arts can be regarded as the
digital asset to be stored on the blockchain platform. The
blockchain inherently holds the property of authenticity,
traceability, and irreversibility which can perfectly pro-
tect the digital assets for each masterpiece. Usually, the
blockchain-based solution marks each masterpiece with an
ID, may denote as token in smart contract. Similarly, many
protocols are designed to trade the nonÔ¨Ånancial assets in
form of tokens on the blockchain platform
Blockchain Solution: Since digital assets need proper-
ties both on authenticity and security, blockchain becomes
the primary selection for the requirements. There are three
options, including private blockchain, consortium blockchain
and public blockchain. Due to the high security of the
assets, the most suitable solution is the consortium methods,
which relatively has a better trade-off between performance
and security. The asset-based property is deployed on the
application-layer of the blockchain, regulated by the rules
deÔ¨Åned in smart contract. There are plenty of applications
successfully executed on top of blockchain [17] and sub-
sequently the infrastructure [18] becomes more complete
along with the development. Our solution provides a trading
infrastructure for art, and it provides an paradigm for other
high value commodities.
Privacy Protection: For the precious digital art assets,
it is fundamental to protect the privacy of assets. There
are two kinds of privacy in research, including identity
privacy and transaction privacy. Identity privacy publicly
links the real identity and transaction scripts, and there are
several behavioral analysis strategies, including anti-money
laundering and know your customer (KYC) to present the
usage graph. Transaction privacy means the plain contents
on the ledger, including the plain transferring value, account
direction, and so on. Some adversaries may draw attentions
to watch even monitor some accounts with huge amounts of
property. Furthermore, there are several methods to achieve
the high level protected blockchain. [19] employed the
mixer to obfuscate the relationships among people. Maxwell
proposed the ConÔ¨Ådential Transaction and Ô¨Årstly achieved
the implemented with the range proof scheme. [20] [21]
Ô¨Ånished the privacy preservation protocols based on ring
signature. [22] sealed the plain amounts by using Paillier
cryptosystem. [23] provides a complete solution to make
the sensitive information unreadable for the public. Our
453
Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA. Downloaded on July 14,2025 at 16:59:39 UTC from IEEE Xplore.  Restrictions apply. 
system relies on the original chain security and provides
protection on the layer of web servers and back-end. This
design decision comprehensively considers the performance
and security for the whole integrated system as a trade-off.
VII. CONCLUSIONS
In this paper, we presented the ArtChain, which is an
platform designed with registration, tracking, protection, and
provenance for artworks enabled by blockchain technology.
We also discussed how to design, implement and deploy the
blockchain platform in operation as a working product in
practice. The proposed blockchain implementation and Ex-
perimental results showed that our system towards artworks
can provide a complete blockchain-based solution with the
property of irreversibility, authentication, traceability and
transparency.
In future, we plan to work on anti-counterfeiting for the
original works of art by integrating with the smart modules
of IoT, and activating relevant smart hardware and other
functionality (e.g. positioning/location tracking) as required
by artists or collectors.
"
pdf//A_High_Performance_Blockchain_Platform_for_Intelligent_Devices.pdf;This paper explores the  possibility of building a high performance blockchain  platform for intelligent devices to shift from traditional  services providers to data value providers and consumers, so  that it can create more value.;The blockchain technology has the characteristics of  high security, decentralization, and tamper-proof, which  enables all participants to realize value interconnection and  transmission at a very low cost.;D. Economic Model  Intelligent devices need to pay a certain amout of tokens  to upload the users¬∂V behavioral data, so as to prevent the  device from maliciously uploading a large number of invalid  data and causing network congestion.;This paper explores the  possibility of building a high performance blockchain  platform for intelligent devices to shift from traditional  services providers to data value providers and consumers, so  that it can create more value.;[('device', 44), ('intelligent', 38), ('intelligent device', 35), ('blockchain', 29), ('datum', 26), ('node', 26), ('network', 11), ('high', 10), ('token', 9), ('value', 8)];;;"Shitang Yu (ystang@grgbanking.com), Kun Lv (lkun10@grgbanking.com), Yingcheng Guo, Jun Zou(zjun23@grgbanking.com), Bo Zhang(zbo20@grgbanking.com) are with 
Department of Research and Development, GRG Banking Blockchain, Guang Zhou, China 
Zhou Shao is with China Computer Federation, Technical Committee of Blockchain 
A High Performance Blockchain Platform  
for Intelligent Devices 

^≈ö≈ù∆öƒÇ≈∂≈êz∆µÕï<∆µ≈∂>«ÄÕï≈ö≈Ω∆µ^≈öƒÇ≈ΩÕïz≈ù≈∂≈êƒê≈öƒû≈∂≈ê'∆µ≈ΩÕï:∆µ≈∂≈Ω∆µÕï≈Ω≈öƒÇ≈∂≈ê
Abstract¬≤In the area of IoT (Internet of Things), more and 
more intelligent devices are being connected to the Internet. 
These intelligent devices have been producing a huge amout of 
useful data over time, however there is still a lack of a platform 
which can efficiently transfer and utilize the value of the 
massive IoT data. Blockchain is able to transfer value with a 
relative low cost, which makes it possible for the data from 
smart devices to create economic value. This work of  this 
paper is to design a high performance blockchain platform, 
using technologies such as distributed network architecture, 
intelligent devices node mapping, as well as PBFT-DPOC 
consensus algorithm to realize the decentralized autonomy of 
intelligent devices. 
Index terms¬≤Blockchain, Intelligent Device Nodes Mapping, 
PBFT-DPOC 
I.
INTRODUCTION
People are benefiting more and more from technological 
advancement, and enjoying more convenient and efficient 
services provided by intelligent devices, such as traffic 
lights, automatic vending machines, etc. In the past, people 
did not realize or could not capture the plentiful valuable 
data generated while using these devices. However, with the 
increase of awareness promoted by the big data boom, it has 
been a universal consensus that data is the most valueable 
asset of a business. With sound protection of data privacy, 
people are trying to make better use of the data created by 
intelligent devices. However, at present, there is no 
comprehensive platform that can make the intelligent devices 
easy to access and continuously exchange data value at low 
cost. The blockchain technology has the characteristics of 
high security, decentralization, and tamper-proof, which 
enables all participants to realize value interconnection and 
transmission at a very low cost.This paper explores the 
possibility of building a high performance blockchain 
platform for intelligent devices to shift from traditional 
services providers to data value providers and consumers, so 
that it can create more value. 
II.
RELATED WORK
   In order to build an efficient blockchain network for 
intelligent devices, this paper makes a in-depth study on 
characteristics and mechanism of blockchain technology and 
intelligent devices network. 
A.
Blockchain
Blockchain technology is a new technology that 
integrates 
decentralization, 
distributed 
computation, 
asymmetric encryption, timestamp, consensus algorithm[1]. 
It provides a distributed ledger that simplifies account 
reconciliation process through encryption techniques and 
distributed message transmission protocol, and maintains a 
large amount of data through decentralization. It is able to 
boost data processing efficiency, and provides data sharing 
function while still ensuring data security. Therefore, 
comparing to traditional technologies, blockchain technology 
is 
equipped 
with 
the 
strengths 
of 
sustainability, 
compatibility, data sharing, and interconnectivity. 
B.
Internet of Intelligent Device 
At present, most intelligent devices are connected to the 
central server of their corresponding carriers through 
network optical fiber, to increase the maintenance 
efficiency[2]. At the same time, there are very few intelligent 
devices to further utilize users¬∂ data. The advancement of 
online payment technology enables the intelligent devices to 
obtain information of actual users. Through further analysis 
and use of data, it can realize functions such as distributing 
the rights and interests of users' consumption data by 
intelligent devices and pushing targeted advertisements, and 
realize higher value of data. 
III.
PROPOSED SOLUTION
In order to ensure the security and stability of the system, 
the inherent characteristics of intelligent devices, such as 
functional specificity and minimum system configuration, 
are fully considered in the design of the system. In the 
process of joining the blockchain network, intelligent devices 
GR QRW DFWXDOO\ FDUU\ RXW ¬≥PLQLQJ¬¥ RU VLPLODU UHVRXUFH-
consuming proof of work, so as to ensure the stable 
operation. 
A.
Network Architecture 
This system mainly adopts a three-layer architecture, 
including the intelligent device layer, blockchain layer and 
DAPP layer, in which the intelligent devices and blockchain 
nodes are connected by the mechanism of node-to-node 
mapping, as shown in the Fig. 1 below. Distributed 
architecture is adopted among blockchain nodes to realize 
the sharing and maintenance of accounts through consensus 
algorithm. DAPP layer mainly provides data service 
interface for data consumers. DAPP developers can develop 
personalized DAPP applications according to users' actual 
needs. The open blockchain system adopts the mode of 
issuing token for incentivizing users and distributing equity, 
so as to encourage all participants to actively participate in 
system maintenance and ensure its stable operation. 
B.
Intelligent Device Nodes Mapping 
    Due to the limited hardware resource of intelligent 
devices, the utilization of the intelligent device for resource-
consumptive 
¬≥mining¬¥ 
operation 
may 
cause 
device 
downtime or other problems. Therefore, this paper proposes 
a node-to-node mapping mechanism. In this mechanism, 
each intelligent device can be mapped to a node in the 
blockchain network through the identity registration 
protocol, and then participate in the verification and 
maintenance of the entire intelligent device blockchain. This 
978-1-5386-4870-4/18/$31.00 ¬©2018 IEEE
260
Proceedings of 2018 1st IEEE International Conference on Hot Information-Centric Networking (HotICN 2018)
Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA. Downloaded on July 14,2025 at 17:01:06 UTC from IEEE Xplore.  Restrictions apply. 
node can be either a lightweight node or a Block Producer 
node. Intelligent devices can share users' useage data in the 
blockchain network through this node, and get rewards after 
the data is consumed and used by others. 
C.
PBFT-DPOC Consensus Algorithm 
Numerous devices and their limited hardware resources 
will exert great pressure on the blockchain network if all 
nodes participate in bookkeeping activities. Therefore, this 
paper puts forward a new DPOC (Delegated Proof of 
Contribution) algorithm to enable any node in the network to 
run for BP (Block Producer). Candidates need to contribute 
their own hardware infrastructure (including computing 
power, storage, and bandwidth), and all nodes can take part 
in voting. The final campaign ranking is determined by votes 
DQGPLQHU¬∂VZHLJKW-sum ranking of seniority. The actual vote 
is calculated by the following formula: 








N
0
N
1
6
Q
L
L

u

u
 ¬¶
 

Where S is the number of votes; 
L
1
is the number of 
votes for node i; k is the proportion coefficient of token; M is 
candidate's seniority. 21 super nodes and several substitute 
nodes will be generated during the voting process. These 
super nodes generate blocks through PBFT (Practical 
Byzantine Fault Tolerance) algorithm and finally reach 
consensus[3][4]. Every block has the digital signature of the 
remaining BP nodes, and if a dishonest or inactive node is 
found during the block verification process, it will be 
blacklisted and replaced by a substitute node. 
D.
Economic Model 
Intelligent devices need to pay a certain amout of tokens 
to upload the users¬∂V behavioral data, so as to prevent the 
device from maliciously uploading a large number of invalid 
data and causing network congestion. At the same time, after 
a BP node generates a block, it will receive a certain number 
of tokens as reward, which will encourage more nodes to 
compete for bookkeepig, and they collectively maintain the 
consistency of the blockchain ledger. DAPP developers, who 
develop personalized applications for intelligent devices, 
need to pay a certain amount of tokens for deploying DAPP 
to the blockchain, and tokens can be earned from DAPP 
users as a service charge. In order to obtain the 
corresponding data resources, the data consumer needs to 
pay some tokens to the data producer before using the data. 
Ordinary users of intelligent devices, can obtain certain token 
rewards after using intelligent devices and use these tokens 
to exchange goods or services from various device operators. 
IV.
RESULTS
This paper tested the transaction throughput and system 
delay of the intelligent device blockchain, and compared it 
with the performance of public blockchains such as Bitcoin 
and Ethereum[5][6]. 
Fig. 2. Throughput and latency results of different blockchains  
The result in Fig. 2 shows that the intelligent device 
blockchain has higher transaction throughput and lower 
transaction latency than that of Bitcoin and Ethereum. 
V.
CONCLUSION
The main contribution of this paper is the design of a 
high performance blockchain platform for intelligent devices. 
The platform achieves efficient connection of intelligent 
devices through the node-to-node mapping mechanism of 
intelligent devices. At the same time, we design a blockchain 
consensus algorithm for intelligent devices, which provids 
higher 
consensus 
efficiency 
while 
guarantee 
the 
decentralization, provide higher efficiency. This system can 
make all the relevant parties of the intelligent devices obtain 
higher efficiency and benefits, and achieve a result of multi-
win. 
"
pdf//A_Lightweight_Blockchain-Based_Privacy_Protection_for_Smart_Surveillance_at_the_Edge.pdf;Hence, we will design the state-of-the art object detection model, and make an apropos ofÔ¨Çine training on sufÔ¨Åciently large data set.;The initial conditions of the chaotic generator that comprises both Ô¨Çoating and integral values are used as the key.;The trained model will be loaded to the edge devices.;The initial conditions of the chaotic generator that comprises both Ô¨Çoating and integral values are used as the key.;[('privacy', 50), ('video', 46), ('camera', 34), ('smart', 32), ('surveillance', 31), ('blockchain', 28), ('system', 27), ('edge', 24), ('access', 23), ('object', 23)];2020.0;;"A Lightweight Blockchain-based Privacy Protection
for Smart Surveillance at the Edge
Alem Fitwi‚Ä†, Yu Chen‚Ä†, Sencun Zhu‚Ä°
‚Ä†Dept. of Electrical & Computer Engineering, Binghamton University, SUNY, Binghamton, NY 13902, USA
‚Ä°Dept. of Computer Science and Engineering, Penn State University, University Park, PA 16802, USA
Emails: {aÔ¨Åtwi1, ychen}@binghamton.edu; szhu@cse.psu.edu
Abstract‚ÄîWitnessing the increasingly pervasive deployment
of security video surveillance systems(VSS), more and more
individuals have become concerned with the issues of privacy
violations. While the majority of the public have a favorable
view of surveillance in terms of crime deterrence, individuals
do not accept the invasive monitoring of their private life. To
date, however, there is not a lightweight and secure privacy-
preserving solution for video surveillance systems. The recent
success of blockchain (BC) technologies and their applications
in the Internet of Things (IoT) shed a light on this challenging
issue. In this paper, we propose a Lightweight, Blockchain-based
Privacy protection (Lib-Pri) scheme for surveillance cameras at
the edge. It enables the VSS to perform surveillance without
compromising the privacy of people captured in the videos.
The Lib-Pri system transforms the deployed VSS into a system
that functions as a federated blockchain network capable of
carrying out integrity checking, blurring keys management,
feature sharing, and video access sanctioning. The policy-based
enforcement of privacy measures is carried out at the edge devices
for real-time video analytics without cluttering the network.
Keywords-Privacy, Lightweight Blockchain, Smart Surveil-
lance, Edge Device, Off-site Storage.
I. INTRODUCTION
Video surveillance cameras are pervasive in public places in
response to growing security concerns [11], [16]. According
to a report produced by IHS Markit, there are about 245
millions surveillance cameras in operation today. London is
the city with the highest number of cameras, where an average
Londoner is estimated to be caught on camera 300 times a
day. The number in China is expected to grow more than
three times by the year 2020 [1], [15]. Clearly individuals‚Äô
privacy is at stake! People are being observed with or without
their awareness almost wherever they go. This situation widely
incurs concerns in the violation of individual‚Äôs privacy.
The more powerful the modern surveillance cameras be-
come, the more likely they are to be abused to gather private
information. Authorized security personnel in charge of the
surveillance system might abuse the cameras for voyeurism,
cyber stalking, and unauthorized collection of data on activities
or behaviors of individuals [13], [15], [17]. Maneuverable
cameras, like pan-tilt-zoom (PTZ) camera, could be abused
and directed to intrusively spy on other people in their
apartments. For instance, there was an investigation launched
after a security guard spied on the private apartment of the
German Chancellor Angela Merkel using a museum‚Äôs closed
circuit television (CCTV) camera [1], [6]. Obviously, while
the beneÔ¨Åts of surveillance greatly outweigh the potential risks,
surveillance and the privacy of people should be balanced out.
There has been a number of efforts to address the privacy
requirements through the introduction of smart cameras with
embedded privacy curtailments in lieu of trying to abandon the
practice of surveillance [4], [13], [15], [17], [18]. However, a
resource and bandwidth aware privacy-protection mechanism
is still missing in most surveillance camera systems today.
The Bitcoin has substantiated how the BC technology can
decentralize trusted computing models [10]. A light-weight
blockchain along with the concept of identity-based distributed
data possession in multi-cloud storage can be leveraged to
ensure privacy and authorized access in smart surveillance [3],
[7], [9], [14]. Due to concerns on privacy and performance
issues, however, public blockchain is not an ideal candidate.
Instead, a private blockchain has been considered where
only authenticated member nodes join [2], [19]. Therefore,
a lightweight, closed-group blockchain that supports decen-
tralized applications like surveillance that entails high speed
and privacy could meet the requirements.
In this position paper, a lightweight blockchain-based pri-
vacy protection (Lib-Pri) scheme for smart surveillance at the
edge is proposed. It enables the construction of a privacy-
aware smart surveillance system by integrating the advanced
features of BC and smart contract with object detection (OD)
technologies coupled with image scrambling techniques. The
Lib-Pri system consists of three major parts in this privacy
and resource aware service: smart cameras, BC nodes and
users. The smart cameras are the edge devices with embedded
conÔ¨Ågurable set of privacy policies. The cameras capture
videos and process them using the attached single board
computer (SBC), e.g. the new Jetson Nano Module, a Tinker
board or Raspberry Pi. Privacy-sensitive objects are detected
and corresponding privacy protection measures are enforced.
The BC network ensures authenticity. Users are assigned with
different levels of access privileges to the videos, which are
deÔ¨Åned in the smart contracts. In addition, an isolated storage
system is considered for the storage of reversibly scrambled
images or videos for law enforcement purposes.
The remainder of this paper is structured as ensues. The
architecture of the Lib-Pri system is described in Section II
followed by the explication of the privacy polices in Section
III. At last, the conclusive remarks and the direction of our
ongoing research are presented in Section IV.
552
2019 IEEE International Conference on Blockchain (Blockchain)
978-1-7281-4693-5/19/$31.00 ¬©2019 IEEE
DOI 10.1109/Blockchain.2019.00080
Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA. Downloaded on July 14,2025 at 17:00:20 UTC from IEEE Xplore.  Restrictions apply. 
Fig. 1.
Privacy-preserving Lite Blockchain-based Smart Surveillance.
II. LIB-PRI SYSTEM: ARCHITECTURE AND COMPONENTS
Figure 1 portrays the high-level overview of the proposed
Lib-Pri system, the Lightweight BC-based Privacy Protection
for smart surveillance at the edge. It comprises smart cameras
as edge devices, BC nodes, authorized users such as security
personnel or law enforcement ofÔ¨Åcials, and off-BC storage.
A. Smart Surveillance Cameras At The Edge
The smart cameras function as edge devices. They capture
videos, perform frame splitting and reversible blurring follow-
ing an object detection as per the deÔ¨Åned policies conÔ¨Ågured
in each camera. A pre-trained machine learning (ML) neural
network (NN) is loaded onto the edge for multiple objects
detection within a budgeted time. Features are extracted for
OD, detected objects that match those on the policy are
bounded, a blurring key is generated and securely shared by
means of a public crypto-system, and then the sensitive objects
are chaotically masked at the edge. The smart cameras also
support the opt-out policy when no attention is paid to privacy.
This boosts the public conÔ¨Ådence that their images or videos
captured by the surveillance cameras will not be abused. The
opt-out option is deÔ¨Åned in the smart contract, and it renders
the privacy policy useless when triggered by authorized users.
Many of the existing CCTV systems are centralized and
not ‚Äúsmart‚Äù. Videos analytics are performed at a centralized
locations. With the mounted SBCs, it is feasible to deploy
and run pre-trained object detection ML algorithms on edge
devices. Performing video analytics, information distillation,
object detection, and human face denaturing at the edge dras-
tically reduces the cameras egress bandwidth consumption.
Meanwhile, edge devices still suffer from resource constraints.
As a consequence, at times when the smart cameras fail to
meet the requirements of real-time video analytics, adopting a
hybrid of edge and fog computing paradigms is an alternative.
Some of the tasks will be ofÔ¨Çoaded to a near-site fog node,
i.e. a laptop, a tablet, or a smartphone.
B. The Lightweight Blockchain Network
A permissioned, private BC network is envisioned in the
Lib-Pri system, which is not open to public access. The Lib-Pri
system employs privacy-preserving smart contracts that deÔ¨Åne
privileges and access rules, which allow authorized users
access the videos without violating the privacy of individuals.
The existing smart contract however doesn‚Äôt preserve the
privacy and conÔ¨Ådentiality of personal Ô¨Åles or data when
shared to the BC nodes. In our proposal, the smart contract is
tailored for better handling of the privacy and conÔ¨Ådentiality
issues. Users who try to access the video need to prove
themselves to the blockchain that they have the permission.
Besides, correctness of the references are validated by every
other node so that only authorized accesses are made and the
integrity of the video storage is veriÔ¨Åable. The reference in
this paper points to a variable on a mapping table that contains
actual references to the videos.
C. Off-Blockchain Storage
Storing data on the blockchain is expensive and the storage
requirements are impractical if video streams are stored in
replicated forms in every node of the blockchain network. As
a solution, a storage server/servers outside the blockchain net-
work is considered that could be connected to the blockchain.
The connection is made as per the business rules deÔ¨Åned on the
smart contract. Only videos and images deemed important for
later law enforcement purposes are stored in the off-network
storage. Video frames containing objects that show offensive
behaviors and fugitives are marked according to the predeÔ¨Åned
policies and are pushed to the storage. The hashed references
and germane access details are stored on the blockchain.
Besides, access histories important for auditing are logged
and stored on the off-BC storage. Only their references are
similarly shared to the BC nodes.
The blurring keys sharing is managed using a public key
crypto-system in two stages; between smart cameras and BC
nodes, and between the BC nodes and the off-BC storages
as necessary. When there is no need to store videos, the Ô¨Årst
stage of key management sufÔ¨Åce. The second stage is required
only when videos have to be stored for later use. Then, keys
are revoked the moment the corresponding video is deemed
unwanted and deleted.
D. Object Detection, Bounding And Masking
Mechanisms that could perform live video frame denatur-
ing for privacy purpose are required to be robust and fast.
Therefore, the accuracy, sophistication, and speed of live-video
processing method is vital. The functionality of our Lib-Pri
system includes detecting objects in an image or video frame,
adding bounding box, and applying reversible chaotic mask to
preserve privacy.
Object detection is a compute-intensive process. Hence, we
will design the state-of-the art object detection model, and
make an apropos ofÔ¨Çine training on sufÔ¨Åciently large data set.
The trained model will be loaded to the edge devices. In order
to avoid any possible violation of the budgeted time for live
553
Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA. Downloaded on July 14,2025 at 17:00:20 UTC from IEEE Xplore.  Restrictions apply. 
video analytics, the fog server works along with an edge device
that supports pipe-lining and parallel processing of frames to
expedite the process.
Following the successful detection of an object and extrac-
tion of coordinates of the bounding box, masking is done using
a chaotic method to conserve privacy. The method is inspired
by the earlier reported researches [5], [12], [18]. The initial
conditions of the chaotic generator that comprises both Ô¨Çoating
and integral values are used as the key.
E. Spotting Fugitives
Our Lib-Pri system is able to identify fugitives after the Ô¨Årst
time they were caught doing something deemed an aggressive
or a criminal act. Once some individuals were detected (with
visible face) doing something wrong and disappeared, the
authorized law enforcement people are provided with the
option to Ô¨Çag the germane video frames or images containing
misconduct as wanted. The fugitive‚Äôs facial features required
for comparison are dispatched to the edge with their original
references pushed to the blockchain network nodes. When
a match is obtained by any of the cameras demanded to
spot the escapees, they will send an immediate alert message
comprising the location and identity of the fugitive.
III. PRIVACY POLICIES
As far as video surveillance is concerned, a number of argu-
ments and views have been raised pro and against of it. Covert
government surveillance is one of the push factors that caused
the public to grow suspicious about it. Governments often
quote the famous Margalit‚Äôs saying: ‚ÄúIf you have got nothing
to hide, you have got nothing to worry about.‚Äù However, many
argue against that it is never all about hiding something, it is all
about that being none of other people‚Äôs business. They argue
in favor of the quote ‚ÄùI don‚Äôt have anything to hide, but I don‚Äôt
have anything I feel like showing to you, either‚Äù [8]. Putting it
another, many people concur on the usefulness of surveillance
system for security purposes but they Ô¨Årmly believe that
the indiscriminately pervasive and expansive deployment has
endangered constitutionally enshrined values like the right of
anonymity, a form of privacy. People going to bars, infertility
clinic, doctors, etc. want to be anonymous. But cameras in
public places enable ofÔ¨Åcials to non-selectively observe these
routine activities of individuals irrespective of whether they are
law-abiding citizens or criminals. Besides, there is a risk that
recorded footage can be abused or leaked. Hence, the public
want the surveillance system to be aware of privacy-sensitive
things.
Therefore, privacy and access policies are included in the
Lib-Pri system to guard against the abuses of surveillance
videos by authorized ofÔ¨Åcials or other users, including un-
warranted monitoring, peeping, and leaking. Privacy policies
that specify which objects or video frames should be denatured
are incorporated in smart cameras, or more precisely speaking,
on the mounted edge computing devices. The privacy policies
recognize the scenarios, objects, activities, or simply locations
Fig. 2.
The Object Detection, Masking, and Access policing Processes.
that are not permitted to be posted publicly. The Ô¨Åne-grained
access privilege policies deÔ¨Åne who accesses what and how.
Access control is enforced by the smart contract embedded
in the BC network. As a private BC network, the access is not
anonymous as what the public blockchain network allows for
Bitcoin. The user has to be veriÔ¨Åed as one of the privileged
users who are authorized to watch the requested videos. The
policy is set to ensure that things are effectively obscured if
they have the potential of revealing information pertinent to
an individual‚Äôs privacy. The contents or objects considered in
the privacy policy of our proposed system are listed as ensues.
The entire policing process is depicted in Fig. 2.
1) By default, the face of every captured individual is
reversibly scrambled. Faces can only be recovered when
proof to verify the identity of someone engaged in
misdeeds is required (for example at a court of law).
2) To prevent peeping at people doing private things at
home or capturing videos via windows by maneuver-
ing cameras, objects on frames identiÔ¨Åed as windows
are reversibly masked at the edge. This is an act of
voyeurism unless cameras are warranted to do so in an
opt-out mode. Another case where the opt-out option
could be enforced is when, for instance, drones with
smart cameras are on exigent or search-and-rescue mis-
sion where clear detection of humans or objects is of
paramount importance and privacy is the least concern.
3) Bedrooms, bathrooms, plate numbers, personal informa-
tion tags, and other things that could reveal information
that leads to potential privacy breach are masked.
4) Fine-grained access control policies and privileges are
set as part of the privacy policies. They can be legiti-
mately and authorizedly updated or revoked at any time.
5) In a frame containing nude images of individuals the
face, genitals, buttocks, and breasts are scrambled.
554
Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA. Downloaded on July 14,2025 at 17:00:20 UTC from IEEE Xplore.  Restrictions apply. 
6) Video frames with aggressive behaviors like throwing a
Ô¨Åst, pointing guns, and an act of vandalizing properties
are Ô¨Çagged and stored for later law enforcement uses.
7) References to the identities of viewers or those who
access the videos are embedded into the video frames
they viewed or accessed to reduce unauthorized leaking.
8) To prevent leaking of videos or images, videos or images
stored cannot be transferred or copied. They can only
be viewed by authorized law enforcement people with
the right privileges. Only when need arises, warranted
people could do the transfer or copying activities.
9) Keys generated for denaturing frames at the camera
end are automatically added to the authorized viewers‚Äô
details on the blockchain based on their privileges and
access nuances deÔ¨Åned on the privacy policies. A key is
kept as long as a reference to the corresponding stored
video exists in the BC nodes.
10) There is an opt-out option which could be triggered by
authorized users whenever privacy is deemed unimpor-
tant. For instance, for live examination proctoring, the
blurring option might not be required.
11) Different nodes of the blockchain network could have
different sets of policies. Even cameras could be set indi-
vidually or zone-wise to have different privacy policies.
12) The smart contracts contain attributes common across
the surveillance facility on top of the attributes and
requirements unique to each organization or community
who own the system.
13) Access histories of stored or viewed videos are logged
and shared onto the blockchain based on the details
deÔ¨Åned in smart contracts. Viewer‚Äôs identity, time of
view or access, privileges, and references of accessed
parts are logged and stored.
IV. CONCLUSIONS AND WORKS IN PROGRESS
It is a violation of the privacy rights of individuals and
a debacle of the rule of law to covertly and non-selectively
monitor people regardless of whether they are suspects or
not. This is how most of today‚Äôs safety/security surveillance
systems operate. They give the least concern to privacy.
In this position paper, we are intending to integrate and
leverage the advantages of the blockchain, smart contract,
object detection, and edge computing technologies to make
the existing video surveillance systems privacy-aware. In the
proposed Lib-Pri system, frame splitting, object detection and
bounding, and policy-based enforcement of privacy measures
are performed at the edge devices, i.e. the smart cameras,
to enable real-time video analytics without congesting the
communication network. Offensive behaviors of individuals
are detected by an object-detection network on the edge device
and is then ofÔ¨Çoaded to an off-blockchain storage. Fugitives
are also identiÔ¨Åed by comparing previous facial features and
those extracted from the live video frames. To discourage
leaking of videos and images, information speciÔ¨Åc to the
viewers is embedded into the videos/images automatically and
a corresponding log-reference is pushed to the BC.
Our on-going efforts consist of multiple tasks, including:
‚Ä¢ Data set collection and labeling for the NN training;
‚Ä¢ Polishing and encoding the proposed privacy policies into
smart contracts; and
‚Ä¢ A prototype of the Lib-Pri system is being built, which
includes multiple surveillance cameras with SBCs like
mounted Raspberry Pi, smartphones and laptops that
function as fog devices.
"
pdf//Decentralizing_Privacy_Using_Blockchain_to_Protect_Personal_Data.pdf;autonomous deployment of a PDS which includes a mecha- nism for returning computations on the data, thus returning answers instead of the raw data itself [6].;The amount of data in our world is rapidly increasing.;Both the service and the user can now query the data using a Tdata transaction with the pointer (key) associated to it.;2) We illustrate through our platform and a discussion of future improvements to the technology, how blockchains could become a vital resource in trusted-computing. Organization.;[('datum', 70), ('s', 50), ('blockchain', 46), ('sig', 37), ('user', 36), ('service', 27), ('store', 21), ('node', 21), ('system', 20), ('protocol', 20)];;;"Decentralizing Privacy: Using Blockchain to Protect
Personal Data
Guy Zyskind
MIT Media Lab
Cambridge, Massachusetts
Email: guyz@mit.edu
Oz Nathan
Tel-Aviv University
Tel-Aviv, Israel
Email: oznathan@gmail.com
Alex ‚ÄôSandy‚Äô Pentland
MIT Media Lab
Cambridge, Massachusetts
Email: pentland@mit.edu
Abstract‚ÄîThe recent increase in reported incidents of surveil-
lance and security breaches compromising users‚Äô privacy call into
question the current model, in which third-parties collect and con-
trol massive amounts of personal data. Bitcoin has demonstrated
in the Ô¨Ånancial space that trusted, auditable computing is possible
using a decentralized network of peers accompanied by a public
ledger. In this paper, we describe a decentralized personal data
management system that ensures users own and control their
data. We implement a protocol that turns a blockchain into an
automated access-control manager that does not require trust in
a third party. Unlike Bitcoin, transactions in our system are not
strictly Ô¨Ånancial ‚Äì they are used to carry instructions, such as
storing, querying and sharing data. Finally, we discuss possible
future extensions to blockchains that could harness them into a
well-rounded solution for trusted computing problems in society.
Keywords‚Äîblockchain; privacy; bitcoin; personal data
I.
INTRODUCTION
The amount of data in our world is rapidly increasing.
According to a recent report [22], it is estimated that 20% of
the world‚Äôs data has been collected in the past couple of years.
Facebook, the largest online social-network, collected 300
petabytes of personal data since its inception [1] ‚Äì a hundred
times the amount the Library of Congress has collected in over
200 years [13]. In the Big Data era, data is constantly being
collected and analyzed, leading to innovation and economic
growth. Companies and organizations use the data they col-
lect to personalize services, optimize the corporate decision-
making process, predict future trends and more. Today, data is
a valuable asset in our economy [21].
While we all reap the beneÔ¨Åts of a data-driven society, there
is a growing public concern about user privacy. Centralized
organizations ‚Äì both public and private, amass large quantities
of personal and sensitive information. Individuals have little or
no control over the data that is stored about them and how it
is used. In recent years, public media has repeatedly covered
controversial incidents related to privacy. Among the better
known examples is the story about government surveillance
[2], and Facebook‚Äôs large-scale scientiÔ¨Åc experiment that was
apparently conducted without explicitly informing participants
[10].
Related Work. There have been various attempts to ad-
dress these privacy issues, both from a legislative perspective
([4], [20]), as well as from a technological standpoint. Open-
PDS, a recently developed framework, presents a model for
The Ô¨Årst two authors contributed equally to this work.
autonomous deployment of a PDS which includes a mecha-
nism for returning computations on the data, thus returning
answers instead of the raw data itself [6]. Across the industry,
leading companies chose to implement their own proprietary
authentication software based on the OAuth protocol [19], in
which they serve as centralized trusted authorities.
From a security perspective, researchers developed various
techniques targeting privacy concerns focused on personal
data. Data anonymization methods attempt to protect person-
ally identiÔ¨Åable information. k-anonymity, a common property
of anonymized datasets requires that sensitive information of
each record is indistinguishable from at least k‚àí1 other records
[24]. Related extensions to k-anonymity include l-diversity,
which ensures the sensitive data is represented by a diverse
enough set of possible values [15]; and t-closeness, which
looks at the distribution of sensitive data [14]. Recent research
has demonstrated how anonymized datasets employing these
techniques can be de-anonymized [18], [5], given even a small
amount of data points or high dimensionality data. Other
privacy-preserving methods include differential privacy, a tech-
nique that perturbs data or adds noise to the computational
process prior to sharing the data [7], and encryption schemes
that allow running computations and queries over encrypted
data. SpeciÔ¨Åcally, fully homomorphic encryption (FHE) [9]
schemes allow any computation to run over encrypted data,
but are currently too inefÔ¨Åcient to be widely used in practice.
In recent years, a new class of accountable systems
emerged. The Ô¨Årst such system was Bitcoin, which allows
users to transfer currency (bitcoins) securely without a cen-
tralized regulator, using a publicly veriÔ¨Åable open ledger (or
blockchain). Since then, other projects (collectively referred
to as Bitcoin 2.0 [8]) demonstrated how these blockchains
can serve other functions requiring trusted computing and
auditability.
Our Contribution. 1) We combine blockchain and off-
blockchain storage to construct a personal data management
platform focused on privacy. 2) We illustrate through our
platform and a discussion of future improvements to the
technology, how blockchains could become a vital resource
in trusted-computing.
Organization. Section II discusses the privacy problem we
solve in this paper; section III provides an overview of the
platform, whereas section IV describes in detail the techni-
cal implementation; section V discusses future extensions to
blockchains, and concluding remarks are found in section VI.
2015 IEEE CS Security and Privacy Workshops
¬© 2015, Guy Zyskind. Under license to IEEE.
DOI 10.1109/SPW.2015.27
180
Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA. Downloaded on July 16,2025 at 22:57:35 UTC from IEEE Xplore.  Restrictions apply. 
II.
THE PRIVACY PROBLEM
Throughout this paper, we address the privacy concerns
users face when using third-party services. We focus speciÔ¨Å-
cally on mobile platforms, where services deploy applications
for users to install. These applications constantly collect high-
resolution personal data of which the user has no speciÔ¨Åc
knowledge or control. In our analysis, we assume that the
services are honest-but-curious (i.e., they follow the protocol).
Note that the same system could be used for other data-
privacy concerns, such as patients sharing their medical data
for scientiÔ¨Åc research, while having the means to monitor how
it is used and the ability to instantly opt-out. In light of this, our
system protects against the following common privacy issues:
Data Ownership. Our framework focuses on ensuring that
users own and control their personal data. As such, the system
recognizes the users as the owners of the data and the services
as guests with delegated permissions.
Data Transparency and Auditability. Each user has
complete transparency over what data is being collected about
her and how they are accessed.
Fine-grained Access Control. One major concern with
mobile applications is that users are required to grant a set
of permissions upon sign-up. These permissions are granted
indeÔ¨Ånitely and the only way to alter the agreement is by
opting-out. Instead, in our framework, at any given time the
user may alter the set of permissions and revoke access to
previously collected data. One application of this mechanism
would be to improve the existing permissions dialog in mobile
applications. While the user-interface is likely to remain the
same, the access-control policies would be securely stored on
a blockchain, where only the user is allowed to change them.
III.
PROPOSED SOLUTION
We begin with an overview of our system. As illustrated
in Figure 1, the three entities comprising our system are
mobile phone users, interested in downloading and using
applications; services, the providers of such applications who
require processing personal data for operational and business-
related reasons (e.g., targeted ads, personalized service); and
nodes, entities entrusted with maintaining the blockchain and a
distributed private key-value data store in return for incentives.
Note that while users in the system normally remain (pseudo)
anonymous, we could store service proÔ¨Åles on the blockchain
and verify their identity.
The system itself is designed as follows. The blockchain
accepts two new types of transactions: Taccess, used for access
control management; and Tdata, for data storage and retrieval.
These network operations could be easily integrated into a
mobile software development kit (SDK) that services can use
in their development process.
To illustrate, consider the following example: a user installs
an application that uses our platform for preserving her privacy.
As the user signs up for the Ô¨Årst time, a new shared (user,
service) identity is generated and sent, along with the asso-
ciated permissions, to the blockchain in a Taccess transaction.
Data collected on the phone (e.g., sensor data such as location)
is encrypted using a shared encryption key and sent to the
blockchain in a Tdata transaction, which subsequently routes
it to an off-blockchain key-value store, while retaining only
a pointer to the data on the public ledger (the pointer is the
SHA-256 hash of the data).
Both the service and the user can now query the data using
a Tdata transaction with the pointer (key) associated to it. The
blockchain then veriÔ¨Åes that the digital signature belongs to
either the user or the service. For the service, its permissions
to access the data are checked as well. Finally, the user can
change the permissions granted to a service at any time by
issuing a Taccess transaction with a new set of permissions, in-
cluding revoking access to previously stored data. Developing
a web-based (or mobile) dashboard that allows an overview
of one‚Äôs data and the ability to change permissions is fairly
trivial and is similar to developing centralized-wallets, such as
Coinbase for Bitcoin1.
The off-blockchain key-value store is an implementation of
Kademilia [16], a distributed hashtable (or DHT), with added
persistence using LevelDB2 and an interface to the blockchain.
The DHT is maintained by a network of nodes (possibly
disjoint from the blockchain network), who fulÔ¨Åll approved
read/write transactions. Data are sufÔ¨Åciently randomized across
the nodes and replicated to ensure high availability. It is
instructive to note that alternative off-blockchain solutions
could be considered for storage. For example, a centralized
cloud might be used to store the data. While this requires some
amount of trust in a third-party, it has some advantages in terms
of scalability and ease of deployment.
user
Taccess 
   (u grants s Access)
encrypted response
service
blockchain
DHT
Fig. 1.
Overview of the decentralized platform.
IV.
THE NETWORK PROTOCOL
We now describe in detail the underlying protocol used
in the system. We utilize standard cryptographic building
blocks in our platform: a symmetric encryption scheme deÔ¨Åned
by the 3-tuple (Genc, Eenc, Denc) ‚Äì the generator, encryption
and decryption algorithms respectively; a digital signature
scheme (DSS) described by the 3-tuple (Gsig, Ssig, Vsig) ‚Äì the
generator, signature and veriÔ¨Åcation algorithms respectively,
1Coinbase bitcoin wallet, http://www.coinbase.com
2LevelDB, http://github.com/google/leveldb
181
Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA. Downloaded on July 16,2025 at 22:57:35 UTC from IEEE Xplore.  Restrictions apply. 
implemented using ECDSA with secp256k1 curve [12]; and
a cryptographic hash function H, instantiated by a SHA-256
[11] implementation.
A. Building Blocks
We now brieÔ¨Çy introduce relevant building blocks that are
used throughout the rest of this paper. We assume familiarity
with Bitcoin [17] and blockchains.
1) Identities: Blockchains utilize a pseudo-identity mech-
anism. Essentially a public-key, every user can generate as
many such pseudo-identities as she desires in order to increase
privacy. We now introduce compound identities, an extension
of this model used in our system. A compound identity
is a shared identity for two or more parties, where some
parties (at least one) own the identity (owners), and the rest
have restricted access to it (guests). Protocol 1 illustrates the
implementation for a single owner (the user) and a single guest
(the service). As illustrated, the identity is comprised of signing
key-pairs for the owner and guest, as well as a symmetric
key used to encrypt (and decrypt) the data, so that the data
is protected from all other players in the system. Formally,
a compound identity is externally (as seen by the network)
observed by the 2-tuple:
Compound(public)
u,s
= (pku,s
sig, pks,u
sig)
(1)
Similarly, the entire identity (including the private keys) is
the following 5-tuple:
Compoundu,s = (pku,s
sig, sku,s
sig, pks,u
sig, sks,u
sig, sku,s
enc)
(2)
Protocol 1 Generating a compound identity
1: procedure COMPOUNDIDENTITY(u, s)
2:
u and s form a secure channel
3:
u executes:
4:
(pku,s
sig, sku,s
sig) ‚ÜêGsig()
5:
sku,s
enc ‚ÜêGenc()
6:
u shares sku,s
enc, pku,s
sig with s
7:
s executes:
8:
(pks,u
sig, sks,u
sig) ‚ÜêGsig()
9:
s shares pks,u
sig with s
10:
// Both u and s have sku,s
enc, pku,s
sig, pks,u
sig
11:
return pku,s
sig, pks,u
sig, sku,s
enc
12: end procedure
2) Blockchain Memory: We let L be the blockchain mem-
ory space, represented as the hastable L : {0, 1}256
‚Üí
{0, 1}N, where N
>>
256 and can store sufÔ¨Åciently-
large documents. We assume this memory to be tamper-
proof under the same adversarial model used in Bitcoin and
other blockchains. To intuitively explain why such a trusted
data-store can be implemented on any blockchain (including
Bitcoin), consider the following simpliÔ¨Åed, albeit inefÔ¨Åcient,
implementation: A blockchain is a sequence of timestamped
transactions, where each transaction includes a variable num-
ber of output addresses (each address is a 160-bit number). L
could then be implemented as follows ‚Äì the Ô¨Årst two outputs
in a transaction encode the 256-bit memory address pointer,
as well as some auxiliary meta-data. The rest of the outputs
construct the serialized document. When looking up L[k], only
the most recent transaction is returned, which allows update
and delete operations in addition to inserts.
3) Policy: A set of permissions a user u grants service s,
denoted by POLICYu,s. For example, if u installs a mobile
application requiring access to the user‚Äôs location and contacts,
then POLICYu,s = {location, contacts}. It is instructive to
note that any type of data could be stored safely this way,
assuming the service will not subvert the protocol and label
the data incorrectly. Safeguards to partially prevent this could
be introduced to the mobile SDK, but in any case, the user
could easily detect a service that cheats, as all changes are
visible to her.
4) Auxiliary Functions: Parse(x) de-seralizes the mes-
sage sent to a transaction, which contains the arguments;
CheckPolicy(pkk
sig, xp), illustrated in Protocol 2, veriÔ¨Åes that
the originator has the appropriate permissions.
Protocol 2 Permissions check against the blockchain
1: procedure CHECKPOLICY(pkk
sig, xp)
2:
s ‚Üê0
3:
apolicy = H(pkk
sig)
4:
if L[apolicy] Ã∏= ‚àÖthen
5:
pku,s
sig, pks,u
sig, POLICYu,s ‚ÜêParse(L[apolicy])
6:
if pkk
sig = pku,s
sig or
7: (pkk
sig = pks,u
sig and xp ‚ààPOLICYu,s) then
8:
s ‚Üê1
9:
end if
10:
end if
11:
return s
12: end procedure
B. Blockchain Protocols
Here we provide a detailed description of the core protocols
executed on the blockchain. Protocol 3 is executed by nodes
in the network when a Taccess transaction is received, and
similarly, Protocol 4 is executed for Tdata transactions.
As mentioned earlier in the paper, Taccess transactions
allow users to change the set of permissions granted to a
service, by sending a POLICYu,s set. Sending the empty set
revokes all access-rights previously granted. Sending a Taccess
transaction with a new compound identity for the Ô¨Årst time is
interpreted as a user signing up to a service.
Similarly, Tdata transactions govern read/write operations.
With the help of CheckPolicy, only the user (always) or the
service (if allowed) can access the data. Note that in lines 9 and
16 of Protocol 4 we used shorthand notation for accessing the
DHT like a normal hashtable. In practice, these instructions
result in an off-blockchain network message (either read or
write) that is sent to the DHT.
C. Privacy and Security Analysis
We rely on the blockchain being tamper-free, an assump-
tion that requires a sufÔ¨Åciently large network of untrusted
peers. In addition, we assume that the user manages her keys
in a secure manner, for example using a secure-centralized
wallet service. We now show how our system protects against
adversaries compromising nodes in the system. Currently, we
182
Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA. Downloaded on July 16,2025 at 22:57:35 UTC from IEEE Xplore.  Restrictions apply. 
Protocol 3 Access Control Protocol
1: procedure HANDLEACCESSTX(pkk
sig, m)
2:
s ‚Üê0
3:
pku,s
sig, pks,u
sig, POLICYu,s = Parse(m)
4:
if pkk
sig = pku,s
sig then
5:
L[H(pkk
sig)] = m
6:
s ‚Üê1
7:
end if
8:
return s
9: end procedure
Protocol 4 Storing or Loading Data
1: procedure HANDLEDATATX(pkk
sig, m)
2:
c, xp, rw = Parse(m)
3:
if CheckPolicy(pkk
sig, xp) = True then
4:
pku,s
sig, pks,u
sig, POLICYu,s
‚Üê
Parse(L[H(pku,s
sig)])
5:
axp = H(pku,s
sig ‚à•xp)
6:
if rw = 0 then
‚ñ∑rw=0 for write, 1 for read
7:
hc = H(c)
8:
L[axp] ‚ÜêL[axp] ‚à™hc
9:
(DHT) ds[hc] ‚Üêc
10:
return hc
11:
else if c ‚ààL[axp] then
12:
(DHT) return ds[hc]
13:
end if
14:
end if
15:
return ‚àÖ
16: end procedure
are less concerned about malicious services that change the
protocol or record previously read data, as they are likely to be
reputable, but we provide a possible solution for such behavior
in section V-A.
Given this model, only the user has control over her data.
The decentralized nature of the blockchain combined with
digitally-signed transactions ensure that an adversary cannot
pose as the user, or corrupt the network, as that would imply
the adversary forged a digital-signature, or gained control over
the majority of the network‚Äôs resources. Similarly, an adversary
cannot learn anything from the public ledger, as only hashed
pointers are stored in it.
An adversary controlling one or more DHT nodes cannot
learn anything about the raw data, as it is encrypted with keys
that none of the nodes posses. Note that while data integrity is
not ensured in each node, since a single node can tamper with
its local copy or act in a byzantine way, we can still in practice
minimize the risk with sufÔ¨Åcient distribution and replication of
the data.
Finally, generating a new compound identity for each user-
service pair guarantees that only a small fraction of the data is
compromised in the event of an adversary obtaining both the
signing and encryption keys. If the adversary obtains only one
of the keys, then the data is still safe. Note that in practice
we could further split the identities to limit the exposure of a
single compromised compound identity. For example, we can
generate new keys for every hundred records stored.
V.
DISCUSSION OF FUTURE EXTENSIONS
In this section, we slightly digress to present possible
future extensions to blockchains. These could play a signiÔ¨Åcant
role in shaping more mature distributed trusted computing
platforms, compared to current state-of-the-art systems. More
speciÔ¨Åcally, they would greatly increase the usefulness of the
platform presented earlier.
A. From Storage to Processing
One of the major contributions of this paper is demonstrat-
ing how to overcome the public nature of the blockchain. So
far, our analysis focused on storing pointers to encrypted data.
While this approach is suitable for storage and random queries,
it is not very efÔ¨Åcient for processing data. More importantly,
once a service queries a piece of raw data, it could store it for
future analysis.
A better approach might be to never let a service observe
the raw data, but instead, to allow it to run computations
directly on the network and obtain the Ô¨Ånal results. If we split
data into shares (e.g., using Shamir‚Äôs Secret Sharing [23]),
rather than encrypting them, we could then use secure Multi-
party Computation (MPC) to securely evaluate any function
[3].
In Figure 2, we illustrate how MPC might work with
blockchains and speciÔ¨Åcally in our framework. Consider a
simple example in which a city holds an election and wishes
to allow online secret voting. It develops a mobile application
for voting which makes use of our system, now augmented
with the proposed MPC capabilities. After the online elections
take place, the city subsequently submits their back-end code
to aggregate the results. The network selects a subset of nodes
at random and an interpreter transforms the code into a secure
MPC protocol. Finally, the results are stored on the public
ledger, where they are safe against tampering. As a result, no
one learns what the individual votes were, but everyone can
see the results of the elections.
procedure EVOTE((‚àó)v1, ..., (‚àó)vn)
s ‚Üên
i=1 vi
if s < 0 then
L[aelection] ‚Üêu1
else if s > 0 then
L[aelection] ‚Üêu2
end if
end procedure
Select
MPC ‚äÇ
NET
MPC Computes:
[s]pi ‚Üên
i=1[vi]pi
broadcast: [s]pi ‚ÜíMPC
s ‚Üêreconstruct([s])
broadcast: s ‚ÜíNET
NET Computes:
if s < 0 then
L[aelection] ‚Üêu1
else if s > 0 then
L[aelection] ‚Üêu2
end if
Fig. 2. Example of a Ô¨Çow of secure computation in a blockchain network. The
top left block (EVote procedure) is the unsecure code, where the arguments
marked in (*) are private and stored as shares on the DHT. The network
selects a subset of nodes at random to compute a secure version of EVote and
broadcasts the results back to the entire network, that stores it on the ledger.
183
Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA. Downloaded on July 16,2025 at 22:57:35 UTC from IEEE Xplore.  Restrictions apply. 
B. Trust and Decision-Making in Blockchains
Bitcoin, or blockchains in general, assumes all nodes are
equally untrusted and that their proportion in the collective
decision-making process is solely based on their computational
resources (known as the Proof-of-work algorithm) [17]. In
other words ‚Äì for every node n, trustn ‚àùresources(n)
(probabilistically) decides the node‚Äôs weight in votes. This
leads to adverse effects, most notably vulnerability to sybil
attacks, excessive energy consumption and high-latency.
Intuitively, Proof-of-Work reasons that nodes which pour
signiÔ¨Åcant resources into the system are less likely to cheat.
Using similar reasoning we could deÔ¨Åne a new dynamic
measure of trust that is based on node behavior, such that good
actors that follow the protocol are rewarded. SpeciÔ¨Åcally, we
could set the trust of each node as the expected value of it
behaving well in the future. Equivalently, since we are dealing
with a binary random variable, the expected value is simply the
probability p. A simple way to approximate this probability is
by counting the number of good and bad actions a node takes,
then using the sigmoid function to squash it into a probability.
In practice, every block i we should re-evaluate the trust score
of every node as ‚Äì
trust(i)
n =
1
1 + e‚àíŒ±(#good‚àí#bad) ,
(3)
where Œ± is simply the step size.
With this measure, the network could give more weight to
trusted nodes and compute blocks more efÔ¨Åciently. Since it
takes time to earn trust in the system, it should be resistant to
sybil attacks. This mechanism could potentially attract other
types of attacks, such as nodes increasing their reputation just
to act maliciously at a later time. This might be mitigated by
randomly selecting several nodes, weighted by their trust, to
vote on each block, then taking the equally-weighted majority
vote. This should prevent single actors from having too much
inÔ¨Çuence, regardless of their trust-level.
VI.
CONCLUSION
Personal data, and sensitive data in general, should not be
trusted in the hands of third-parties, where they are suscep-
tible to attacks and misuse. Instead, users should own and
control their data without compromising security or limiting
companies‚Äô and authorities‚Äô ability to provide personalized
services. Our platform enables this by combining a blockchain,
re-purposed as an access-control moderator, with an off-
blockchain storage solution. Users are not required to trust
any third-party and are always aware of the data that is
being collected about them and how it is used. In addition,
the blockchain recognizes the users as the owners of their
personal data. Companies, in turn, can focus on utilizing data
without being overly concerned about properly securing and
compartmentalizing them.
Furthermore, with a decentralized platform, making legal
and regulatory decisions about collecting, storing and sharing
sensitive data should be simpler. Moreover, laws and regula-
tions could be programmed into the blockchain itself, so that
they are enforced automatically. In other situations, the ledger
can act as legal evidence for accessing (or storing) data, since
it is (computationally) tamper-proof.
Finally, we discussed several possible future extensions
for blockchains that could harness them into a well-rounded
solution for trusted computing problems in society.
"
pdf//Effective_Scheme_against_51_Attack_on_Proof-of-Work_Blockchain_with_History_Weighted_Information.pdf;In the present paper, we introduce a new solution by utilizing a historical weighted difÔ¨Åculty to determine the total chain difÔ¨Åculty.;We demonstrate that, in reality, such an algorithm can increase the money cost and the time cost of 51% attacks by a factor of at least two orders of magnitude.;In the present paper, we introduce a new solution by utilizing a historical weighted difÔ¨Åculty to determine the total chain difÔ¨Åculty.;When the second PoW is sufÔ¨Åciently difÔ¨Åcult, pool operators have to give out this private key to the pool miners in order to perform a calculation faster than all the peer nodes.;[('miner', 62), ('block', 62), ('branch', 48), ('attack', 44), ('blockchain', 28), ('weight', 28), ('attacker', 26), ('cost', 26), ('hashrate', 24), ('hwd', 21)];2014.0;;"Effective scheme against 51% Attack on
Proof-of-Work Blockchain with History Weighted
Information
Xinle Yang, Yang Chen and Xiaohu Chen
MOAC Blockchain Tech Inc.
Palo Alto, CA, USA
{xinle.yang, yang.chen, david.chen}@moac.io
Abstract‚ÄîProof-of-Work (PoW) is a popular protocol used
in Blockchain systems to resolve double-spending problems.
However, if an attacker has access to calculation hash power
greater than half of the total hash power, this attacker can create
a double-spending attack or 51% attack. The cost of creating
a 51% attack is surprisingly low if hash power is abundantly
available. That posts a great threat to lots of PoW blockchains.
We propose a technique to combine history weighted information
of miners with the total calculation difÔ¨Åculty to alleviate the 51%
attack problem. Analysis indicates that with the new technique,
the cost of a traditional attack is increased by two orders of
magnitude.
Index Terms‚ÄîBlockchain, 51% Attack, Mining, Double spend-
ing attack
I. INTRODUCTION
Developed by Satoshi Nakamoto in 2009 [1], Bitcoin is
the Ô¨Årst decentralized public ledger system. Since then, a
number of similar blockchain-based cryptocurrencies have
emerged. Blockchain is a distributed data processing protocol
for retaining a public distributed ledger in a Peer-to-peer (P2P)
network. Transaction data is recorded in blocks, and these
blocks form a linked list (i.e., chain) of blocks. Each node
in the network stores and maintains an entire copy of the
ledger without requiring a central authority. In blockchain-
based cryptocurrencies, each block contains the hash value
of the previous block, making it hard to manipulate the
transactions within. Normally, a consensus protocol is used to
guarantee the data integrity among the nodes of the blockchain
P2P network. There are several different consensus protocols
used in different types of blockchains [2].
Proof-of-Work (PoW) is the most commonly used con-
sensus protocol in blockchain-based cryptocurrencies. Major
blockchains such as Bitcoin and Ethereum are both using
different variety of PoW protocol. In PoW protocol, each node
is competing to Ô¨Ånd a nonce value to produce a hash that
meets a certain criteria. The difÔ¨Åculty of calculating such a
nonce value can be calculated based on the criteria of the hash
value. When such a nonce value is found, a block is generated
and broadcasted to the P2P network. Depending on different
varieties of protocol, peer nodes always accept the longest
chain or the chain with the largest total difÔ¨Åculty repeatedly
to continuously expand the blockchain. PoW utilizes this
mechanism to determine which node has the right to seal a
block. This process is also called mining.
In such a mechanism, a peer node with greater computing
speed (or sometimes called hashrate power) can calculate
nonce value faster than a peer node with less computing speed
and thus has a higher probability of getting the right to seal a
new block. However, this mechanism has a drawback. A selÔ¨Åsh
node with hashrate power higher than the total hashrate power
of the rest nodes combined can compromise the blockchain
system by causing double spending and selÔ¨Åsh mining, etc
[3] [4]. This is commonly referred to as a 51% attack. Some
studies have proposed ways to avoid such kind of attacks. Eyal
and Sirer [5] in 2014 proposed a Two-Phase PoW(2P-PoW)
solution preventing the formation of a mining pool with huge
hash power. In this solution, the second phase PoW requires
signature from the private key of the coinbase address. When
the second PoW is sufÔ¨Åciently difÔ¨Åcult, pool operators have to
give out this private key to the pool miners in order to perform
a calculation faster than all the peer nodes. RufÔ¨Ång et al. [6]
in 2015 proposed contracts to penalize attackers attempting
a double-spending attack. Solat and Potop-Butucaru proposed
ZeroBlock [7] in 2016. The mechanism in ZeroBlock requires
a block to be accepted by its peers within certain time interval
after the timestamp of the block. Otherwise, the block is
expired. This mechanism prevents attacker nodes from selÔ¨Åsh
mining for a long period of time. J. Bae and H. Lim [8] in
2018 proposed a solution to randomly select a certain group
of miners to have the right to mine the next block.
In the present paper, we introduce a new solution by
utilizing a historical weighted difÔ¨Åculty to determine the total
chain difÔ¨Åculty. In such a modiÔ¨Åed algorithm, a branch of
blockchain has a greater total historical weighted difÔ¨Åculty
if the miners of such a branch have a higher coverage rate
in previous blocks. We demonstrate that, in reality, such an
algorithm can increase the money cost and the time cost of
51% attacks by a factor of at least two orders of magnitude.
II. 51% ATTACK AND COST
First, let us review the 51% attack scheme. Assume the
current hashrate is po, the attacker accumulates a greater
hashrate power pa with pa > po, and utilizes this hashrate
power to compute a hidden branch ba. The attacker performs
261
2019 IEEE International Conference on Blockchain (Blockchain)
978-1-7281-4693-5/19/$31.00 ¬©2019 IEEE
DOI 10.1109/Blockchain.2019.00041
Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA. Downloaded on July 14,2025 at 17:00:14 UTC from IEEE Xplore.  Restrictions apply. 
double spending in two branches. The attacker then reveals
hidden longer branch ba and invalidates all transactions in
original branch bo. The estimated cost to launch such a 51%
attack is,
Cost = (P ‚àóR) ‚àóf ‚àót
(1)
where P is the price of token at trade exchange, R is the
block reward, f is the frequency of block generation speed,
and t stands for the duration of the attack. Also, to simplify
the cost estimation, here we assume that the price of mined
token is close to the cost of mining such token. For many
small blockchains, the cost to perform such an attack is only
hundreds or thousands of US Dollars [9].
Another factor that makes the Scenario worse is that
hashrate could be easily accessible to anyone who can pay
the right price. NiceHash [10] provides an open market for
hashrate exchange. Anyone can easily pay with cryptocurrency
to rent available hashrate to mine for the target blockchain. So
an attacker can accumulate signiÔ¨Åcant hashrate in short period
of time to exceed the 51% threshold. The attacker can double
spend the token through a centralized exchange. The whole
process only takes around 50-500 blocks. After that, attacker
can release the rented hashrate and walk away with the proÔ¨Åt.
Most recently, Ethereum Classic [11] was attacked. Large
amount of ETCs were double-spent in attack branch length
ranged from 50 to 150.
III. HISTORICAL WEIGHTED DIFFICULTY
We propose an improved technique to calculate the total
difÔ¨Åculty of a branch. This technique takes into account the
distribution of miner addresses in the last certain amount of
blocks of the blockchain. We call this protocol Historical
Weighted DifÔ¨Åculty based Proof-of-Work (HWD-PoW) pro-
tocol. The assumption is that in an honest blockchain branch,
miners of new blocks will most likely be the miners who
mined the previous blocks, and the distribution will reÔ¨Çect
the ratio in history. Furthermore, in a malicious blockchain
branch, distribution of miners of new blocks will most likely
be controlled by the attackers, which will be different from
the regular distribution of miners in the history. Therefore,
when the distribution of the miners in history is considered,
one can easily distinguish an honest blockchain branch from
a malicious one.
Under the proposed mechanism, branch with miners of less
representation in the previous blocks will earn less weight in
the total difÔ¨Åculty calculation. Therefore, to perform a 51%
attack, the malicious miners have two choices: either to mine
a much longer branch, or to build up miner representation in
the previous blocks to build up the credibility.
Now, let us look at how Historical Weight DifÔ¨Åculty scheme
works to defend the 51% attack.
(a) First, record each miner‚Äôs block generation frequency
for history window W:
ri =
(blocks mined by miner i)
(total block number generated in window W) (2)
where
n

i=0
ri = 1
(3)
(b) Each block is then signed by miner‚Äôs private key. In this
way, miners will not be able to counterfeit the miner identity.
Although, this might expose the private keys of the miners.
But, such problem can be mitigated by transfering the tokens
out of miners‚Äô accounts to cold wallets as soon as the tokens
are mined.
(c) When a split is detected, Historical Weighted DifÔ¨Åculty
(HWD) is calculated for each branch at each peer node in the
following way: for any unique miner k in the branch b,
HWDb = HWb ‚àóDb =
l

k=1
rk ‚àó
l

k=1
dk
(4)
where rk is the block generation frequency in the history
window, dk is the difÔ¨Åculty of block k, and l is the branch
length.
Please note that only unique miner‚Äôs generation frequency
is counted. If one miner address mined multiple blocks, it is
only counted once. This is to discourage single high hashrate
miners, thus encouraging the decentralization of mining. It also
increase the difÔ¨Åculty of attack.
(d) Each peer node compares two different HWD‚Äôs from
two branches. The branch with greater HWD will be selected.
The immediate result is clear: if the attacker just brings
in temporary new hashrate power, but the miner of the new
branch is relatively new to the system, the ri of the blocks
is very low, and the corresponding HWD will be very small
compared to the original branch. No peer node in the original
branch will switch to the attacker branch. This scheme can
easily defend rent-and-attack case.
If the attacker wants to make nodes to switch his fraudulent
branch, he will need to produce higher HWD value. The
attacker needs to mine in the original branch for a while to
make itself included in the history. Therefore, when it switches
to hidden branch, its HWD will be greater.
Suppose pa is the attacker miners‚Äô hashrate, po is the
original honest miners‚Äô hashrate.
Fig. 1. Attacker tries to attack branch bo with branch ba.
The attacker needs to spend hashrate pa in the original
branch for a time duration t. The optimum spending of pa is
262
Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA. Downloaded on July 14,2025 at 17:00:14 UTC from IEEE Xplore.  Restrictions apply. 
to mine for w/2 period and then switch pa to hidden branch at
attack point show in Fig. 1. In order for attack to be successful,
we have
pa > po
(5)
As a result, the revealed malicious branch ba will be longer
than original branch bo. At the reveal time, HWD of the
original branch is,
HWDo = Do ‚àó
l

k=0
ro
k = Do ‚àó(1
2 ‚àíŒ¥)
(6)
where Œ¥ is the minimal marginal difference accepted by peer
node.
So, HWD of the malicious branch is
HWDa = (1
2 + Œ¥) ‚àów ‚àíl
w
‚àóDa
(7)
Therefore, we have,
(1
2 + Œ¥) ‚àów ‚àíl
w
‚àóDa > (1
2 ‚àíŒ¥) ‚àóDo
(8)
Because Da and Do are close to each other in such a condition,
we can simplify the equation to
(1
2 + Œ¥) ‚àów ‚àíl
w
> (1
2 ‚àíŒ¥)
(9)
and we derive to
Œ¥ >
l
4w ‚àí2l
(10)
To summarize, the minimal cost of the attacker is to prepare
mining for (w ‚àíl) duration with hashrate po ‚àó(1/2+l/(4w ‚àí
2l)).
For a typical attack, l needs to be around 50-500 blocks to
allow token withdrawal from a token exchange. From below
section, the change of miners is not very frequent. We can
easily set w > 1 month to increase the history weight. With
w = 100, 000 blocks, the robustness against attack is increased
by over 100 times.
Although we cannot totally avoid 51% attacks, we can
dramatically increase the money cost and time it takes to
prepare a potential attack by at least two orders of magnitude.
Also, because attacker needs to spend quite a long time to
prepare, the attack is much less likely to happen as the long
period of time causes a lot of opportunity cost and uncertainty.
IV. ADDITIONAL IMPROVEMENT SCHEMES
Orthogonal to the above-mentioned HWD scheme, addi-
tional improvement schemes can be applied to further increase
the cost of attack.
The Ô¨Årst approach is to post a cap of ri < rc, which means
single miners can never be counted more than rc even it gen-
erates more blocks within the history window. This approach
will encourage a more diversiÔ¨Åed mining pool. At the same
time, the miners could purposely split the mining hashrate into
multiple miners to make sure each one is below rc. This will
circumvent the diversiÔ¨Åcation requirement. However, this is
still useful, as it increase the cost for attackers to maintain
multiple miner accounts.
The second approach is to add a miner overlap requirement
between two split branches. To minimize the cost of attack, an
attacker will normally put all of its hashrate power to mine in
the malicious branch. The overlap requirement requires that
some miners to mine both of the branches. Under such a
condition, in order for a branch switch to happen, one needs
to satisfy not only the HWD condition,
HWDa > HWDo
(11)
but also, the overlap between two sets of miners need to be
greater than s,
{ri}

{rk} > s
(12)
where ri are the miners‚Äô frequency of original branch, rk are
the miners‚Äô frequency of attacker branch, and s is the overlap
threshold.
Meaning, the system discourages sudden hashrate power
switches from one set of miners to another distinct set of
miners.
With such an enhanced requirement, if s = 0.25, an
attacker needs to have three times of the current hashrate
within time duration w. This means an attacker needs to keep
some hashrate in the original branch, and twice more in the
malicious branch to compensate for the effect. Therefore, by
introducing such a requirement, we double the time cost and
triple the money cost to perform an attack to the original
Historical Weighted DifÔ¨Åculty algorithm. For higher s, attacker
needs to spend even more hashrate than the minimal case.
V. HWD ALGORITHM
In this section, we will present the algorithm to perform
HWD based branch selection.
Below is the pseudo code to calculate the HWD,
VI. REAL DATA STATISTICS FROM ETHEREUM
We
picked
a
well-known
PoW
blockchain
platform
Ethereum. We analyzed block information of Ô¨Årst 6,000,000
blocks, which is about 3 years mining history. The Ô¨Årst task is
to Ô¨Ånd out the distribution of miners with signiÔ¨Åcant hashrate.
The analysis shows that the miner distribution has a strong
correlation with past history. At block #2,000,000, #4,000,000,
#6,000,000, the following 360 blocks were analyzed. Each
miner‚Äôs weight in the 360-block and weight in the 2M-block
is shown in tables blew:
The total weight of 360-block miners has a strong correla-
tion with the distribution in the history window, even if the
history we used is 2 million (M) blocks long (about one year).
The result is shown in Fig. 2. This supports our assumption
that the participation rate of honest miners is relatively stable.
Therefore, miners‚Äô historical weight is a valuable information
we can utilize to Ô¨Åght against 51% attack. We also observed
that correlation of new miners with previous 2M blocks is
strengthened, as it indicates that Ethereum mining is going
towards centralization.
263
Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA. Downloaded on July 14,2025 at 17:00:14 UTC from IEEE Xplore.  Restrictions apply. 
Algorithm 1 Calculation of HWD
1: function HWDCALCULATION(W, B) ‚ñ∑Where W - array
of historic blocks window, B - array of branch blocks
2:
HW = 0
3:
d = 0
4:
w = Length(W)
5:
l = Length(B)
6:
Let R[1 . . . l] be new arrays
7:
for i = 1 to l do
‚ñ∑Calculate miner appearance
frequency in historic blocks window
8:
R[i] = 0
9:
for j = 1 to w do
10:
if Miner(W[j]) == Miner(B[i]) then
11:
R[i]+ = 1
12:
R[i]/ = w
13:
for k = 1 to Length(B) do
‚ñ∑Sum Historic Weight
14:
HW = HW + R[k]
15:
for k = 1 to Length(B) do ‚ñ∑Sum branch difÔ¨Åculty
16:
d = d + Diff(B[k])
17:
HWD = HW ‚àód
TABLE I
ETHEREUM BLOCK MINERS FROM 2,000,001 TO 2,000,360
Miner
Weight
Amount
Weight in 2M
0x2a65......8226
0.272222
98
0.239315
0x61c8......0bd9
0.177778
64
0.049251
0xbcdf......41d1
0.163889
59
0.023924
0xea67......8ec8
0.116667
42
0.036458
0x4bb9......1b01
0.063889
23
0.057752
0xa42a......e84e
0.055556
20
0.001293
0x52bc......e3b5
0.038889
14
0.147223
0x1a06......58f1
0.030556
11
0.004212
0x6879......01da
0.025000
9
0.023600
0xd138......a31c
0.005556
2
0.000053
0xf3b9......c2fb
0.005556
2
0.008294
0xa027......e88f
0.005556
2
0.012287
0x1654......d5de
0.002778
1
0.001272
0x186a......b0f2
0.002778
1
0.000001
0x2cb7......6402
0.002778
1
0.000004
0x30b6......4e6d
0.002778
1
0.002430
0x40ce......f821
0.002778
1
0.000954
0x5979......e584
0.002778
1
0.000116
0x6caf......a46d
0.002778
1
0.001050
0x7a14......0b95
0.002778
1
0.001233
0x9148......a49d
0.002778
1
0.000021
0x94ce......a2f7
0.002778
1
0.000944
0x9558......7211
0.002778
1
0.011990
0xadd8......db02
0.002778
1
0.000039
0xd3d0......ee9d
0.002778
1
0.001598
0xdc3f......e455
0.002778
1
0.000340
aTotal miners‚Äô weight from previous 2 million blocks is 62.57%.
TABLE II
ETHEREUM BLOCK MINERS FROM 4,000,001 TO 4,000,360
Miner
Weight
Amount
Weight in 2MÀú4M
0x829b......a830
0.283333
102
0.012240
0xea67......8ec8
0.236111
85
0.169016
0x1e99......0341
0.138889
50
0.079728
0xb293......0347
0.086111
31
0.032167
0x52bc......e3b5
0.075000
27
0.045849
0x2a65......8226
0.072222
26
0.167880
0xc0ea......2949
0.033333
12
0.072130
0x4bb9......1b01
0.016667
6
0.058859
0xf3b9......c2fb
0.013889
5
0.015585
0x9435......7805
0.008333
3
0.003338
0x9633......a11c
0.008333
3
0.005184
0x73b8......7fea
0.005556
2
0.007535
0x8727......87a5
0.005556
2
0.000331
0xa42a......e84e
0.005556
2
0.033483
0xa4aa......7f0d
0.005556
2
0.003277
0xa9a9......51fc
0.002778
1
0.000911
0xa027......e88f
0.002778
1
0.001355
aTotal miners‚Äô weight from previous 2 million blocks is 70.89%.
TABLE III
ETHEREUM BLOCK MINERS FROM 6,000,001 TO 6,000,360
Miner
Weight
Amount
Weight in 4MÀú6M
0xea67......8ec8
0.322222
116
0.259396
0x5a0b......9c4c
0.133333
48
0.108651
0x829b......a830
0.127778
46
0.210382
0x52bc......e3b5
0.116667
42
0.125527
0xb293......0347
0.105556
38
0.098562
0xf3b9......c2fb
0.036111
13
0.023992
0x2a65......8226
0.027778
10
0.035354
0x1ca4......be1a
0.019444
7
0.000904
0x52e4......f13c
0.013889
5
0.007205
0xd958......4012
0.013889
5
0.000263
0xb75d......22f5
0.011111
4
0.005698
0xd438......1807
0.011111
4
0.000594
0x6a7a......9b1f
0.008333
3
0.008874
0x70ae......e21d
0.008333
3
0.002358
0x35f6......738d
0.005556
2
0.000325
0x4a07......a82b
0.005556
2
0.002980
0xe4bd......0649
0.005556
2
0.003712
0x0019......99e8
0.002778
1
0.000784
0x4bb9......1b01
0.002778
1
0.015724
0x914d......1dcd
0.002778
1
0.000168
0x92e3......b549
0.002778
1
0.000822
0x9435......7805
0.002778
1
0.007071
0xb8f8......5453
0.002778
1
0.000668
0xcc16......e610
0.002778
1
0.002227
0xd100......4fce
0.002778
1
0.000470
0xd380......636d
0.002778
1
0.000002
0xd9cf......06e3
0.002778
1
0.000108
aTotal miners‚Äô weight from previous 2 million blocks is 92.28%.
Please also note that one miner with address 0x829b......a830
changed its weight substantially between 2MÀú4M blocks and
the 360 blocks after in Table II. And, yet, the total miners‚Äô
weight from previous 2 million blocks is still at over 70%.
This indicates that some individual miners may change their
mining participation drastically, but it does not change the total
historical weight a lot in a geniune branch.
We further created a simulation to perform 51% attacks at
the point of block #2M, #4M and #6M, and computed the
result for window length of 1M and 2M. If the HWD of
264
Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA. Downloaded on July 14,2025 at 17:00:14 UTC from IEEE Xplore.  Restrictions apply. 
2
3
4
5
6
0
20
40
60
80
100
Ethereum mainnet block number n (million)
total historical weight of unique miners n+360
k=n+1 rk (%)
Fig. 2. Total historical weight HW of unique miners of the 360 new blocks
from previous 2 million blocks.
attacking branch is higher than those of the original branch,
we marked it as a successful attack.
In the ideal case, the preparation should be at least longer
than the speciÔ¨Åed window. However, given the correlation of
distribution, the preparation period was slightly shorter. We
ran the simulation multiple times for each window to get the
average accumulated cost. Here we ignored the mining reward
halving effect over the time. Result is below Fig. 3.
The result indicates that with HWD scheme, the cost of
attacking the Ethereum Mainnet blockchain is increased by
more than 100 times if we set the window size to 1M or 2M
blocks. In real application, the window could be shorter to
speed up the process. We suggest window size is at least 1
Million, making the cost of attack 100x more expensive.
VII. CONCLUSION
In this paper, we proposed an approach to increase the cost
of a successful 51% double-spending attack on Proof-of-Work
types of Blockchain protocols. The proposed approach utilizes
the frequency rate of miners in history blocks and calculates
the total Historical Weighted DifÔ¨Åculty to determine if branch
switch is needed. We demonstrated in three real Ethereum
Mainnet scenarios that the cost of attack is increased by more
than 100 times with HWD-PoW scheme.
Our HWD-PoW scheme could be applied to all other PoW
based blockchains. This can improve smaller blockchain‚Äôs
security drastically with easy integration.
ACKNOWLEDGMENT
This work was supported by the MOAC Foundation and
MOAC Blockchain Tech Inc. We thank Andrew Champagne
for helping us on proof reading.
2
3
4
5
6
103
104
105
Ethereum mainnet block number n (million)
cost to perform a 51% attack (Blocks)
window#1 1M
window#2 2M
PoW
Fig. 3.
Comparing the cost of perform a 51% attack, HWD-PoW(1M
windows, 2M windows) vs. PoW
cost = 2 ‚àó
‚àö
window ‚àóbranch size ‚àócorrelation rate
"
pdf//ETH_Relay_A_Cost-efficient_Relay_for_Ethereum-based_Blockchains.pdf;Thus, operating a relay that requires each block header to be fully validated on submission between Ethereum-based blockchains leads to exorbitant operating cost.;In Sections VI and VII, we evaluate the proposed relay scheme with regards to security and operating cost, respectively.;In future work, in an effort to reduce submission cost even further, we will investigate the feasibility of batch submis- sions of Ethereum block headers using zero-knowledge proofs similar to the approach taken by zkRelay for Bitcoin block headers.;Because of its ability to store data and execute code in a decentralized and immutable way, blockchain technology is seen as potentially disruptive in areas such as Ô¨Ånance [1], business process management;[('header', 247), ('relay', 197), ('block', 195), ('blockchain', 146), ('block header', 118), ('chain', 102), ('contract', 87), ('branch', 87), ('client', 62), ('main', 61)];2020.0;In future work, in an effort to reduce submission cost even further, we will investigate the feasibility of batch submis- sions of Ethereum block headers using zero-knowledge proofs similar to the approach taken by zkRelay for Bitcoin block headers.;"ETH Relay: A Cost-efÔ¨Åcient Relay
for Ethereum-based Blockchains
Philipp Frauenthaler‚àó, Marten Sigwart‚àó, Christof Spanring‚Ä†, Michael Sober‚àó, Stefan Schulte‚àó
‚àóChristian Doppler Laboratory for Blockchain Technologies for the Internet of Things
Distributed Systems Group, TU Wien, Vienna, Austria
{p.frauenthaler, m.sigwart, m.sober, s.schulte}@dsg.tuwien.ac.at
‚Ä† Pantos GmbH, Vienna, Austria
contact@pantos.io
Abstract‚ÄîCurrent blockchain relay schemes require the imme-
diate validation of each relayed block header by the destination
blockchain. This leads to high operating cost when deploying these
relays between Ethereum-based blockchains where validating
block headers on-chain is computationally expensive.
To overcome these limitations, we introduce a novel relay
scheme that employs a validation-on-demand pattern combined
with economic incentives to reduce the cost of operating a relay
between Ethereum-based blockchains by up to 92%. With this
relay scheme, decentralized interoperability between blockchains
like Ethereum and Ethereum Classic becomes feasible.
Index
Terms‚Äîblockchain
interoperability,
cross-blockchain
communication, blockchain relay, simpliÔ¨Åed payment veriÔ¨Åcation
I. INTRODUCTION
Because of its ability to store data and execute code in a
decentralized and immutable way, blockchain technology is
seen as potentially disruptive in areas such as Ô¨Ånance [1],
business process management [2], data provenance [3, 4],
supply chain management [5], or healthcare [6]. The growing
popularity among industry and research communities has led
to a plethora of new projects creating their own blockchains,
either by developing an entirely new one or by forking an
existing code base. However, interoperability between these
blockchains is often not foreseen. As a result, a heteroge-
neous landscape of independent and unconnected platforms has
emerged [7]. Today, even blockchains that share the same code
base operate isolated from each other. Prominent examples
of such blockchains are Ethereum-based blockchains, e.g.,
Ethereum and Ethereum Classic.
One promising way to break this isolation are blockchain
relays [8]. Relays operate by having off-chain clients forward
block headers of some source blockchain to a destination
blockchain virtually replicating one blockchain within the
other. This way, it becomes possible for the destination block-
chain to independently verify that certain pieces of data (e.g.,
transactions) exist on the source blockchain [8].
To ensure that only valid block headers are replicated within
the destination blockchain, current relay solutions [9, 10]
require the destination blockchain to validate each relayed
block header according to the protocol rules of the source
blockchain (e.g., the consensus algorithm). With each block
header being validated on-chain, the need for explicit trust in
off-chain clients is eliminated.
However, Ethereum-based blockchains such as Ethereum
and Ethereum Classic use a consensus algorithm called Ethash
that is computationally expensive to validate on-chain. Even
with gas-optimized implementations [11], the validation of
Ethash for a single block header still costs around 3 million
gas. Thus, operating a relay that requires each block header
to be fully validated on submission between Ethereum-based
blockchains leads to exorbitant operating cost.
To overcome this issue, we introduce ETH Relay‚Äîa novel
relay scheme that uses a validation-on-demand pattern to-
gether with a sophisticated incentive structure to achieve a
cost reduction of up to 92% over traditional relay solutions
when deployed for Ethereum-based blockchains. We show that
ETH Relay is fully decentralized and secure as long as at least
one off-chain client acts honestly.
To this end, the paper is organized as follows. We Ô¨Årst
provide background information on blockchain relays (Sec-
tion II), and take a look at existing relay solutions (Section III).
In Sections IV and V, we then describe the concepts and
implementation of ETH Relay. In Sections VI and VII, we
evaluate the proposed relay scheme with regards to security and
operating cost, respectively. Finally, Section VIII concludes the
paper.
II. BACKGROUND
In blockchain relays, off-chain clients relay the block head-
ers of a source blockchain to some destination blockchain [8].
Having access to the source blockchain‚Äôs block headers, the
destination blockchain can use a technique called SimpliÔ¨Åed
Payment VeriÔ¨Åcation (SPV) to verify the existence of certain
pieces of the source blockchain‚Äôs state (e.g., the existence of
certain transactions). In this section, we Ô¨Årst explain the con-
cept of SPV and then describe how SPVs facilitate blockchain
relays.
A. SimpliÔ¨Åed Payment VeriÔ¨Åcation
SPV is a technique that can be used to cryptographically
verify that a particular transaction is part of a blockchain while
only having knowledge of a blockchain‚Äôs block headers and not
204
2020 IEEE International Conference on Blockchain (Blockchain)
978-0-7381-0495-9/20/$31.00 ¬©2020 IEEE
DOI 10.1109/Blockchain50366.2020.00032
Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA. Downloaded on July 14,2025 at 17:00:25 UTC from IEEE Xplore.  Restrictions apply. 
Block Header
Merkle Root
Hash
Block Header
Block Header
H( ) H( )
Tx1
H( ) H( )
H( ) H( )
Tx2
Tx3
Tx4
Merkle
Proof
Fig. 1. A block consists of a header and a Merkle tree containing the block‚Äôs
transactions. Merkle trees enable concise proofs of membership, as illustrated
for Tx2.
the individual blockchain transactions [1]. SPV is commonly
used in light nodes such as wallet software [12].
In blockchains such as Bitcoin and Ethereum, transactions
in a block are organized in a so-called Merkle tree [13], a data
structure in which each node uses hash pointers to reference
its child nodes. As seen in Fig. 1, the leaves of the Merkle
tree consist of the individual transactions with the hash of the
Merkle tree‚Äôs root (Merkle root hash) stored as part of the
block header. Therefore, a light node has access to the Merkle
root hash. With this, light nodes can verify the inclusion of
a particular transaction in the blockchain by leveraging a so-
called Merkle proof of membership. Such a proof consists of
all tree nodes that make up the path from the transaction (leaf)
up to the root node (see Fig. 1), and can be retrieved from full
nodes. When retrieving such a proof, the light node recalculates
the hashes of all nodes along the path from the leaf (i.e., the
transaction) up to the root node. If the Ô¨Ånal hash matches the
Merkle root hash of the block header stored by the light node,
the membership of the transaction within the corresponding
block is successfully veriÔ¨Åed. Light nodes thus are able to
verify the existence of transactions (e.g., payments) while only
consuming a fraction of the space as they do not need to store
the transaction history.
B. Relay Schemes
Light nodes use SPVs to verify whether or not a particu-
lar transaction exists on some blockchain. Blockchain relays
leverage this capability by having a smart contract on some
destination blockchain act as a light node for some source
blockchain [8]. A prominent example for this is BTC Relay [9].
BTC Relay is essentially a Bitcoin light node running on the
Ethereum blockchain in the form of a smart contract, the so-
called relay contract. The relay contract is able to verify the
inclusion of Bitcoin transactions on the Ethereum blockchain
by means of SPVs.
For successful SPVs, the relay contract needs to know about
the block headers of the source blockchain. However, contrary
to off-chain light nodes, the relay contract cannot proactively
query headers from full nodes. Instead, headers of the source
blockchain need to be constantly submitted to the contract
by off-chain clients. As any off-chain client can submit block
headers, potentially illegal block headers may arrive at the relay
contract. Hence, blockchain relays need to make sure that only
valid block headers are used for SPVs [8].
Furthermore, in Proof of Work (PoW) blockchains like
Ethereum, multiple valid blocks with the same block height
can exist in parallel, forming multiple blockchain ‚Äúbranches‚Äù.
While there can be several branches at the same time, only
one of these branches represents the current main chain of
the blockchain, e.g., in PoW blockchains, the main chain
is identiÔ¨Åed by searching for the branch with the highest
total difÔ¨Åculty [8]. As more block headers are appended to
branches, the main chain of a blockchain may change over
time. This represents a challenge to relays since SPVs should
only be successful if the requested block header is part of
the main chain. When an SPV is requested on a certain
block, the relay contract thus needs to determine whether the
block is part of the main chain of the source blockchain.
The likelihood of a block remaining part of the main chain
increases with each succeeding block that is appended to it.
These block conÔ¨Årmations should be taken into account by
the relay contract as well when performing SPVs.
III. RELATED WORK
As blockchain relays are seen as one way to achieve
blockchain interoperability [8, 14], a couple of relays have
been implemented and conceptualized [9, 10, 15, 16, 17]. In
the following section, we explain how these relays verify the
validity of submitted headers and discuss current limitations.
BTC Relay [9] was the Ô¨Årst and‚Äîto the best of our
knowledge‚Äîso far only relay solution to be operational. It
allows relaying block headers from the Bitcoin blockchain to
the Ethereum blockchain. Similarly, Waterloo [15, 16] attempts
to provide a relay between the Ethereum and EOS blockchains.
Waterloo is bi-directional, i.e., it consists of two separate
relays, from Ethereum to EOS and from EOS to Ethereum.
To ensure that only valid block headers are used for SPVs,
both relays‚ÄîBTC Relay and Waterloo‚Äîfully validate newly
submitted block headers according to the header validation
procedure of the source blockchain, i.e., the blockchain from
which the headers originate (e.g., Bitcoin in case of BTC
Relay). Among other things, this usually involves validating
the consensus algorithm, e.g., for PoW blockchains it needs to
be veriÔ¨Åed that enough work was performed for constructing
a block [8].
For both relays, fully validating every submitted block
header is economically viable due to the speciÔ¨Åcs of the
involved blockchains. In case of BTC Relay, validating each
Bitcoin block header on Ethereum is feasible as Bitcoin
headers only have a size of 80 bytes and validating the Bitcoin
hashing algorithm SHA-256 on Ethereum is computationally
inexpensive.
205
Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA. Downloaded on July 14,2025 at 17:00:25 UTC from IEEE Xplore.  Restrictions apply. 
Relay Contract
Source Blockchain
Destination Blockchain
Off-chain Clients
Dispute
Observe
Submit
Fig. 2. The ETH Relay Scheme
In Waterloo, relaying headers from Ethereum to EOS is
economically viable because EOS uses delegated Proof of
Stake as consensus mechanism. By design, this allows cheaper
on-chain computations and thus makes the on-chain validation
of Ethash, the consensus algorithm of Ethereum, feasible. For
the other direction (EOS to Ethereum), delegated Proof of
Stake relies on a changing set of block producers, which
on average happens every 8 hours [15]. Consequently, when
relaying block headers from EOS to Ethereum, it sufÔ¨Åces to
validate only those headers where the block producers change.
BTC Relay and Waterloo both work in their speciÔ¨Åc settings.
However, when deploying one of these schemes between
Ethereum-based blockchains such as Ethereum and Ethereum
Classic, validating each block header would lead to high
operating cost: validating Ethash, the PoW algorithm used
by Ethereum-based blockchains, on another Ethereum-based
blockchain costs about 3 million gas even with gas-optimized
solutions (see Section VII). Hence, the underlying strategy
employed by BTC Relay and Waterloo is not viable for relays
between Ethereum-based blockchains.
A relay for Ethereum-based blockchains that mitigates high
validation cost is PeaceRelay [10]. In its current implementa-
tion, PeaceRelay relies on trusted, authorized clients to submit
valid block headers. While this makes PeaceRelay relatively
cheap to operate, it also leads to a high degree of centralization.
PeaceRelay is therefore rather a notary scheme than a relay.
Another approach for reducing operating cost is to leverage
zero-knowledge proofs as done in zkRelay [17]. In zkRelay,
clients validate a batch of Bitcoin headers off-chain and
submit a proof certifying the successful validation to the relay
contract on the Ethereum blockchain. While the block header
validation of Bitcoin can be implemented as zero-knowledge
proof enabling such succinct batch submissions, it is uncertain
whether this approach can be leveraged for block headers of
Ethereum-based blockchains.
To conclude, a number of blockchain relays have been
conceptualized so far. However, their applicability largely
depends on the underlying blockchains. Deploying these relays
between Ethereum-based blockchains either leads to high op-
erating cost, requires explicit trust in third parties, or may be
technologically infeasible. The following sections show how
operating cost of relays can be kept to a minimum without
placing explicit trust in third parties.
Algorithm 1 Procedure performed by the relay contract when
receiving a new header of the source blockchain
1: function SUBMITBLOCKHEADER(header, submitter)
2:
if headers.contains(HASH(header)) == true then
3:
return false
4:
parentHash = header.parentHash
5:
if headers.contains(parentHash) == false then
6:
return false
7:
headers.put(HASH(header), header)
8:
header.m.lockedUntil = now + LOCK PERIOD
9:
parent = headers.get(parentHash)
10:
parent.m.chldn.append(HASH(header))
11:
branchHeads.add(HASH(header))
12:
if branchHeads.contains(parentHash) then
13:
branchHeads.remove(parentHash)
14:
header.m.branchId = parent.m.branchId
15:
header.m.junction = parent.m.junction
16:
else
17:
lastBranchId = lastBranchId + 1
18:
header.m.branchId = lastBranchId
19:
header.m.junction = parentHash
20:
if parent.m.chldn.length == 2 then
21:
SETJUNCTION(parent.m.chldn[0], parentHash)
22:
mainChainHead = GETMAINCHAINHEAD( )
IV. ETH RELAY
This section introduces ETH Relay, a novel relay scheme
that keeps operating cost low while remaining fully decentral-
ized and secure. The relay scheme consists of a relay contract
(i.e., a smart contract) running on the destination blockchain
and off-chain clients (see Fig. 2).
A. Validation-on-demand
In ETH Relay‚Äîjust like in any relay scheme‚Äîoff-chain
clients are responsible for continuously relaying block headers
of the source blockchain to the relay contract on the destina-
tion blockchain. Algorithm 1 shows the pseudo code that is
executed for each newly submitted block header.
Right after the arrival of a new header, it is checked that the
retrieved header has not been submitted to the relay contract
before (Line 2) and that the parent block referenced by the
header is known to ensure that only a continuous chain of block
headers is replicated within the relay contract (Line 5). If both
checks are successful, the header is stored in a hashmap with
the header‚Äôs hash as key and the header itself as value (Line 7).
Notably, a full header validation as done by traditional
relay solutions such as BTC Relay is not carried out. Instead,
the key to reducing operating cost in ETH Relay lies in a
validation-on-demand pattern. That means, newly submitted
block headers do not immediately undergo the expensive full
header validation procedure of the source blockchain. Rather,
they are optimistically accepted by the relay contract. Of
course, this may lead to invalid block headers entering the relay
206
Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA. Downloaded on July 14,2025 at 17:00:25 UTC from IEEE Xplore.  Restrictions apply. 
contract. Therefore, each newly received header is ‚Äúlocked‚Äù for
a certain amount of time (Line 8), during which a block header
cannot be used for SPVs.
To Ô¨Ålter out the invalid block headers that may have entered
the relay contract, locked headers can be disputed by the off-
chain clients as shown in Fig. 2. That is, the clients monitor
the relay contract and the source blockchain. Whenever they
detect a block header that is submitted to the relay contract
and that does not constitute a valid block header of the source
blockchain, they send a dispute request to the relay contract.
In case of a dispute, the full header validation according to
the rules of the source blockchain is carried out by the relay
contract. If the validation fails, the invalid block header is
removed from the contract. If in the meantime, block headers
have been submitted to the relay contract that derive from
the invalid block header, these descendants are removed as
well (see Fig. 2).
Once the lock period has passed, block headers are con-
sidered valid. From then on, SPVs on these headers can be
carried out. While the validation-on-demand pattern already
reduces cost of submitting block headers, ETH Relay applies
a further optimization for reducing operating cost by using a
modiÔ¨Åed version of the so-called content-addressable storage
pattern [18].
B. Content-Addressable Storage Pattern
The idea of the content-addressable storage pattern is that
not all data needs to be stored directly in the relay contract.
Instead, the remaining data is stored externally. As Ethereum
transactions also include the parameters of smart contract
invocations, submitted block headers are implicitly recorded
in the blockchain‚Äôs transaction history. We can take advantage
of this fact by storing only the hash of the block header,
the block number and certain meta data in the relay contract
itself. Whenever clients initiate a dispute or an on-chain SPV,
they read the required full header data from the corresponding
submit-transactions recorded in the transaction history and
provide it to the relay contract. The contract can then verify
the provided headers‚Äô integrity by recalculating their hashes
and comparing them to the hashes stored in the relay contract.
This way, no trust in the client invoking an SPV or a block
header dispute is required. With Ô¨Åelds such as the parent hash
or the Merkle root hash no longer being kept in the relay
contract directly, the amount of stored data per block header
is reduced‚Äîsubsequently further reducing submission cost.
Notably, while the content-addressable storage pattern leads
to reduced submission cost it may increase cost of executing
SPVs and header disputes since more data needs to be passed
with each request (see Section VII for details).
Obviously, the correct functioning of ETH Relay is only
ensured if off-chain clients continuously submit block headers
of the source blockchain to the relay contract on the destination
blockchain and dispute any invalid block headers entering the
relay contract. However, clients that submit and dispute block
headers incur cost. Thus, an incentive structure for encouraging
(honest) participation is needed. The details of this incentive
structure are explained in the next section.
C. Incentive Structure
Without an incentive structure that compensates off-chain
clients for submitting and disputing block headers, clients
may have no interest in participating in the proposed relay
scheme. The incentive structure we propose rewards off-chain
clients for submitting and disputing block headers and also
discourages submission of invalid block headers.
To hold clients that submit invalid block headers account-
able, clients are required to deposit a stake for every submitted
header. The stake is locked for the duration of the lock period
of newly submitted block headers. While the stake is locked,
it cannot be withdrawn and cannot be used for submitting
further block headers. After a submitted header has passed
the lock period without a dispute, the client that submitted the
header gets back control of the corresponding stake. However,
in case the block header is disputed successfully within the
lock period, i.e., the validation of the block header fails,
the client that triggered the dispute earns the locked stake
of the submitter as well as any stake that was locked for
any descendant of the illegal block header. Not only does
this incentivize disputes, it also discourages submission of
invalid block headers as clients risk losing the deposited stake.
Of course, clients are only incentivized to dispute headers if
the potential reward is higher than the cost of executing the
dispute.
To encourage the submission of block headers, clients re-
ceive a fee every time their submitted headers are used for
SPVs. This veriÔ¨Åcation fee is paid by the client requesting the
veriÔ¨Åcation. To fully compensate submitting clients, the total
veriÔ¨Åcation fees earned on each header need to be greater than
the initial submission cost for that header (Eq. (1)).
fee √ó no. of veriÔ¨Åcations > submission cost
(1)
The minimum veriÔ¨Åcation fee can thus be calculated as the
average submission cost divided by the expected number of
veriÔ¨Åcations per block header (Eq. (2)).
fee >
submission cost
no. of veriÔ¨Åcations
(2)
With headers replicated within the relay contract and an
incentive structure in place to encourage participation and
honest behavior, the next section looks at how SPVs are
executed within ETH Relay.
V. SIMPLIFIED PAYMENT VERIFICATION IN ETH RELAY
Once headers are replicated within the relay contract, clients
(e.g., other smart contracts) can send a request to the relay
contract in the form of ‚ÄúIs transaction tx of block b part of
the source blockchain and conÔ¨Årmed by at least n blocks?‚Äù.
To answer the request, the relay contract executes an on-chain
SPV. Since SPVs should only be successful if the requested
block is part of the main chain of the source blockchain,
207
Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA. Downloaded on July 14,2025 at 17:00:25 UTC from IEEE Xplore.  Restrictions apply. 
Block 0x11
Height: 17
BranchId: 1
Junction: 0x10
Block 0x12
Height: 18
BranchId: 1
Junction: 0x10
Block 0x13
Height: 19
BranchId: 1
Junction: 0x12
Block 0x14
Height: 19
BranchId: 2
Junction: 0x12
Block 0x15
Height: 20
BranchId: 1
Junction: 0x12
Block 0x16
Height: 21
BranchId: 1
Junction: 0x15
Block 0x18
Height: 21
BranchId: 3
Junction: 0x15
Block 0x19
Height: 22
BranchId: 3
Junction: 0x15
Block 0x1A
Height: 23
BranchId: 3
Junction: 0x15
Block 0x17
Height: 22
BranchId: 1
Junction: 0x15
Block 0x10
Height: 16
BranchId: 1
Junction: 0x2
Block 0x1B
Height: 17
BranchId: 4
Junction: 0x10
Fig. 3. An example illustrating the replication of a source blockchain within the relay contract. Headers are double-linked (denoted by arrows pointing in both
directions) as ETH Relay stores in each block header the parent hash as well as the hashes of its children. Green headers represent the current main chain of the
source blockchain. For the sake of simplicity, block hashes are in ascending order to make it clearly evident which block headers have been submitted before
others to the contract, e.g., block header 0x11 was submitted after block header 0x10, 0x1B after 0x1A, and so on. Block headers 0x1B, 0x14, 0x17, and 0x1A
are heads of the corresponding branch. Block headers 0x10, 0x12, and 0x15 represent branch junctions.
the relay contract performs the following four steps. First, it
determines the current main chain of the source blockchain
(see Section V-A). Second, the contract checks whether h is
unlocked (i.e., the lock period has passed) and part of the
main chain (see Section V-B). Third, the contract veriÔ¨Åes that
h is conÔ¨Årmed by at least n succeeding block headers (see
Section V-C). Finally, it is checked whether tx is actually
included in block b by means of a Merkle proof of membership
(see Section V-D).
A. Determining the Main Chain
As mentioned in Section II, the main chain of a blockchain
may change over time as new blocks are appended to different
branches. In ETH Relay, the relay contract tracks the head of
each branch, i.e., the latest block header that was appended
to the branch. We consider Algorithm 1 again. Whenever a
new block header is received, it is added to the set of branch
heads (Line 11) as it either starts a completely new branch
or it becomes the new head of an existing branch in which
case it replaces its parent (Lines 12ff). The contract then re-
evaluates the branch head with the greatest difÔ¨Åculty storing
it in a global variable mainChainHead (Line 22). This branch
head represents the current head of the main chain of the source
blockchain.
B. Verifying Main Chain Membership
With the main chain determined, the relay contract now
needs to verify that header h is unlocked and actually part
of the main chain. As blockchains with multiple branches
represent a Directed Acyclic Graph (DAG) [19], determining
main chain membership boils down to a classical problem
in graph theory, the so-called reachability problem. In graph
theory, reachability refers to the ability of some node v to
reach some other node s within a graph [20]. Verifying the
membership of some block b on the main chain (which is a
speciÔ¨Åc branch of the DAG) is done by checking whether the
main chain‚Äôs head (i.e., the latest block of the main chain) can
reach block b.
As each block header contains a hash pointer to its parent,
we could simply trace from the main chain‚Äôs head all the way
back until we reach the requested block header or the genesis
block. However, depending on how far back the requested
block lies, this traversal can be expensive.
To make this traversal more cost-efÔ¨Åcient, ETH Relay
follows a design inspired by the chain decomposition ap-
proach [20]. Within the relay contract, the source blockchain
(i.e., the DAG) is partitioned into its individual branches with
each branch being assigned a unique identiÔ¨Åer. To track branch
memberships, each block header gets assigned the id of the
branch it belongs to. Furthermore, for each received header,
the relay contract stores a reference to the preceding branch
junction, i.e., a reference to the header where the branch of the
newly submitted block header branches off. This meta data is
stored in the Ô¨Åelds m.branchId and m.junction, respectively.
In case the submitted header continues an existing branch,
m.branchId and m.junction are set to the corresponding Ô¨Åeld
values of its parent, as shown in Lines 14 and 15 of Algo-
rithm 1. If a new branch occurs, m.branchId gets assigned
the maximum branch id used so far incremented by one
and m.junction of the submitted header is set to the parent‚Äôs
hash (Lines 17 to 19).
The introduced helper Ô¨Åelds m.branchId and m.junction
enable a more efÔ¨Åcient search when verifying the membership
of some block header on the main chain, as the backwards
traversal can be executed in jumps from branch junction to
branch junction rather than from block header to block header.
Consider the example illustrated in Fig. 3 which shows
a source blockchain replicated within the relay contract. All
block headers between two consecutive branch junctions or
between a branch junction and a branch head have the same
branch id BranchId. Since a submitted header‚Äôs branch id is
either set to its parent‚Äôs branch id or to the maximum branch id
incremented by one, we know that all descendants of some
block header (i.e., headers that build upon this header) have a
branch id equal to or greater than the branch id of that header.
Analogous, all predecessors of some header have a branch id
208
Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA. Downloaded on July 14,2025 at 17:00:25 UTC from IEEE Xplore.  Restrictions apply. 
equal to or lower than the branch id of that header.
This constraint can be used to efÔ¨Åciently verify whether
block header h is part of the main chain of the source
blockchain, i.e., whether the block header h is a predecessor
of the main chain‚Äôs head.
If block header h has a branch id that is greater than the
branch id of the main chain‚Äôs head (i.e., mainChainHead), we
know‚Äîwithout having to traverse any header‚Äîthat header h
cannot be a predecessor of mainChainHead and thus not be
part of the main chain.
If block header h has the same branch id as mainChainHead,
we know that h is part of the main chain since header h and
mainChainHead belong to the same branch. Again, no block
header needs to be traversed.
In case the branch id of header h is smaller than the
branch id of the main chain‚Äôs head, we cannot know with
certainty whether h is part of the main chain. Consider block
header 0x16 in Fig. 3. Despite having a branch id lower than
header 0x1A (i.e., the head of the main chain), header 0x16
is not part of the main chain. Hence, the relay contract starts
at the main chain‚Äôs head and traverses each reachable branch
junction until a branch junction j is reached that has a branch id
lower than or equal to the branch id of header h. Note that the
next branch junction can be retrieved from the Ô¨Åeld m.junction
of the currently traversed branch junction.
If the branch id of j is lower than the branch id of h, we
know that h is not part of the main chain as h cannot be a
predecessor of junction j due to the higher branch id. In case
both headers have the same branch id, we know that they are
both part of at least one common branch. However, it can still
be the case that h is not part of the main chain. Consider
block headers 0x15 and 0x16 in Fig. 3. If 0x15 is the branch
junction j and 0x16 the header h, 0x15 is part of the main chain
while 0x16 is not. As such, the relay contract compares the
block heights of j and h. If h.blockHeight > j.blockHeight, h
is not part of the main chain. If h.blockHeight ‚â§j.blockHeight,
j and h are either the same or j is a branch junction between
h and the main chain‚Äôs head. Hence, in both cases, h is part
of the main chain.
We note that it is completely sufÔ¨Åcient to only traverse
branch junctions since all headers between two consecutive
branch junctions or between a branch junction and a branch‚Äôs
head always have the same branch id. As all headers in-
between are skipped, the relay contract only checks a few block
headers instead of traversing all headers between the header h
and the main chain‚Äôs head as done in a na¬®ƒ±ve search.
C. Counting Block ConÔ¨Årmations
With main chain membership determined, it needs to be
veriÔ¨Åed that header h is already conÔ¨Årmed by a certain number
of block headers to increase the likelihood of the block
remaining part of the main chain [1]. For that purpose, the
relay contract maintains a reference to each header‚Äôs immediate
children. Whenever a new block header is received, the relay
contract adds its hash to its parent‚Äôs child list (Line 10 of
Algorithm 1). Typically, a header only has one child. If the
header is a branch junction, the list contains at least two
children (i.e., the hashes of the block headers branching off
from the header).
Of course, for each conÔ¨Årming block header the lock period
must be over. To verify the number of conÔ¨Årmations, the relay
contract temporarily stores a reference to the last unlocked
branch junction that was encountered while determining main
chain membership of header h. Starting at that branch junction,
all its descendants are traversed in the direction of the main
chain until enough unlocked (conÔ¨Årming) block headers are
found (as all headers between h and the starting point are
unlocked, these header count already as conÔ¨Årming headers).
If a block header is encountered that is locked or there is no
descendant to check (i.e., the main chain‚Äôs head is reached),
we know that h has not enough conÔ¨Årmations. In this case, the
SPV fails.
Once more, consider the example in Fig. 3. Assuming
membership of block header 0x11 should be veriÔ¨Åed and block
header 0x15 is the most recent unlocked branch junction.
Therefore, the starting point for the conÔ¨Årmation veriÔ¨Åcation
is block header 0x18.
D. Verifying the Merkle Proof of Membership
After verifying that header h is unlocked, part of the source
blockchain‚Äôs current main chain and that h is conÔ¨Årmed by at
least n succeeding block headers, the relay contract checks the
Merkle proof of membership.
If the veriÔ¨Åcation of the Merkle proof fails, transaction tx
is not part of the corresponding block b of header h. If it
is successful, tx is included within block b. Since the relay
contract has already veriÔ¨Åed h‚Äôs membership in the main chain
of the source blockchain and n headers succeeding h, it can be
concluded that transaction tx is in fact included in the source
blockchain.
By specifying a sufÔ¨Åciently large number of conÔ¨Årmations,
clients requesting a veriÔ¨Åcation increase the probability that
transaction tx remains in the main chain of the source block-
chain. Further, as the veriÔ¨Åcation procedure relies on the source
blockchain‚Äôs headers being exactly replicated within the relay
contract on the destination blockchain, it must be difÔ¨Åcult to
tamper with the relay. The next section analyzes the security
of the relay.
VI. SECURITY ANALYSIS
This section provides a security analysis of ETH Relay
by looking at possible attack scenarios and investigating
consequences on the relay in case changes to the involved
blockchains occur.
For the following discussion, we suppose the set of off-
chain clients to remain static during an attack. Furthermore,
our analysis is based on the following assumptions: (a) no
off-chain client is guaranteed to follow the proposed relay
scheme, (b) the actions of many clients are driven by self-
interest, and (c) some clients may categorically deviate from
209
Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA. Downloaded on July 14,2025 at 17:00:25 UTC from IEEE Xplore.  Restrictions apply. 
the scheme. Accordingly, we categorize off-chain clients into
three groups according to the BAR (Byzantine, Altruistic,
Rational) model [21]. This model has found application in
security analysis for blockchain protocols and extensions be-
fore, e.g., [22, 23]. Under this model, byzantine clients may
depart arbitrarily from the relay scheme for any reason, e.g.,
they may be faulty or may just follow strategies optimizing an
unknown utility function. Altruistic clients always follow the
proposed scheme, regardless of whether deviations would lead
to a higher proÔ¨Åt. They exhibit no adversarial behavior. Finally,
rational clients are self-interested, aiming at maximizing their
proÔ¨Åt according to a known utility function. These clients will
depart from the scheme if they expect doing so to yield a higher
proÔ¨Åt than being honest.
A. Relay Poisoning
To reliably execute on-chain SPVs, the relay contract de-
pends on off-chain clients constantly submitting block headers.
Thus, an attacker may try to poison the relay contract with
invalid block headers. For that, the attacker must attempt a
chain re-organization within the relay contract according to
the consensus rules of the source blockchain, i.e., the attacker
must submit enough block headers such that these headers
form the new main chain within the relay contract. A chain
re-organization allows the attacker to request SPVs on invalid
block headers. For instance, an application relying on the relay
contract can be tricked into performing actions on the basis of
transactions that never occurred on the source blockchain.
Essentially, an attacker can choose between two approaches.
Either the attacker sends invalid block headers to the relay
contract or the attacker submits headers which are themselves
valid but belong to blocks containing invalid transactions (i.e.,
a header validation in case of a dispute would not detect any
anomaly). We discuss these two attack models in the next
subsections.
1) Incentive Attacks on Disputes:
Option one to achieve relay poisoning is for the attacker to sub-
mit illegal block headers while preventing other clients from
disputing these headers. The advantage of this approach is that
the attacker does not have to follow the source blockchain‚Äôs
consensus rules for creating block headers, e.g., the attacker
does not have to solve the PoW for each header. This enables
the attacker to create block headers at a much faster rate.
However, disputes of these illegal headers would be successful
since the block header validation would inevitably fail. Hence,
to launch a successful attack, the attacker needs to convince
all participating clients to not dispute any illegal headers for
the duration of the headers‚Äô lock periods, e.g., by launching
incentive attacks [23].
Imagine all off-chain clients to act rationally. Even with in-
centives perfectly aligned, rational clients seeking to maximize
proÔ¨Åt will deviate from the relay scheme if they expect doing
so to yield a higher proÔ¨Åt. For instance, an attacker may offer
these clients an alternative reward that is more proÔ¨Åtable than a
successful dispute of invalid block headers. Naturally, the more
clients participate in the relay, the more expensive the attack
becomes since each client needs to be convinced to follow the
attack. However, if all clients act rationally and the attacker
has sufÔ¨Åcient funds, an attack may be successful. In general,
correct behavior is never guaranteed in systems that rely on all
clients acting rationally since clients can always Ô¨Ånd ways to
yield larger proÔ¨Åts in a greater ecosystem [24].
Fortunately, the relay contract can determine the validity of
headers by itself. It just needs a single client to trigger this
validation in form of a dispute. Thus, if just one client acts
altruistically, incentive attacks always fail ensuring the correct
functioning of the relay scheme. As building open and per-
missionless systems that withstand all participants potentially
deviating from the intended rules appears to be fundamentally
impossible [24], an acceptable trade-off is a system that only
requires a single altruistic participant out of all participants.
2) Incentive Attacks on Submissions:
Option two for achieving relay poising is for the attacker to
submit block headers that are valid according to the source
blockchain‚Äôs header validation procedure but belong to blocks
containing illegal transactions. Disputing these headers would
not be successful since the header validation performed by the
relay contract does not include the validation of transactions.
Hence, the attacker could request SPVs on illegal transactions.
If other clients continue to submit the correct headers from the
source blockchain, the only way this attack can be successful is
if the attacker is able to create and submit valid block headers
at a faster rate than the network of the source blockchain, e.g.,
by launching a 51% attack [13].
Alternatively, the attacker may try to convince the other
clients to refrain from submitting block headers for the duration
of the attack. This way, the attacker‚Äôs block headers are the
only ones arriving at the relay contract on the destination
blockchain. If all clients act rationally, the attacker may
convince them to join the attack, e.g., by offering a bribe.
However‚Äîanalogue to what has been discussed above‚Äîsince
all clients need to be convinced, the cost of this attack grows
proportionally with the number of participants. Again, if there
is just one altruistic client that continuously submits the block
headers created by the network of the source blockchain, the
success of this attack is about as likely as a successful 51%
attack on the source blockchain.
B. Changes to the Source Blockchain
Besides deliberate attacks as discussed in the prior sections,
changes to the source blockchain may affect the reliability of
the relay contract as well.
When changing the block header validation procedure of the
source blockchain, it becomes either less or more restrictive.
In the Ô¨Årst case, headers adhering to the new validation
rules would be rejected by the relay contract when being
received, or clients would be able to successfully dispute block
headers that are actually valid under the new rules. If the
header validation becomes more restrictive, newly introduced
validation rules are not enforced by the relay contract, possibly
210
Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA. Downloaded on July 14,2025 at 17:00:25 UTC from IEEE Xplore.  Restrictions apply. 
leading to the acceptance of headers invalid under the new
rules. Thus, any change to the header validation procedure
of the source blockchain requires an update of the header
validation procedure performed within the relay contract. On
the other hand, if changes to the source blockchain do not
affect the header validation procedure, the relay contract does
not need to be updated.
In case the source blockchain‚Äôs network does not reach
consensus on an upcoming update, the source blockchain may
be split up, resulting in multiple instances of the same block-
chain. Technically, such instances are just branches originating
from the same blockchain. While the relay contract is able
to keep track of branches, only one branch is used for on-
chain SPVs. Hence, there may be a competition of multiple
instances of the source blockchain to form the main chain
within the relay contract. Which branch eventually overtakes
the others may be unclear at the time the blockchain is split
up. If multiple blockchain instances were to be supported,
additional deployments of the relay contract would be required.
VII. QUANTITATIVE ANALYSIS
To evaluate ETH Relay, we implemented a total of three
prototypes (Baseline, ETH Relay 1, and ETH Relay 2, re-
spectively) for Ethereum Virtual Machine (EVM)-based block-
chains such as Ethereum and Ethereum Classic.
As the name implies, Baseline acts as baseline for our
experiments. This prototype does not implement the validation-
on-demand pattern. Instead, it fully validates each block header
at submission as done by existing relays such as BTC Relay.
Furthermore, Baseline implements a na¬®ƒ±ve search algorithm
for verifying main chain membership starting from the main
chain‚Äôs head, traversing each header until the header suppos-
edly containing the transaction is found or the genesis block
is reached.
In contrast, the prototypes ETH Relay 1 and ETH Relay 2
both implement the validation-on-demand pattern and imple-
ment the more efÔ¨Åcient search for verifying main chain mem-
bership as explained in Section V-B. ETH Relay 2 additionally
applies the content-addressable storage pattern as explained in
Section IV-B.
The functionality of each prototype is summed up in Table 1.
A fully functional reference implementation of all concepts and
algorithms of the relay contract, an off-chain client written in
Go, and the evaluation are available as open-source projects
on GitHub123. For repeatability, the evaluation project not only
contains the three prototypes used for the evaluation but also
the evaluation scripts, the necessary block header data as SQL
dump, and the results.
A. Experiments
To evaluate the operating cost of the relay contract, we
used a Geth light client (version 1.9.10) to collect 154,445
1https://github.com/pantos-io/ethrelay
2https://github.com/pantos-io/go-ethrelay
3https://github.com/pantos-io/ethrelay-evaluation
TABLE 1
PROTOTYPE FUNCTIONALITY
Functionality
Baseline
ETH Relay 1
ETH Relay 2
Validation-on-submission
‚úì
Validation-on-demand
‚úì
‚úì
Content-adressable storage
‚úì
Na¬®ƒ±ve search
‚úì
Optimized search
‚úì
‚úì
block headers containing 2,542 branches from the Ethereum
main network from 17.12.2019 to 14.01.2020. Note that we
also count uncle blocks as branches, since‚Äîwhen submitted
to the relay contract‚Äîthey would introduce a new branch.
We then feed these block headers into the three prototypes
that are deployed as smart contracts on a private development
blockchain running on a Parity Ethereum node (version 2.6.8-
beta, ‚ÄìconÔ¨Åg dev). All three prototypes are initialized with
block #9121452 as genesis block.
In the Ô¨Årst experiment, we analyze the operating cost (i.e.,
the cost of submitting block headers), the cost of on-chain
SPVs, and whether the source blockchain is correctly replicated
within the relay contract. For that, we continuously submit all
block headers of our dataset to each prototype. The headers
are submitted in ascending order according to their block
numbers and timestamp Ô¨Åelds. After each submission, an SPV
on the genesis block (block #9121452) is triggered. Since
the replicated header chain within the relay contract grows
after each submission, the algorithm checking whether block
#9121452 is part of the main chain has to deal with a growing
number of headers. This allows us to observe the cost of
executing SPVs with an increasing search depth.
We measure the cost of each operation by the gas consump-
tion of its corresponding Ethereum transaction. Furthermore,
after each submission, we log the head of the main chain
and the currently submitted header‚Äôs branch id and branch
junction within the relay contract. This enables us to verify
that the submitted headers of the source blockchain (i.e., the
Ethereum main network) are correctly replicated within the
prototypes running on the destination blockchain (i.e., private
development blockchain).
To measure the cost of header disputes, we repeat the Ô¨Årst
experiment, however, instead of performing an SPV after each
submission, we trigger a dispute on the genesis block (block
#9121452). For simplicity, as we are primarily interested in the
cost caused by the removal of branches, we remove the branch
originating from the disputed header regardless of the actual
result of the header validation. After each dispute, all removed
headers are resubmitted to restore the state. This allows us to
observe the dispute cost with a growing number of headers that
have to be pruned. The cost of each dispute (in gas) is logged
only for prototypes ETH Relay 1 and ETH Relay 2, since
prototype Baseline already performs the full header validation
at time of submission.
211
Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA. Downloaded on July 14,2025 at 17:00:25 UTC from IEEE Xplore.  Restrictions apply. 
0
3.3
0.6
0.28
¬∑106
:b *QMbmKTiBQM
UV >2/2` bm#KBbbBQMb
0
50,000
1 ¬∑ 105
1.5 ¬∑ 105
0
2
4
6
¬∑106
O Q7 bm#KBii2/ ?2/2`b
U#V PM@+?BM aSob
0
20
40
60
2
3.3
¬∑106
O Q7 bm#KBii2/ ?2/2`b
U+V >2/2` /BbTmi2b
""b2HBM2
1h> _2Hv R
1h> _2Hv k
Fig. 4. Gas consumption of the relay contract
B. Results
Figure 4 depicts the results of our experiments. Figure 4(a)
shows the average gas consumption per header submission
for each prototype. With 612,348 gas (standard deviation of
6,592 gas), ETH Relay 1 achieves a signiÔ¨Åcant cost reduction
of 82% over Baseline (average gas consumption of 3,369,653
gas, standard deviation of 5,101 gas). By applying the content-
addressable storage pattern, ETH Relay 2 reduces the average
gas consumption of ETH Relay 1 by 54%, resulting in gas
cost of 284,041 for every submitted header (standard deviation
of 3,679 gas). Compared to Baseline, ETH Relay 2 reduces
submission cost by 92%.
Figure 4(b) depicts the cost for executing on-chain SPVs
on the genesis block (block #9121452) for each prototype.
The x-axis denotes the number of succeeding block headers
that have already been submitted to the relay. Since SPVs are
always performed on the genesis block, the search algorithms
verifying the membership on the main chain have to cope with
an increasing search depth. Prototype Baseline using the na¬®ƒ±ve
search algorithm reaches the private blockchain‚Äôs block gas
limit of 6.7 million gas already after 18,766 submitted headers.
ETH Relay 1 and ETH Relay 2 can cope with the growing
search depth at much lower cost.
Notably, ETH Relay 2 is slightly more expensive than
ETH Relay 1 due to the implementation of the content-
addressable storage pattern requiring the full block header to
be provided at every execution of an SPV. Hence, applying this
pattern is a trade-off between low submission cost and slightly
higher cost for SPVs. Notably, gas consumption is measured
in a worst-case scenario where each block header is submitted
to the relay even if it may not be part of the actual main
chain of the source blockchain. In practice, the veriÔ¨Åcation
cost measured for ETH Relay 1 and ETH Relay 2 may be
much lower since clients may be reluctant to submit headers
which are not part of the main chain since these headers will
not yield a proÔ¨Åt.
Figure 4(c) shows the dispute cost measured for ETH Re-
lay 1 and ETH Relay 2 (Baseline has no dispute cost at
all, since it does not implement the validation-on-demand
pattern). Despite the fact that a growing number of headers
has to be removed with each dispute, the dispute cost of both
prototypes temporarily declines. This is because freeing up
contract storage in Ethereum-based blockchains yields a so-
called gas refund which is given at the end of a successful
transaction execution [25]. From a certain point on (after nine
headers for ETH Relay 1 and 23 headers for ETH Relay 2),
the dispute cost starts to rise which is caused by the design
rationale that the gas refund is capped up to a maximum
of the half of the total gas consumed by a transaction [25].
Furthermore, as shown in the Ô¨Ågure, ETH Relay 1 reaches
the block gas limit much earlier than ETH Relay 2. Notably,
the gas refund is given only after the successful execution
of a transaction, i.e., reaching the block gas limit makes the
transaction fail without yielding any gas refund. This is why
both graphs stop at around 3.3 million gas (last successful
disputes) before reaching the block gas limit. If a branch is
too long to be disputed within a single invocation, the dispute
function can be called multiple times with each invocation
pruning one part of the illegal branch.
In the Ô¨Årst experiment, the branch id and branch junction
of each submitted header as recorded by each of the three
prototypes were logged. This data allows us to verify whether
all branches of the dataset have been correctly replicated within
the relays. In particular, we extracted all unique junctions from
the results as well as from our dataset. A comparison of both
lists shows that all 2,542 branches were correctly recognized
by the three prototypes.
VIII. CONCLUSION
For Ethereum-based blockchains, existing relay schemes are
either very costly, rely on authorized parties, or may not
be technologically feasible. As a solution to this problem,
we introduced ETH Relay, a novel relay scheme especially
suited for Ethereum-based blockchains. ETH Relay uses a
validation-on-demand pattern combined with a sophisticated
incentive structure to motivate honest participation. Our eval-
uation shows that ETH Relay is able to reliably verify the
212
Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA. Downloaded on July 14,2025 at 17:00:25 UTC from IEEE Xplore.  Restrictions apply. 
inclusion of transactions across blockchains while reducing
the operating cost in comparison to traditional blockchain
relays by up to 92%. ETH Relay does not require trust in
a centralized party. As such, it provides a further step in
enabling decentralized interoperability between blockchains.
While the cost beneÔ¨Åts of ETH Relay are evident for EVM-
based blockchains, the proposed relay scheme can be leveraged
whenever the block header validation of the source blockchain
is so costly that validating every single block header on
the destination blockchain is too expensive. Hence, the basic
approach presented in this paper could also be applied with
regard to other blockchain technologies.
In the current approach, every block header of the source
blockchain needs to be submitted to the destination blockchain.
In future work, in an effort to reduce submission cost even
further, we will investigate the feasibility of batch submis-
sions of Ethereum block headers using zero-knowledge proofs
similar to the approach taken by zkRelay for Bitcoin block
headers. Further, we will look into optimization opportunities
for verifying main chain membership. While there exist graph
algorithms capable of verifying main chain membership in
constant time, these algorithms often require a precomputation
phase with additional storage demands possibly increasing
submission cost [20]. In upcoming research, we will investigate
the trade-off between submission cost and optimizations of the
on-chain execution of SPVs.
ACKNOWLEDGEMENTS
The Ô¨Ånancial support by the Austrian Federal Ministry for
Digital and Economic Affairs, the National Foundation for
Research, Technology and Development and the Christian
Doppler Research Association is gratefully acknowledged.
"
pdf//Hawk_The_Blockchain_Model_of_Cryptography_and_Privacy-Preserving_Smart_Contracts.pdf;A. Hawk Overview We propose Hawk, a framework for building privacy- preserving smart contracts.;These emerging cryptocur- rency systems build atop a novel blockchain technology where miners run distributed consensus whose security is ensured if no adversary wields a large fraction of the computational (or other forms of) resource.;"However, this paper refers to the entire protocol deÔ¨Åned by the Hawk program as a contract; and the blockchain‚Äôs program is a constituent of the bigger protocol.";These emerging cryptocur- rency systems build atop a novel blockchain technology where miners run distributed consensus whose security is ensured if no adversary wields a large fraction of the computational (or other forms of) resource.;[('coin', 127), ('party', 110), ('blockchain', 103), ('contract', 97), ('protocol', 87), ('program', 83), ('manager', 75), ('public', 70), ('user', 69), ('p', 69)];;;"Hawk: The Blockchain Model of Cryptography and
Privacy-Preserving Smart Contracts
Ahmed Kosba‚àó, Andrew Miller‚àó, Elaine Shi‚Ä†, Zikai Wen‚Ä†, Charalampos Papamanthou‚àó
‚àóUniversity of Maryland and ‚Ä†Cornell University
{akosba, amiller}@cs.umd.edu, {rs2358, zw385}@cornell.edu, cpap@umd.edu
Abstract‚ÄîEmerging smart contract systems over decentralized
cryptocurrencies allow mutually distrustful parties to transact
safely without trusted third parties. In the event of contrac-
tual breaches or aborts, the decentralized blockchain ensures
that honest parties obtain commensurate compensation. Existing
systems, however, lack transactional privacy. All transactions,
including Ô¨Çow of money between pseudonyms and amount
transacted, are exposed on the blockchain.
We present Hawk, a decentralized smart contract system that
does not store Ô¨Ånancial transactions in the clear on the block-
chain, thus retaining transactional privacy from the public‚Äôs view.
A Hawk programmer can write a private smart contract in an
intuitive manner without having to implement cryptography, and
our compiler automatically generates an efÔ¨Åcient cryptographic
protocol where contractual parties interact with the blockchain,
using cryptographic primitives such as zero-knowledge proofs.
To formally deÔ¨Åne and reason about the security of our
protocols, we are the Ô¨Årst to formalize the blockchain model
of cryptography. The formal modeling is of independent interest.
We advocate the community to adopt such a formal model when
designing applications atop decentralized blockchains.
I. INTRODUCTION
Decentralized cryptocurrencies such as Bitcoin [48] and alt-
coins [20] have rapidly gained popularity, and are often quoted
as a glimpse into our future [5]. These emerging cryptocur-
rency systems build atop a novel blockchain technology where
miners run distributed consensus whose security is ensured if
no adversary wields a large fraction of the computational (or
other forms of) resource. The terms ‚Äúblockchain‚Äù and ‚Äúminers‚Äù
are therefore often used interchangeably.
Blockchains like Bitcoin reach consensus not only on a
stream of data but also on computations involving this data. In
Bitcoin, speciÔ¨Åcally, the data include money transfer transac-
tion proposed by users, and the computation involves transac-
tion validation and updating a data structure called the unspent
transaction output set which, imprecisely speaking, keeps track
of users‚Äô account balances. Newly emerging cryptocurrency
systems such as Ethereum [57] embrace the idea of running
arbitrary user-deÔ¨Åned programs on the blockchain, thus creat-
ing an expressive decentralized smart contract system.
In this paper, we consider smart contract protocols where
parties interact with such a blockchain. Assuming that the
decentralized concensus protocol is secure, the blockchain can
be thought of as a conceptual party (in reality decentralized)
that can be trusted for correctness and availability but not for
privacy. Such a blockchain provides a powerful abstraction for
the design of distributed protocols.
The blockchain‚Äôs expressive power is further enhanced by
the fact that blockchains naturally embody a discrete notion
of time, i.e., a clock that increments whenever a new block
is mined. The existence of such a trusted clock is crucial
for attaining Ô¨Ånancial fairness in protocols. In particular,
malicious contractual parties may prematurely abort from a
protocol to avoid Ô¨Ånancial payment. However, with a trusted
clock, timeouts can be employed to make such aborts evident,
such that the blockchain can Ô¨Ånancially penalize aborting
parties by redistributing their collateral deposits to honest,
non-aborting parties. This makes the blockchain model of
cryptography more powerful than the traditional model without
a blockchain where fairness is long known to be impossible
in general when the majority of parties can be corrupt [8],
[17], [24].
In summary, blockchains allow parties mutually
unbeknownst to transact securely without a centrally trusted
intermediary, and avoiding high legal and transactional cost.
Despite the expressiveness and power of the blockchain
and smart contracts, the present form of these technologies
lacks transactional privacy. The entire sequence of actions
taken in a smart contract are propagated across the network
and/or recorded on the blockchain, and therefore are publicly
visible. Even though parties can create new pseudonymous
public keys to increase their anonymity, the values of all trans-
actions and balances for each (pseudonymous) public key are
publicly visible. Further, recent works have also demonstrated
deanonymization attacks by analyzing the transactional graph
structures of cryptocurrencies [42], [52].
We stress that lack of privacy is a major hindrance towards
the broad adoption of decentralized smart contracts, since Ô¨Å-
nancial transactions (e.g., insurance contracts or stock trading)
are considered by many individuals and organizations as being
highly secret. Although there has been progress in designing
privacy-preserving cryptocurrencies such as Zerocash [11] and
several others [26], [43], [54], these systems forgo programma-
bility, and it is unclear a priori how to enable programmability
without exposing transactions and data in cleartext to miners.
A. Hawk Overview
We propose Hawk, a framework for building privacy-
preserving smart contracts. With Hawk, a non-specialist pro-
grammer can easily write a Hawk program without having to
2016 IEEE Symposium on Security and Privacy
2375-1207/16 $31.00 ¬© 2016 IEEE
DOI 10.1109/SP.2016.55
839
2016 IEEE Symposium on Security and Privacy
¬© 2016, Ahmed Kosba. Under license to IEEE.
DOI 10.1109/SP.2016.55
839
Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA. Downloaded on July 16,2025 at 23:03:37 UTC from IEEE Xplore.  Restrictions apply. 
implement any cryptography. Our Hawk compiler is in charge
of compiling the program to a cryptographic protocol between
the blockchain and the users. As shown in Figure 1, a Hawk
program contains two parts:
1) A private portion denoted œÜpriv which takes in parties‚Äô input
data (e.g., choices in a ‚Äúrock, paper, scissors‚Äù game) as well
as currency units (e.g., bids in an auction). œÜpriv performs
computation to determine the payout distribution amongst
the parties. For example, in an auction, winner‚Äôs bid goes to
the seller, and others‚Äô bids are refunded. The private Hawk
program œÜpriv is meant to protect the participants‚Äô data and
the exchange of money.
2) A public portion denoted œÜpub that does not touch private
data or money.
Our compiler will compile the Hawk program into the
following pieces which jointly deÔ¨Åne a cryptographic protocol
between users, the manager, and the blockchain:
‚Ä¢ the blockchain‚Äôs program which will be executed by all
consensus nodes;
‚Ä¢ a program to be executed by the users; and
‚Ä¢ a program to be executed by a special facilitating party
called the manager which will be explained shortly.
Security guarantees. Hawk‚Äôs security guarantees encompass
two aspects:
‚Ä¢ On-chain privacy. On-chain privacy stipulates that transac-
tional privacy be provided against the public (i.e., against
any party not involved in the contract) ‚Äì unless the con-
tractual parties themselves voluntarily disclose information.
Although in Hawk protocols, users exchange data with
the blockchain, and rely on it to ensure fairness against
aborts, the Ô¨Çow of money and amount transacted in the
private Hawk program œÜpriv is cryptographically hidden
from the public‚Äôs view. Informally, this is achieved by
sending ‚Äúencrypted‚Äù information to the blockchain, and
relying on zero-knowledge proofs to enforce the correctness
of contract execution and money conservation.
‚Ä¢ Contractual security. While on-chain privacy protects con-
tractual parties‚Äô privacy against the public (i.e., parties
not involved in the Ô¨Ånancial contract), contractual secu-
rity protects parties in the same contractual agreement
from each other. Hawk assumes that contractual parties
act selÔ¨Åshly to maximize their own Ô¨Ånancial interest. In
particular, they can arbitrarily deviate from the prescribed
protocol or even abort prematurely. Therefore, contractual
security is a multi-faceted notion that encompasses not only
cryptographic notions of conÔ¨Ådentiality and authenticity,
but also Ô¨Ånancial fairness in the presence of cheating and
aborting behavior. The best way to understand contractual
security is through a concrete example, and we refer the
reader to Section I-B for a more detailed explanation.
Minimally trusted manager. The execution of Hawk con-
tracts are facilitated by a special party called the manager.
The manager can see the users‚Äô inputs and is trusted not to
disclose users‚Äô private data. However, the manager is NOT to
Public –§pub    Private –§priv
Hawk Contract
Protocol
Coins
Data
Blockchain
Programmer
Compile
Manager
Users
Fig. 1. Hawk overview.
be equated with a trusted third party ‚Äî even when the manager
can deviate arbitrarily from the protocol or collude with the
parties, the manager cannot affect the correct execution of
the contract. In the event that a manager aborts the protocol,
it can be Ô¨Ånancially penalized, and users obtain compensation
accordingly.
The manager also need not be trusted to maintain the
security or privacy of the underlying currency (e.g., it cannot
double-spend, inÔ¨Çate the currency, or deanonymize users).
Furthermore, if multiple contract instances run concurrently,
each contract may specify a different manager and the effects
of a corrupt manager are conÔ¨Åned to that instance. Finally,
the manager role may be instantiated with trusted comput-
ing hardware like Intel SGX, or replaced with a multiparty
computation among the users themselves, as we describe in
Section IV-C and Appendix A.
Terminology. In Ethereum [57], the blockchain‚Äôs portion of
the protocol is called an Ethereum contract. However, this
paper refers to the entire protocol deÔ¨Åned by the Hawk
program as a contract; and the blockchain‚Äôs program is a
constituent of the bigger protocol. In the event that a manager
aborts the protocol, it can be Ô¨Ånancially penalized, and users
obtain compensation accordingly.
B. Example: Sealed Auction
Example program. Figure 2 shows a Hawk program for
implementing a sealed, second-price auction where the highest
bidder wins, but pays the second highest price. Second-
price auctions are known to incentivize truthful bidding under
certain assumptions, [55] and it is important that bidders
submit bids without knowing the bid of the other people. Our
example auction program contains a private portion œÜpriv that
determines the winning bidder and the price to be paid; and
a public portion œÜpub that relies on public deposits to protect
bidders from an aborting manager.
For the time being, we assume that the set of bidders are
known a priori.
Contractual security requirements. Hawk will compile this
auction program to a cryptographic protocol. As mentioned
earlier, as long as the bidders and the manager do not volun-
tarily disclose information, transaction privacy is maintained
against the public. Hawk also guarantees the following con-
tractual security requirements for parties in the contract:
840
840
Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA. Downloaded on July 16,2025 at 23:03:37 UTC from IEEE Xplore.  Restrictions apply. 
1
HawkDeclareParties(Seller,/* N parties */);
2
HawkDeclareTimeouts(/* hardcoded timeouts */);
3
// Private portion œÜpriv
4
private contract auction(Inp &in, Outp &out) {
5
int winner = -1;
6
int bestprice = -1;
7
int secondprice = -1;
8
for (int i = 0; i < N; i++) {
9
if (in.party[i].$val > bestprice) {
10
secondprice = bestprice;
11
bestprice = in.party[i].$val;
12
winner = i;
13
} else if (in.party[i].$val > secondprice) {
14
secondprice = in.party[i].$val;
15
}
16
}
17
// Winner pays secondprice to seller
18
// Everyone else is refunded
19
out.Seller.$val = secondprice;
20
out.party[winner].$val = bestprice-secondprice;
21
out.winner = winner;
22
for (int i = 0; i < N; i++) {
23
if (i != winner)
24
out.party[i].$val = in.party[i].$val;
25
}
26
}
27
// Public portion œÜpub
28
public contract deposit {
29
// Manager deposited $N earlier
30
def check():
// invoked on contract completion
31
send $N to Manager
// refund manager
32
def managerTimeOut():
33
for (i in range($N)):
34
send $1 to party[i]
35
}
Fig. 2.
Hawk program for a second-price sealed auction. Code described
in this paper is an approximation of our real implementation. In the public
contract, the syntax ‚Äúsend $N to P‚Äù corresponds to the following semantics
in our cryptographic formalism: ledger[P]
:=
ledger[P] + $N ‚Äì see
Section II-B.
‚Ä¢ Input independent privacy. Each user does not see others‚Äô
bids before committing to their own (even when they collude
with a potentially malicious manager). This way, users bids
are independent of others‚Äô bids.
‚Ä¢ Posterior privacy. As long as the manager does not disclose
information, users‚Äô bids are kept private from each other
(and from the public) even after the auction.
‚Ä¢ Financial fairness. Parties may attempt to prematurely abort
from the protocol to avoid payment or affect the redistribu-
tion of wealth. If a party aborts or the auction manager
aborts, the aborting party will be Ô¨Ånancially penalized
while the remaining parties receive compensation. As is
well-known in the cryptography literature, such fairness
guarantees are not attainable in general by off-chain only
protocols such as secure multi-party computation [7], [17].
As explained later, Hawk offers built-in mechanisms for
enforcing refunds of private bids after certain timeouts.
Hawk also allows the programmer to deÔ¨Åne additional rules,
as part of the Hawk contract, that govern Ô¨Ånancial fairness.
‚Ä¢ Security against a dishonest manager. We ensure authen-
ticity against a dishonest manager: besides aborting, a dis-
honest manager cannot affect the outcome of the auction
and the redistribution of money, even when it colludes with
a subset of the users. We stress that to ensure the above,
input independent privacy against a faulty manager is a
prerequisite. Moreover, if the manager aborts, it can be
Ô¨Ånancially penalized, and the participants obtain correspond-
ing remuneration.
An auction with the above security and privacy requirements
cannot be trivially implemented atop existing cryptocurrency
systems such as Ethereum [57] or Zerocash [11]. The former
allows for programmability but does not guarantee transac-
tional privacy, while the latter guarantees transactional privacy
but at the price of even reduced programmability than Bitcoin.
Aborting and timeouts. Aborting is dealt with using timeouts.
A Hawk program such as Figure 2 declares timeout parame-
ters using the HawkDeclareTimeouts special syntax. Three
timeouts are declared where T1 < T2 < T3:
T1 : The Hawk contract stops collecting bids after T1.
T2 : All users should have opened their bids to the manager
within T2; if a user submitted a bid but fails to open by T2,
its input bid is treated as 0 (and any other potential input
data treated as ‚ä•), such that the manager can continue.
T3 : If the manager aborts, users can reclaim their private bids
after time T3.
The public Hawk contract œÜpub can additionally implement
incentive structures. Our sealed auction program redistributes
the manager‚Äôs public deposit if it aborts. SpeciÔ¨Åcally, in our
sealed auction program, œÜpub deÔ¨Ånes two functions, namely
check and managerTimeOut. The check function will be in-
voked when the Hawk contract completes execution within T3,
i.e., manager did not abort. Otherwise, if the Hawk contract
does not complete execution within T3, the managerTimeOut
function will be invoked. We remark that although not explic-
itly written in the code, all Hawk contracts have an implicit
default entry point for accepting parties‚Äô deposits ‚Äì these
deposits are withheld by the contract till they are redistributed
by the contract. Bidders should check that the manager has
made a public deposit before submitting their bids.
Additional applications. Besides the sealed auction example,
Hawk supports various other applications. We give more
sample programs in Section VI-B.
C. Contributions
To the best of our knowledge, Hawk is the Ô¨Årst to simulta-
neously offer transactional privacy and programmability in a
decentralized cryptocurrency system.
Formal models for decentralized smart contracts. We are
among the Ô¨Årst ones to initiate a formal, academic treatment
of the blockchain model of cryptography. We present a formal,
Universal Composability (UC) model for the blockchain model
of cryptography ‚Äì this formal model is of independent interest,
841
841
Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA. Downloaded on July 16,2025 at 23:03:37 UTC from IEEE Xplore.  Restrictions apply. 
and can be useful in general for deÔ¨Åning and modeling the
security of protocols in the blockchain model. Our formal
model has also been adopted by the Gyges work [35] in
designing criminal smart contracts.
In deÔ¨Åning for formal blockchain model, we rely on a notion
called wrappers to modularize our protocol design and to sim-
plify presentation. Wrappers handle a set of common details
such as timers, pseudonyms, global ledgers in a centralized
place such that they need not be repeated in every protocol.
New cryptography suite. We implement a new cryptography
suite that binds private transactions with programmable logic.
Our protocol suite contains three essential primitives freeze,
compute, and finalize. The freeze primitive allows parties
to commit to not only normal data, but also coins. Committed
coins are frozen in the contract, and the payout distribution will
later be determined by the program œÜpriv. During compute,
parties open their committed data and currency to the manager,
such that the manager can compute the function œÜpriv. Based on
the outcome of œÜpriv, the manager now constructs new private
coins to be paid to each recipient. The manager then submits
to the blockchain both the new private coins as well as zero-
knowledge proofs of their well-formedness. At this moment,
the previously frozen coins are now redistributed among the
users. Our protocol suite strictly generalizes Zerocash since
Zerocash implements only private money transfers between
users without programmability.
We deÔ¨Åne the security of our primitives using ideal func-
tionalities, and formally prove security of our constructions
under a simulation-based paradigm.
Implementation and evaluation. We built a Hawk prototype
and evaluated its performance by implementing several ex-
ample applications, including a sealed-bid auction, a ‚Äúrock,
paper, scissors‚Äù game, a crowdfunding application, and a
swap Ô¨Ånancial instrument. We propose interesting protocol
optimizations that gained us a factor of 10√ó in performance
relative to a straightforward implementation. We show that
for at about 100 parties (e.g., auction and crowdfunding), the
manager‚Äôs cryptographic computation (the most expensive part
of the protocol) is under 2.85min using 4 cores, translating
to under $0.14 of EC2 time. Further, all on-chain computation
(performed by all miners) is very cheap, and under 20ms for
all cases. We will open source our Hawk framework in the
near future.
D. Background and Related Work
1) Background: The original Bitcoin offers limited pro-
grammability through a scripting language that is neither
Turing-complete nor user friendly. Numerous previous endeav-
ors at creating smart contract-like applications atop Bitcoin
(e.g., lottery [7], [17], micropayments [4],veriÔ¨Åable computa-
tion [40]) have demonstrated the difÔ¨Åculty of in retroÔ¨Åtting
Bitcoin‚Äôs scripting language ‚Äì this serves well to motivate a
Turing-complete, user-friendly smart contract language.
Ethereum is the Ô¨Årst Turing-complete decentralized smart
contract system. With Ethereum‚Äôs imminent launch, companies
and hobbyists are already building numerous smart contract
applications either atop Ethereum or by forking off Ethereum,
such as prediction markets [3], supply chain provenance [6],
crowd-based fundraising [1], and security and derivatives
trading [28].
Security of the blockchain. Like earlier works that design
smart contract applications for cryptocurrencies, we rely on the
underlying decentralized blockchain to be secure. Therefore,
we assume the blockchain‚Äôs consensus protocol attains security
when an adversary does not wield a large fraction of the com-
putational power. Existing cryptocurrencies are designed with
heuristic security. On one hand, researchers have identiÔ¨Åed
attacks on various aspects of the system
[29], [34]; on the
other, efforts to formally understand the security of blockchain
consensus have begun [32], [45].
Minimizing on-chain costs. Since every miner will execute
the smart contract programs while verifying each transaction,
cryptocurrencies including Bitcoin and Ethereum collect trans-
action fees that roughly correlate with the cost of execution.
While we do not explicitly model such fees, we design our
protocols to minimize on-chain costs by performing most of
the heavy-weight computation off-chain.
2) Additional Related Works: Leveraging blockchain for
Ô¨Ånancial fairness. A few prior works have explored how to
leverage the blockchain technology to achieve fairness in pro-
tocol design. For example, Bentov et al. [17], Andrychowicz
et al. [7], Kumaresan et al. [40], Kiayias et al. [36], as well
as Zyskind et al. [59], show how Bitcoin can be used to
ensure fairness in secure multi-party computation protocols.
These protocols also perform off-chain secure computation
of various types, but do not guarantee transactional privacy
(i.e., hiding the currency Ô¨Çows and amounts transacted). For
example, it is not clear how to implement our sealed auction
example using these earlier techniques. Second, these earlier
works either do not offer system implementations or provide
implementations only for speciÔ¨Åc applications (e.g., lottery). In
comparison, Hawk provides a generic platform such that non-
specialist programmers can easily develop privacy-preserving
smart contracts.
Smart contracts. The conceptual idea of programmable elec-
tronic ‚Äúsmart contracts‚Äù dates back nearly twenty years [53].
Besides recent decentralized cryptocurrencies, which guaran-
tee authenticity but not privacy, other smart contract imple-
mentations rely on trusted servers for security [46]. Our work
therefore comes closest to realizing the original vision of
parties interacting with a trustworthy ‚Äúvirtual computer‚Äù that
executes programs involving money and data.
Programming frameworks for cryptography. Several works
have developed programming frameworks that take in high-
level programs as speciÔ¨Åcations and generate cryptographic
implementations, including compilers for secure multi-party
computation [19], [39], [41], [51], authenticated data struc-
tures [44], and (zero-knowledge) proofs [12], [30], [31], [49].
Zheng et al. show how to generate secure distributed protocols
such as sealed auctions, battleship games, and banking applica-
tions [58]. These works support various notions of security, but
842
842
Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA. Downloaded on July 16,2025 at 23:03:37 UTC from IEEE Xplore.  Restrictions apply. 
none of them interact directly with money or leverage public
blockchains for ensuring Ô¨Ånancial fairness. Thus our work
is among the Ô¨Årst to combine the ‚Äúcorrect-by-construction‚Äù
cryptography approach with smart contracts.
Concurrent work. Our framework is the Ô¨Årst to provide a
full-Ô¨Çedged formal model for decentralized blockchains as
embodied by Bitcoin, Ethereum, and many other popular
decentralized cryptocurrencies. In concurrent and independent
work, Kiayias et al. [36] also propose a blockchain model
in the (Generalized) Universal Composability framework [23]
and use it to derive results that are similar to what we
describe in the online version [37], i.e., fair MPC with public
deposits. However, the ‚Äúprogrammability‚Äù of their formalism
is limited to their speciÔ¨Åc application (i.e., fair MPC with
public deposits). In comparison, our formalism is designed
with much broader goals, i.e., to facilitate protocol designers
to design a rich class of protocols in the blockchain model. In
particular, both our real-world wrapper (Figure 11) and ideal-
world wrapper (Figure 10) model the presence of arbitrary user
deÔ¨Åned contract programs, which interact with both parties and
the ledger. Our formalism has also been adopted by the Gyges
work [35] demonstrating its broad usefulness.
II. THE BLOCKCHAIN MODEL OF CRYPTOGRAPHY
A. The Blockchain Model
We begin by informally describing the trust model and
assumptions. We then propose a formal framework for the
‚Äúblockchain model of cryptography‚Äù for specifying and rea-
soning about the security of protocols.
In this paper, the blockchain refers to a decentralized set
of miners who run a secure consensus protocol to agree upon
the global state. We therefore will regard the blockchain as a
conceptual trusted party who is trusted for correctness and
availability, but not trusted for privacy. The blockchain
not only maintains a global ledger that stores the balance for
every pseudonym, but also executes user-deÔ¨Åned programs.
More speciÔ¨Åcally, we make the following assumptions:
‚Ä¢ Time. The blockchain is aware of a discrete clock that
increments in rounds. We use the terms rounds and epochs
interchangeably.
‚Ä¢ Public state. All parties can observe the state of the block-
chain. This means that all parties can observe the public
ledger on the blockchain, as well as the state of any user-
deÔ¨Åned blockchain program (part of a contract protocol).
‚Ä¢ Message delivery. Messages sent to the blockchain will
arrive at the beginning of the next round. A network
adversary may arbitrarily reorder messages that are sent
to the blockchain within the same round. This means that
the adversary may attempt a front-running attack (also
referred to as the rushing adversary by cryptographers), e.g.,
upon observing that an honest user is trading a stock, the
adversary preempts by sending a race transaction trading the
same stock. Our protocols should be proven secure despite
such adversarial message delivery schedules.
We assume that all parties have a reliable channel to the
blockchain, and the adversary cannot drop messages a party
sends to the blockchain. In reality, this means that the
overlay network must have sufÔ¨Åcient redundancy. However,
an adversary can drop messages delivered between parties
off the blockchain.
‚Ä¢ Pseudonyms. Users can make up an unbounded polynomial
number of pseudonyms when communicating with the
blockchain.
‚Ä¢ Correctness and availability. We assume that the blockchain
will perform any prescribed computation correctly. We also
assume that the blockchain is always available.
Advantages of a generic blockchain model. We adopt
a generic blockchain model where the blockchain can run
arbitrary Turing-complete programs. In comparison, previous
and concurrent works [7], [17], [40], [50] retroÔ¨Åt the artifacts
of Bitcoin‚Äôs limited and hard-to-use scripting language. In
Section VII and the online version [37], we present additional
theoretical results demonstrating that our generic blockchain
model yields asymptotically more efÔ¨Åcient cryptographic pro-
tocols.
B. Formally Modeling the Blockchain
Our paper adopts a carefully designed notational system
such that readers may understand our constructions without
understanding the precise details of our formal modeling.
We stress, however, that we give formal, precise speciÔ¨Å-
cations of both functionality and security, and our protocols
are formally proven secure under the Universal Composability
(UC) framework. In doing so, we make a separate contribution
of independent interest: we are the Ô¨Årst to propose a formal,
UC-based framework for describing and proving the security
of distributed protocols that interact with a blockchain ‚Äî
we refer to our formal model as ‚Äúthe blockchain model of
cryptography‚Äù.
Programs, wrappers, and functionalities. In the remainder
of the paper, we will describe ideal speciÔ¨Åcations, as well
as pieces of the protocol executed by the blockchain, the
users, and the manager respectively as programs written in
pseudocode. We refer to them as the ideal program (denoted
Ideal), the blockchain program (denoted B or Blockchain), and
the user/manager program (denoted UserP) respectively.
All of our pseudo-code style programs have precise mean-
ings in the UC framework. To ‚Äúcompile‚Äù a program to a
UC-style functionality or protocol, we apply a wrapper to
a program. SpeciÔ¨Åcally, we deÔ¨Åne the following types of
wrappers:
‚Ä¢ The ideal wrapper F(¬∑) transforms an ideal program IdealP
into a UC ideal functionality F(IdealP).
‚Ä¢ The blockchain wrapper G(¬∑) transforms a blockchain pro-
gram B to a blockchain functionality G(B). The blockchain
functionality G(B) models the program executing on the
blockchain.
‚Ä¢ The protocol wrapper Œ†(¬∑) transforms a user/manager
program UserP into a user-side or manager-side protocol
Œ†(UserP).
One important reason for having wrappers is that wrappers im-
plement a set of common features needed by every smart con-
843
843
Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA. Downloaded on July 16,2025 at 23:03:37 UTC from IEEE Xplore.  Restrictions apply. 
tract application, including time, public ledger, pseudonyms,
and adversarial reordering of messages ‚Äî in this way, we
need not repeat this notation for every blockchain application.
We defer our formal UC modeling to Appendix B. This will
not hinder the reader in understanding our protocols as long
as the reader intuitively understands our blockchain model and
assumptions described in Section II-A. Before we describe our
protocols, we deÔ¨Åne some notational conventions for writing
‚Äúprograms‚Äù. Readers who are interested in the details of our
formal model and proofs can refer to Appendix B.
C. Conventions for Writing Programs
Our wrapper-based system modularizes notation, and allows
us to use a set of simple conventions for writing user-deÔ¨Åned
ideal programs, blockchain programs, and user protocols. We
describe these conventions below.
Timer activation points. The ideal functionality wrapper
F(¬∑) and the blockchain wrapper G(¬∑) implement a clock that
advances in rounds. Every time the clock is advanced, the
wrappers will invoke the Timer activation point. Therefore,
by convention, we allow the ideal program or the blockchain
program can deÔ¨Åne a Timer activation point. Timeout oper-
ations (e.g., refunding money after a certain timeout) can be
implemented under the Timer activation point.
Delayed processing in ideal programs. When writing the
blockchain program, every message received by the blockchain
program is already delayed by a round due to the G(¬∑) wrapper.
When writing the ideal program, we introduce a simple
convention to denote delayed computation. Program instruc-
tions that are written in gray background denote computation
that does not take place immediately, but is deferred to
the beginning of the next timer click. This is a convenient
shorthand because in our real-world protocol, effectively any
computation done by a blockchain functionality will be de-
layed. For example, in our IdealPcash ideal program (see
Figure 3), whenever the ideal functionality receives a mint or
pour message, the ideal adversary S is notiÔ¨Åed immediately;
however, processing of the messages is deferred till the next
timer click. Formally, delayed processing can be implemented
simply by storing state and invoking the delayed program in-
structions on the next Timer click. By convention, we assume
that the delayed instructions are invoked at the beginning of
the Timer call. In other words, upon the next timer click, the
delayed instructions are executed Ô¨Årst.
Pseudonymity. All party identiÔ¨Åers that appear in ideal
programs, blockchain programs, and user-side programs by
default refer to pseudonyms. When we write ‚Äúupon receiving
message from some P‚Äù, this accepts a message from any
pseudonym. Whenever we write ‚Äúupon receiving message
from P‚Äù, without the keyword some, this accepts a message
from a Ô¨Åxed pseudonym P, and typically which pseudonym
we refer to is clear from the context.
Whenever we write ‚Äúsend m to G(B) as nym P‚Äù inside a
user program, this sends an internal message (‚Äúsend‚Äù, m, P)
to the protocol wrapper Œ†. The protocol wrapper will then
authenticate the message appropriately under pseudonym P.
IdealPcash
Init:
Coins: a multiset of coins, each of the form (P, $val)
Mint:
Upon receiving (mint, $val) from some P:
send (mint, P, $val) to A
assert ledger[P] ‚â•$val
ledger[P] := ledger[P] ‚àí$val
append (P, $val) to Coins
Pour:
On (pour, $val1, $val2, P1, P2, $val‚Ä≤
1, $val‚Ä≤
2) from P:
assert $val1 + $val2 = $val‚Ä≤
1 + $val‚Ä≤
2
if P is honest,
assert (P, $vali) ‚ààCoins for i ‚àà{1, 2}
assert Pi Ã∏= ‚ä•for i ‚àà{1, 2}
remove one (P, $vali) from Coins for i ‚àà{1, 2}
for i ‚àà{1, 2}, if Pi is corrupted, send (pour, i,
Pi, $val‚Ä≤
i) to A; else send (pour, i, Pi) to A
if P is corrupted:
assert (P, $vali) ‚ààCoins for i ‚àà{1, 2}
remove one (P, $vali) from Coins for i ‚àà{1, 2}
for i ‚àà{1, 2}: add (Pi, $val‚Ä≤
i) to Coins
for i ‚àà{1, 2}: if Pi Ã∏= ‚ä•, send (pour, $val‚Ä≤
i) to Pi
Fig. 3. DeÔ¨Ånition of IdealPcash. Notation: ledger denotes the public ledger,
and Coins denotes the private pool of coins. As mentioned in Section II-C,
gray background denotes batched and delayed activation. All party names
correspond to pseudonyms due to notations and conventions deÔ¨Åned in
Section II-B.
When the context is clear, we avoid writing ‚Äúas nym P‚Äù,
and simply write ‚Äúsend m to G(B)‚Äù. Our formal system also
allows users to send messages anonymously to the blockchain
‚Äì although this option will not be used in this paper.
Ledger and money transfers. A public ledger is denoted
ledger in our ideal programs and blockchain programs. When a
party sends $amt to an ideal program or a blockchain program,
this represents an ordinary message transmission. Money
transfers only take place when ideal programs or blockchain
programs update the public ledger ledger. In other words,
the symbol $ is only adopted for readability (to distinguish
variables associated with money and other variables), and does
not have special meaning or signiÔ¨Åcance. One can simply think
of this variable as having the money type.
III. CRYPTOGRAPHY ABSTRACTIONS
We now describe our cryptography abstraction in the form
of ideal programs. Ideal programs deÔ¨Åne the correctness and
security requirements we wish to attain by writing a speci-
Ô¨Åcation assuming the existence of a fully trusted party. We
will later prove that our real-world protocols (based on smart
contracts) securely emulate the ideal programs. As mentioned
earlier, an ideal program must be combined with a wrapper F
to be endowed with exact execution semantics.
Overview. Hawk realizes the following speciÔ¨Åcations:
‚Ä¢ Private ledger and currency transfer. Hawk relies on the
existence of a private ledger that supports private currency
transfers. We therefore Ô¨Årst deÔ¨Åne an ideal functionality
called IdealPcash that describes the requirements of a private
ledger (see Figure 3). Informally speaking, earlier works
such as Zerocash [11] are meant to realize (approximations
844
844
Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA. Downloaded on July 16,2025 at 23:03:37 UTC from IEEE Xplore.  Restrictions apply. 
of) this ideal functionality ‚Äì although technically this ought
to be interpreted with the caveat that these earlier works
prove indistinguishability or game-based security instead
UC-based simulation security.
‚Ä¢ Hawk-speciÔ¨Åc primitives. With a private ledger speciÔ¨Åed,
we then deÔ¨Åne Hawk-speciÔ¨Åc primitives including freeze,
compute, and Ô¨Ånalize that are essential for enabling trans-
actional privacy and programmability simultaneously.
A. Private Cash SpeciÔ¨Åcation IdealPcash
At a high-level, the IdealPcash speciÔ¨Åes the requirements of a
private ledger and currency transfer. We adopt the same ‚Äúmint‚Äù
and ‚Äúpour‚Äù terminology from Zerocash [11].
Mint. The mint operation allows a user P to transfer money
from the public ledger denoted ledger to the private pool
denoted Coins[P]. With each transfer, a private coin for user
P is created, and associated with a value val.
For correctness, the ideal program IdealPcash checks that
the user P has sufÔ¨Åcient funds in its public ledger ledger[P]
before creating the private coin.
Pour. The pour operation allows a user P to spend money
in its private bank privately. For simplicity, we deÔ¨Åne the
simple case with two input coins and two output coins. This
is sufÔ¨Åcient for users to transfer any amount of money by
‚Äúmaking change,‚Äù although it would be straightforward to
support more efÔ¨Åcient batch operations as well.
For correctness, the ideal program IdealPcash checks the
following: 1) for the two input coins, party P indeed possesses
private coins of the declared values; and 2) the two input coins
sum up to equal value as the two output coins, i.e., coins
neither get created or vanish.
Privacy. When an honest party P mints, the ideal-world
adversary A learns the pair (P, val) ‚Äì since minting is raising
coins from the public pool to the private pool. Operations on
the public pool are observable by A.
When an honest party P pours, however, the adversary A
learns only the output pseudonyms P1 and P2. It does not learn
which coin in the private pool Coins is being spent nor the
name of the spender. Therefore, the spent coins are anonymous
with respect to the private pool Coins. To get strong anonymity,
new pseudonyms P1 and P2 can be generated on the Ô¨Çy to
receive each pour. We stress that as long as pour hides the
sender, this ‚Äúbreaks‚Äù the transaction graph, thus preventing
linking analysis.
If a corrupted party is the recipient of a pour, the adversary
additionally learns the value of the coin it receives.
Additional subtleties. Later in our protocol, honest parties
keep track of a wallet of coins. Whenever an honest party
pours, it Ô¨Årst checks if an appropriate coin exists in its local
wallet ‚Äì and if so it immediately removes the coin from the
wallet (i.e., without delay). In this way, if an honest party
makes multiple pour transactions in one round, it will always
choose distinct coins for each pour transaction. Therefore, in
our IdealPcash functionality, honest pourers‚Äô coins are immedi-
ately removed from Coins. Further, an honest party is not able
to spend a coin paid to itself until the next round. By contrast,
corrupted parties are allowed to spend coins paid to them in
the same round ‚Äì this is due to the fact that any message is
routed immediately to the adversary, and the adversary can
also choose a permutation for all messages received by the
blockchain in the same round (see Section II and Appendix B).
Another subtlety in the IdealPcash functionality is while hon-
est parties always pour to existing pseudonyms, the function-
ality allows the adversary to pour to non-existing pseudonyms
denoted ‚ä•‚Äî in this case, effectively the private coin goes
into a blackhole and cannot be retrieved. This enables a
performance optimization in our UserPcash and Blockchaincash
protocol later ‚Äì where we avoid including the cti‚Äôs in the NIZK
of LPOUR (see Section IV). If a malicious pourer chooses to
compute the wrong cti, it is as if the recipient Pi did not
receive the pour, i.e., the pour is made to ‚ä•.
B. Hawk SpeciÔ¨Åcation IdealPhawk
To enable transactional privacy and programmability simul-
taneously, we now describe the speciÔ¨Åcations of new Hawk
primitives, including freeze, compute, and Ô¨Ånalize. The formal
speciÔ¨Åcation of the ideal program IdealPhawk is provided in
Figure 4. Below, we provide some explanations. We also refer
the reader to Section I-C for higher-level explanations.
Freeze. In freeze, a party tells IdealPhawk to remove one
coin from the private coins pool Coins, and freeze it in the
blockchain by adding it to FrozenCoins. The party‚Äôs private
input denoted in is also recorded in FrozenCoins. IdealPhawk
checks that P has not called freeze earlier, and that a coin
(P, val) exists in Coins before proceeding with the freeze.
Compute. When a party P calls compute, its private input
in and the value of its frozen coin val are disclosed to the
manager PM.
Finalize. In finalize, the manager PM submits a public
input inM to IdealPhawk. IdealPhawk now computes the outcome
of œÜpriv on all parties‚Äô inputs and frozen coin values, and
redistributes the FrozenCoins based on the outcome of œÜpriv.
To ensure money conservation, the ideal program IdealPhawk
checks that the sum of frozen coins is equal to the sum of
output coins.
Interaction with public contract. The IdealPhawk functional-
ity is parameterized by a public Hawk contract œÜpub, which is
included in IdealPhawk as a sub-module.
During a finalize,
IdealPhawk calls œÜpub.check. The public contract œÜpub typically
serves the following purposes:
‚Ä¢ Check the well-formedness of the manager‚Äôs input inM.
For example, in our Ô¨Ånancial derivatives application (Sec-
tion VI-B), the public contract œÜpub asserts that the input
corresponds to the price of a stock as reported by the stock
exchange‚Äôs authentic data feed.
‚Ä¢ Redistribute public deposits. If parties or the manager have
aborted, or if a party has provided invalid input (e.g., less
than a minimum bet) the public contract œÜpub can now
redistribute the parties‚Äô public deposits to ensure Ô¨Ånancial
845
845
Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA. Downloaded on July 16,2025 at 23:03:37 UTC from IEEE Xplore.  Restrictions apply. 
IdealPhawk(PM, {Pi}i‚àà[N], T1, T2, œÜpriv, œÜpub)
Init: Call IdealPcash.Init. Additionally:
FrozenCoins:
a
set
of
coins
and
private
in-
puts received by this contract, each of the form
(P, in, $val). Initialize FrozenCoins := ‚àÖ.
Freeze: Upon receiving (freeze, $vali, ini) from Pi for some
i ‚àà[N]:
assert current time T < T1
assert Pi has not called freeze earlier.
assert at least one copy of (Pi, $vali) ‚ààCoins
send (freeze, Pi) to A
add (Pi, $vali, ini) to FrozenCoins
remove one (Pi, $vali) from Coins
Compute: Upon receiving compute from Pi for some i ‚àà[N]:
assert current time T1 ‚â§T < T2
if PM is corrupted, send (compute, Pi, $vali, ini)
to A
else send (compute, Pi) to A
let (Pi, $vali, ini) be the item in FrozenCoins
corresponding to Pi
send (compute, Pi, $vali, ini) to PM
Finalize: Upon receiving (finalize, inM, out) from PM:
assert current time T ‚â•T2
assert PM has not called finalize earlier
for i ‚àà[N]:
let ($vali, ini) := (0, ‚ä•) if Pi has not called
compute
({$val‚Ä≤
i}, out‚Ä†) := œÜpriv({$vali, ini}, inM)
assert out‚Ä† = out
assert 
i‚àà[N] $vali = 
i‚àà[N] $val‚Ä≤
i
send (finalize, inM, out) to A
for each corrupted Pi that called compute: send (Pi,
$val‚Ä≤
i) to A
call œÜpub.check(inM, out)
for i ‚àà[N] such that Pi called compute:
add (Pi, $val‚Ä≤
i) to Coins
send (finalize, $val‚Ä≤
i) to Pi
œÜpub: Run a local instance of public contract œÜpub. Messages
between the adversary to œÜpub, and from œÜpub to parties
are forwarded directly.
Upon receiving message (pub, m) from party P:
notify A of (pub, m)
send m to œÜpub on behalf of P
IdealPcash: include IdealPcash (Figure 3).
Fig. 4. DeÔ¨Ånition of IdealPhawk. Notations: FrozenCoins denotes frozen coins
owned by the contract; Coins denotes the global private coin pool deÔ¨Åned by
IdealPcash; and (ini, vali) denotes the input data and frozen coin value of
party Pi.
fairness. For example, in our ‚ÄúRock, Paper, Scissors‚Äù exam-
ple (see Section VI-B), the private contract œÜpriv checks if
each party has frozen the minimal bet. If not, œÜpriv includes
that information in out so that œÜpub pays that party‚Äôs public
deposit to others.
Security and privacy requirements. The IdealPhawk speciÔ¨Åes
the following privacy guarantees. When an honest party P
freezes money (e.g., a bid), the adversary should not observe
the amount frozen. However, the adversary can observe the
party‚Äôs pseudonym P. We note that leaking the pseudonym P
does not hurt privacy, since a party can simply create a new
pseudonym P and pour to this new pseudonym immediately
before the freeze.
When an honest party calls compute, the manager PM gets
to observe its input and frozen coin‚Äôs value. However, the
public and other contractual parties do not observe anything
(unless the manager voluntarily discloses information).
Finally, during a finalize operation, the output out is
declassiÔ¨Åed to the public ‚Äì note that out can be empty if we
do not wish to declassify any information to the public.
It is not hard to see that our ideal program IdealPhawk
satisÔ¨Åes input independent privacy and authenticity against a
dishonest manager. Further, it satisÔ¨Åes posterior privacy as
long as the manager does not voluntarily disclose information.
Intuitive explanations of these security/privacy properties were
provided in Section I-B.
Timing and aborts. Our ideal program IdealPhawk requires
that freeze operations be done by time T1, and that compute
operations be done by time T2. If a user froze coins but did
not open by time T2, our ideal program IdealPhawk treats
(ini, vali) := (0, ‚ä•), and the user Pi essentially forfeits
its frozen coins. Managerial aborts is not handled inside
IdealPhawk, but by the public portion of the contract.
Simplifying assumptions. For clarity, our basic version of
IdealPhawk is a stripped down version of our implementation.
SpeciÔ¨Åcally, our basic IdealPhawk and protocols do not realize
refunds of frozen coins upon managerial abort. As mentioned
in Section IV-C, it is not hard to extend our protocols to
support such refunds.
Other simplifying assumptions we made include the follow-
ing. Our basic IdealPhawk assumes that the set of pseudonyms
participating in the contract as well as timeouts T1 and T2 are
hard-coded in the program. This can also be easily relaxed as
mentioned in Section IV-C.
IV. CRYPTOGRAPHIC PROTOCOLS
Our protocols are broken down into two parts: 1) the private
cash part that implements direct money transfers between
users; and 2) the Hawk-speciÔ¨Åc part that binds transactional
privacy with programmable logic. The formal protocol descrip-
tions are given in Figures 5 and 6. Below we explain the high-
level intuition.
A. Warmup: Private Cash and Money Transfers
Our construction adopts a Zerocash-like protocol for im-
plementing private cash and private currency transfers. For
completeness, we give a brief explanation below, and we
mainly focus on the pour operation which is technically more
interesting. The blockchain program Blockchaincash maintains
a set Coins of private coins. Each private coin is of the format
(P, coin := Comms($val))
where P denotes a party‚Äôs pseudonym, and coin commits to
the coin‚Äôs value $val under randomness s.
846
846
Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA. Downloaded on July 16,2025 at 23:03:37 UTC from IEEE Xplore.  Restrictions apply. 
Blockchaincash
Init:
crs: a reference string for the underlying NIZK system
Coins: a set of coin commitments, initially ‚àÖ
SpentCoins: set of spent serial numbers, initially ‚àÖ
Mint: Upon receiving (mint, $val, s) from some party P,
coin := Comms($val)
assert (P, coin) /‚ààCoins
assert ledger[P] ‚â•$val
ledger[P] := ledger[P] ‚àí$val
add (P, coin) to Coins
Pour: Anonymous receive (pour, œÄ, {sni, Pi, coini, cti}i‚àà{1,2}})
let MT be a merkle tree built over Coins
statement := (MT.root, {sni, Pi, coini}i‚àà{1,2})
assert NIZK.Verify(LPOUR, œÄ, statement)
for i ‚àà{1, 2},
assert sni /‚ààSpentCoins
assert (Pi, coini) /‚ààCoins
add sni to SpentCoins
add (Pi, coini) to Coins
send (pour, coini, cti) to Pi,
Relation (statement, witness) ‚ààLPOUR is deÔ¨Åned as:
parse statement as (MT.root, {sni, Pi, coin‚Ä≤
i}i‚àà{1,2})
parse witness as (P, skprf, {branchi, si, $vali, s‚Ä≤
i, ri, $val‚Ä≤
i})
assert P.pkprf = PRFskprf(0)
assert $val1 + $val2 = $val‚Ä≤
1 + $val‚Ä≤
2
for i ‚àà{1, 2},
coini := Commsi($vali)
assert MerkleBranch(MT.root, branchi, (P‚à•coini))
assert sni = PRFskprf(P‚à•coini)
assert coin‚Ä≤
i = Comms‚Ä≤
i($val‚Ä≤
i)
Protocol UserPcash
Init:
Wallet: stores P‚Äôs spendable coins, initially ‚àÖ
GenNym:
sample a random seed skprf
pkprf := PRFskprf(0)
return pkprf
Mint: On input (mint, $val),
sample a commitment randomness s
coin := Comms($val)
store (s, $val, coin) in Wallet
send (mint, $val, s) to G(Blockchaincash)
Pour (as sender): On input (pour, $val1, $val2, P1, P2, $val‚Ä≤
1,
$val‚Ä≤
2),
assert $val1 + $val2 = $val‚Ä≤
1 + $val‚Ä≤
2
for i ‚àà{1, 2}, assert (si, $vali, coini) ‚ààWallet for some
(si, coini)
let MT be a merkle tree over Blockchaincash.Coins
for i ‚àà{1, 2}:
remove one (si, $vali, coini) from Wallet
sni := PRFskprf(P‚à•coini)
let branchi be the branch of (P, coini) in MT
sample randomness s‚Ä≤
i, ri
coin‚Ä≤
i := Comms‚Ä≤
i($val‚Ä≤
i)
cti := ENC(Pi.epk, ri, $val‚Ä≤
i‚à•s‚Ä≤
i)
statement := (MT.root, {sni, Pi, coin‚Ä≤
i}i‚àà{1,2})
witness := (P, skprf, {branchi, si, $vali, s‚Ä≤
i, ri, $val‚Ä≤
i})
œÄ := NIZK.Prove(LPOUR, statement, witness)
AnonSend(pour, œÄ, {sni, Pi, coin‚Ä≤
i, cti}i‚àà{1,2})
to G(Blockchaincash)
Pour
(as
recipient):
On
receive
(pour, coin, ct)
from
G(Blockchaincash):
let ($val‚à•s) := DEC(esk, ct)
assert Comms($val) = coin
store (s, $val, coin) in Wallet
output (pour, $val)
Fig. 5. UserPcash construction. A trusted setup phase generates the NIZK‚Äôs common reference string crs. For notational convenience, we omit writing the
crs explicitly in the construction. The Merkle tree MT is stored on the blockchain and not computed on the Ô¨Çy ‚Äì we omit stating this in the protocol for
notational simplicity. The protocol wrapper Œ†(¬∑) invokes GenNym whenever a party creates a new pseudonym.
During a pour operation, the spender P chooses two coins
in Coins to spend, denoted (P, coin1) and (P, coin2) where
coini := Commsi($vali) for i ‚àà{1, 2}. The pour operation
pays val‚Ä≤
1 and val‚Ä≤
2 amount to two output pseudonyms denoted
P1 and P2 respectively, such that val1 + val2 = val‚Ä≤
1 + val‚Ä≤
2.
The spender chooses new randomness s‚Ä≤
i for i ‚àà{1, 2}, and
computes the output coins as

Pi, coini := Comms‚Ä≤
i($val‚Ä≤
i)

The spender gives the values s‚Ä≤
i and val‚Ä≤
i to the recipient Pi
for Pi to be able to spend the coins later.
Now, the spender computes a zero-knowledge proof to show
that the output coins are constructed appropriately, where
correctness compasses the following aspects:
‚Ä¢ Existence of coins being spent. The coins being spent
(P, coin1) and (P, coin2) are indeed part of the private pool
Coins. We remark that here the zero-knowledge property
allows the spender to hide which coins it is spending ‚Äì this
is the key idea behind transactional privacy.
To prove this efÔ¨Åciently, Blockchaincash maintains a Merkle
tree MT over the private pool Coins. Membership in the set
can be demonstrated by a Merkle branch consistent with the
root hash, and this is done in zero-knowledge.
‚Ä¢ No double spending. Each coin (P, coin) has a cryptograph-
ically unique serial number sn that can be computed as
a pseudorandom function of P‚Äôs secret key and coin. To
pour a coin, its serial number sn must be disclosed, and a
zero-knowledge proof given to show the correctness of sn.
Blockchaincash checks that no sn is used twice.
‚Ä¢ Money conservation. The zero-knowledge proof also attests
to the fact that the input coins and the output coins have
equal total value.
We make some remarks about the security of the scheme.
Intuitively, when an honest party pours to an honest party,
the adversary A does not learn the values of the output
coins assuming that the commitment scheme Comm is hiding,
and the NIZK scheme we employ is computational zero-
knowledge. The adversary A can observe the nyms that receive
the two output coins. However, as we remarked earlier, since
these nyms can be one-time, leaking them to the adversary
would be okay. Essentially we only need to break linkability
at spend time to ensure transactional privacy.
847
847
Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA. Downloaded on July 16,2025 at 23:03:37 UTC from IEEE Xplore.  Restrictions apply. 
Blockchainhawk(PM, {Pi}i‚àà[N], T1, T2, œÜpriv, œÜpub)
Init: See IdealPhawk for description of parameters
Call Blockchaincash.Init.
Freeze: Upon receiving (freeze, œÄ, sni, cmi) from Pi:
assert current time T ‚â§T1
assert this is the Ô¨Årst freeze from Pi
let MT be a merkle tree built over Coins
assert sni /‚ààSpentCoins
statement := (Pi, MT.root, sni, cmi)
assert NIZK.Verify(LFREEZE, œÄ, statement)
add sni to SpentCoins and store cmi for later
Compute: Upon receiving (compute, œÄ, ct) from Pi:
assert T1 ‚â§T < T2 for current time T
assert NIZK.Verify(LCOMPUTE, œÄ, (PM, cmi, ct))
send (compute, Pi, ct) to PM
Finalize: On receiving (finalize, œÄ, inM, out, {coin‚Ä≤
i, cti}i‚àà[N])
from PM:
assert current time T ‚â•T2
for every Pi that has not called compute, set cmi := ‚ä•
statement := (inM, out, {cmi, coin‚Ä≤
i, cti}i‚àà[N])
assert NIZK.Verify(LFINALIZE, œÄ, statement)
for i ‚àà[N]:
assert coin‚Ä≤
i /‚ààCoins
add coin‚Ä≤
i to Coins
send (finalize, coin‚Ä≤
i, cti) to Pi
Call œÜpub.check(inM, out)
Blockchaincash: include Blockchaincash
œÜpub : include user-deÔ¨Åned public contract œÜpub
Relation (statement, witness) ‚ààLFREEZE is deÔ¨Åned as:
parse statement as (P, MT.root, sn, cm)
parse witness as (coin, skprf, branch, s, $val, in, k, s‚Ä≤)
coin := Comms($val)
assert MerkleBranch(MT.root, branch, (P‚à•coin))
assert P.pkprf = skprf(0)
assert sn = PRFskprf(P‚à•coin)
assert cm = Comms‚Ä≤($val‚à•in‚à•k)
Relation (statement, witness) ‚ààLCOMPUTE is deÔ¨Åned as:
parse statement as (PM, cm, ct)
parse witness as ($val, in, k, s‚Ä≤, r)
assert cm = Comms‚Ä≤($val‚à•in‚à•k)
assert ct = ENC(PM.epk, r, ($val‚à•in‚à•k‚à•s‚Ä≤))
Relation (statement, witness) ‚ààLFINALIZE is deÔ¨Åned as:
parse statement as (inM, out, {cmi, coin‚Ä≤
i, cti}i‚àà[N])
parse witness as {si, $vali, ini, s‚Ä≤
i, ki}i‚àà[N]
({$val‚Ä≤
i}i‚àà[N], out) := œÜpriv({$vali, ini}i‚àà[N], inM)
assert 
i‚àà[N] $vali = 
i‚àà[N] $val‚Ä≤
i
for i ‚àà[N]:
assert cmi = Commsi($vali‚à•ini‚à•ki))
‚à®($vali, ini, ki, si, cmi) = (0, ‚ä•, ‚ä•, ‚ä•, ‚ä•)
assert cti = SENCki(s‚Ä≤
i‚à•$val‚Ä≤
i)
assert coin‚Ä≤
i = Comms‚Ä≤
i($val‚Ä≤
i)
Protocol UserPhawk(PM, {Pi}i‚àà[N], T1, T2, œÜpriv, œÜpub)
Init: Call UserPcash.Init.
Protocol for a party P ‚àà{Pi}i‚àà[N]:
Freeze: On input (freeze, $val, in) as party P:
assert current time T < T1
assert this is the Ô¨Årst freeze input
let MT be a merkle tree over Blockchaincash.Coins
assert that some entry (s, $val, coin) ‚ààWallet for some
(s, coin)
remove one (s, $val, coin) from Wallet
sn := PRFskprf(P‚à•coin)
let branch be the branch of (P, coin) in MT
sample a symmetric encryption key k
sample a commitment randomness s‚Ä≤
cm := Comms‚Ä≤($val‚à•in‚à•k)
statement := (P, MT.root, sn, cm)
witness := (coin, skprf, branch, s, $val, in, k, s‚Ä≤)
œÄ := NIZK.Prove(LFREEZE, statement, witness)
send (freeze, œÄ, sn, cm) to G(Blockchainhawk)
store in, cm, $val, s‚Ä≤, and k to use later (in compute)
Compute: On input (compute) as party P:
assert current time T1 ‚â§T < T2
sample encryption randomness r
ct := ENC(PM.epk, r, ($val‚à•in‚à•k‚à•s‚Ä≤))
œÄ := NIZK.Prove((PM, cm, ct), ($val, in, k, s‚Ä≤, r))
send (compute, œÄ, ct) to G(Blockchainhawk)
Finalize: Receive (finalize, coin, ct) from G(Blockchainhawk):
decrypt (s‚à•$val) := SDECk(ct)
store (s, $val, coin) in Wallet
output (finalize, $val)
Protocol for manager PM:
Compute: On receive (compute, Pi, ct) from G(Blockchainhawk):
decrypt and store ($vali‚à•ini‚à•ki‚à•si) := DEC(esk, ct)
store cmi := Commsi($vali‚à•ini‚à•ki)
output (Pi, $vali, ini)
If this is the last compute received:
for i ‚àà[N] such that Pi has not called compute,
($vali, ini, ki, si, cmi) := (0, ‚ä•, ‚ä•, ‚ä•, ‚ä•)
({$val‚Ä≤
i}i‚àà[N], out) := œÜpriv({$vali, ini}i‚àà[N], inM)
store and output ({$val‚Ä≤
i}i‚àà[N], out)
Finalize: On input (finalize, inM, out):
assert current time T ‚â•T2
for i ‚àà[N]:
sample a commitment randomness s‚Ä≤
i
coin‚Ä≤
i := Comms‚Ä≤
i($val‚Ä≤
i)
cti := SENCki(s‚Ä≤
i‚à•$val‚Ä≤
i)
statement := (inM, out, {cmi, coin‚Ä≤
i, cti}i‚àà[N])
witness := {si, $vali, ini, s‚Ä≤
i, ki}i‚àà[N]
œÄ := NIZK.Prove(statement, witness)
send (finalize, œÄ, inM, out, {coin‚Ä≤
i, cti})
to G(Blockchainhawk)
UserPcash: include UserPcash.
Fig. 6. Blockchainhawk and UserPhawk construction.
848
848
Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA. Downloaded on July 16,2025 at 23:03:37 UTC from IEEE Xplore.  Restrictions apply. 
When a corrupted party P‚àópours to an honest party P, even
though the adversary knows the opening of the coin, it cannot
spend the coin (P, coin) once the transaction takes effect by
the Blockchaincash, since P‚àócannot demonstrate knowledge
of P‚Äôs secret key. We stress that since the contract binds the
owner‚Äôs nym P to the coin, only the owner can spend it even
when the opening of coin is disclosed.
Technical subtleties. Our Blockchaincash uses a modiÔ¨Åed ver-
sion of Zerocash to achieve stronger security in the simulation
paradigm. In comparison, Zerocash adopts a strictly weaker,
indistinguishability-based privacy notion called ledger indis-
tinguishability. In multi-party protocols, indistinguishability-
based security notions are strictly weaker than simulation
security. Not only so, the particular ledger indistinguishability
notion adopted by Zerocash [11] appears subtly questionable
upon scrutiny, which we elaborate on in the online ver-
sion [37]. This does not imply that the Zerocash construction
is necessarily insecure ‚Äì however, there is no obvious path
to proving their scheme secure under a simulation based
paradigm.
B. Binding Privacy and Programmable Logic
So far, Blockchaincash, similar to Zerocash [11], only sup-
ports direct money transfers between users. We allow transac-
tional privacy and programmable logic simutaneously.
Freeze. We support a new operation called freeze, that does
not spend directly to a user, but commits the money as well
as an accompanying private input to a smart contract. This is
done using a pour-like protocol:
‚Ä¢ The user P chooses a private coin (P, coin) ‚ààCoins, where
coin := Comms($val). Using its secret key, P computes the
serial number sn for coin ‚Äì to be disclosed with the freeze
operation to prevent double-spending.
‚Ä¢ The user P computes a commitment (val||in||k) to the
contract where in denotes its input, and k is a symmetric
encryption key that is introduced due to a practical opti-
mization explained later in Section V.
‚Ä¢ The user P now makes a zero-knowledge proof attesting to
similar statements as in a pour operation, i.e., that the spent
coin exists in the pool Coins, the sn is correctly constructed,
and that the val committed to the contract equals the value
of the coin being spent. See LFREEZE in Figure 6 for details
of the NP statement being proven.
Compute. Next, computation takes place off-chain to compute
the payout distribution {val‚Ä≤
i}i‚àà[n] and a proof of correctness.
In Hawk, we rely on a minimally trusted manager PM to
perform computation. All parties would open their inputs to
the manager PM, and this is done by encrypting the opening
to the manager‚Äôs public key:
ct := ENC(PM.epk, r, ($val‚à•in‚à•k‚à•s‚Ä≤))
The ciphertext ct is submitted to the smart contract along with
appropriate zero-knowledge proofs of correctness. While the
user can also directly send the opening to the manager off-
chain, passing the ciphertext ct through the smart contract
would make any aborts evident such that the contract can
Ô¨Ånancially punish an aborting user.
After obtaining the openings, the manager now computes
the payout distribution {val‚Ä≤
i}i‚àà[n] and public output out by
applying the private contract œÜpriv. The manager also constructs
a zero-knowledge proof attesting to the outcomes.
Finalize. When the manager submits the outcome of œÜpriv
and a zero-knowledge proof of correctness to Blockchainhawk,
Blockchainhawk veriÔ¨Åes the proof and redistributes the frozen
money accordingly. Here Blockchainhawk also passes the man-
ager‚Äôs public input inM and public output out to the public
Hawk contract œÜpub. The public contract œÜpub can be invoked
to check the validity of the manager‚Äôs input, as well as
redistribute public collateral deposit.
Theorem 1. Assuming that the hash function in the Merkle
tree is collision resistant, the commitment scheme Comm
is perfectly binding and computationally hiding, the NIZK
scheme is computationally zero-knowledge and simulation
sound extractable, the encryption schemes ENC and SENC
are perfectly correct and semantically secure, the PRF scheme
PRF is secure, then, our protocols in Figures 5 and 6 securely
emulates the ideal functionality F(IdealPhawk) against a ma-
licious adversary in the static corruption model.
Proof. Deferred to our online version [37].
C. Extensions and Discussions
Refunding frozen coins to users.
In our implementation,
we extend our basic scheme to allow the users to reclaim
their frozen money after a timeout T3 > T2. To achieve this,
user P simply sends the contract a newly constructed coin
(P, coin := Comms($val)) and proves in zero-knowledge that
its value $val is equal to that of the frozen coin. In this case,
the user can identify the previously frozen coin in the clear,
i.e., there is no need to compute a zero-knowledge proof of
membership within the frozen pool as is needed in a pour
transaction.
Instantiating the manager with trusted hardware. In some
applications, it may be a good idea to instantiate the manager
using trusted hardware such as the emerging Intel SGX. In this
case, the off-chain computation can take place in a secret SGX
enclave that is not visible to any untrusted software or users.
Alternatively, in principle, the manager role can also be split
into two or more parties that jointly run a secure computation
protocol ‚Äì although this approach is likely to incur higher
overhead.
We stress that our model is fundamentally different from
placing full trust in any centralized node. Trusted hardware
cannot serve as a replacement of the blockchain. Any off-
chain only protocol that does not interact with the blockchain
cannot offer Ô¨Ånancial fairness in the presence of aborts ‚Äì even
when trusted hardware is employed.
Furthermore, even the use of SGX does not obviate the need
for our cryptographic protocol. If the SGX is trusted only by
a subset of parties (e.g., just the parties to a particular private
contact), rather than globally, then those users can beneÔ¨Åt from
849
849
Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA. Downloaded on July 16,2025 at 23:03:37 UTC from IEEE Xplore.  Restrictions apply. 
the efÔ¨Åciency of an SGX-managed private contract, while still
utilizing the more widely trusted underlying currency.
Pouring anonymously to long-lived pseudonyms. In our
basic formalism of IdealPcash, the pour operation discloses
the recipient‚Äôs pseudonyms to the adversary. This means that
IdealPcash only retains full privacy if the recipient generates
a fresh, new pseudonym every time. In comparison, Zero-
cash [11] provides an option of anonymously spending to a
long-lived pseudonym (in other words, having IdealPcash not
reveal recipients‚Äô pseudonyms to the adversary).
It would be straightforward to add this feature to Hawk as
well (at the cost of a constant factor blowup in performance);
however, in most applications (e.g., a payment made after
receiving an invoice), the transfer is subsequent to some
interaction between the recipient and sender.
Open enrollment of pseudonyms. In our current formalism,
parties‚Äô pseudonyms are hardcoded and known a priori. We can
easily relax this to allow open enrollment of any pseudonym
that joins the contract (e.g., in an auction). Our implementation
supports open enrollment. Due to SNARK‚Äôs preprocessing,
right now, each contract instance must declare an upper-
bound on the number of participants. An enrollment fee
can potentially be adopted to prevent a DoS attack where
the attacker joins the contract with many pseudonyms thus
preventing legitimate users from joining. How to choose the
correct fee amount to achieve incentive compatibility is left as
an open research challenge. The a priori upper bound on the
number of participants can be avoided if we adopt recursively
composable SNARKs [18], [25] or alternative proofs that do
not require circuit-dependent setup [16].
V. ADOPTING SNARKS IN UC PROTOCOLS AND
PRACTICAL OPTIMIZATIONS
A. Using SNARKs in UC Protocols
Succinct Non-interactive ARguments of Knowledge [12],
[33], [49] provide succinct proofs for general computation
tasks, and have been implemented by several systems [12],
[49], [56]. We would like to use SNARKs to instantiate the
NIZK proofs in our protocols ‚Äî unfortunately, SNARK‚Äôs
security is too weak to be directly employed in UC protocols.
SpeciÔ¨Åcally, SNARK‚Äôs knowledge extractor is non-blackbox
and cannot be used by the UC simulator to extract witnesses
from statements sent by the adversary and environment ‚Äî
doing so would require that the extractor be aware of the
environment‚Äôs algorithm, which is inherently incompatible
with UC security.
UC protocols often require the NIZKs to have simulation
extractability. Although SNARKs do not satisfy simulation
extractability, Kosba et al. show that it is possible to apply
efÔ¨Åcient SNARK-lifting transformations to construct simula-
tion extractable proofs from SNARKs [38]. Our implementa-
tions thus adopt the efÔ¨Åcient SNARK-lifting transformations
proposed by Kosba et al. [38].
B. Practical Considerations
EfÔ¨Åcient SNARK circuits. A SNARK prover‚Äôs performance
is mainly determined by the number of multiplication gates
in the algebraic circuit to be proven [12], [49]. To achieve
efÔ¨Åciency, we designed optimized circuits through two ways:
1) using cryptographic primitives that are SNARK-friendly,
i.e. efÔ¨Åciently realizable as arithmetic circuits under a speciÔ¨Åc
SNARK parametrization. 2) Building customized circuit gen-
erators to produce SNARK-friendly implementations instead
of relying on compilers to translate higher level implementa-
tion.
The main cryptographic building blocks in our system are:
collision-resistant hash function for the Merkle trees, pseudo-
random function, commitment, and encryption. Our imple-
mentation supports both 80-bit and 112-bit security levels. To
instantiate the CRH efÔ¨Åciently, we use an Ajtai-based SNARK-
friendly collision-resistant hash function that is similar to the
one used by Ben-Sasson et al. [14]. In our implementation, the
modulus q is set to be the underlying SNARK implementation
254-bit Ô¨Åeld prime, and the dimension d is set to 3 for the 80-
bit security level, and to 4 for the 112-bit security level based
on the analysis in [38]. For PRFs and commitments, we use
a hand-optimized implementation of SHA-256. Furthermore,
we adopt the SNARK-friendly primitives for encryption used
in the study by Kosba et al. [38], in which an efÔ¨Åcient circuit
for hybrid encryption in the case of 80-bit security level was
proposed. The circuit performs the public key operations in a
prime-order subgroup of the Galois Ô¨Åeld extension FpŒº, where
Œº = 4, p is the underlying SNARK Ô¨Åeld prime (typically 254-
bit prime, i.e. pŒº is over 1000-bit ), and the prime order of the
subgroup used is 398-bit prime. This was originally inspired
by Pinocchio coin [26]. The circuit then applies a lightweight
cipher like Speck [10] or Chaskey-LTS [47] with a 128-bit key
to perform symmetric encryption in the CBC mode, as using
the standard AES-128 instead will result in a much higher
cost [38]. For the 112-bit security, using the same method for
public key operations requires intensive factorization to Ô¨Ånd
suitable parameters, therefore we use a manually optimized
RSA-OAEP encryption circuit with a 2048-bit key instead.
In the next section, we will illustrate how using SNARK-
friendly implementations can lead to 2.0-3.7√ó savings in the
size of the circuits at the 80-bit security level, compared to
the case when naive straightforward implementation are used.
We will also illustrate that the performance is also practical
in the higher security level case.
Optimizations for finalize.
In addition to the SNARK-
friendly optimizations, we focus on optimizing the O(N)-
sized finalize circuit since this is our main performance
bottleneck. All other SNARK proofs in our scheme are for
O(1)-sized circuits. Two key observations allow us to greatly
improve the performance of the proof generation during
finalize.
Optimization 1: Minimize SSE-secure NIZKs. First, we ob-
serve that in our proof, the simulator need not extract any new
witnesses when a corrupted manager submits proofs during a
850
850
Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA. Downloaded on July 16,2025 at 23:03:37 UTC from IEEE Xplore.  Restrictions apply. 
finalize operation. All witnesses necessary will have been
learned or extracted by the simulator at this point. Therefore,
we can employ an ordinary SNARK instead of a stronger
simulation sound extractable NIZK during finalize. For
freeze and compute, we still use the stronger NIZK. This
optimization reduces our SNARK circuit sizes by 1.5√ó as can
be inferred from Figure 9 of Section VI, after SNARK-friendly
optimizations are applied.
Optimization 2: Minimize public-key encryption in SNARKs.
Second, during finalize, the manager encrypts each party
Pi‚Äôs output coins to Pi‚Äôs key, resulting in a ciphertext cti.
The ciphertexts {cti}i‚àà[N] would then be submitted to the
contract along with appropriate SNARK proofs of correctness.
Here, if a public-key encryption is employed to generate
the cti‚Äôs, it would result in relatively large SNARK circuit
size. Instead, we rely on a symmetric-key encryption scheme
denoted SENC in Figure 6. This requires that the manager
and each Pi perform a key exchange to establish a symmetric
key ki. During an compute, the user encrypts this ki to the
manager‚Äôs public key PM.epk, and prove that the k encrypted
is consistent with the k committed to earlier in cmi. The
SNARK proof during finalize now only needs to include
commitments and symmetric encryptions instead of public key
encryptions in the circuit ‚Äì the latter much more expensive.
This second optimization additionally gains us a factor of
1.9√ó as shown in Figure 9 of Section VI after applying the
previous optimizations. Overall, all optimizations will lead to
a gain of more than 10√ó in the finalize circuit.
Remarks about the common reference string. SNARK
schemes require the generation of a common reference string
(CRS) during a pre-processing step. This common reference
string consists of an evaluation key for the prover, and a
veriÔ¨Åcation key for the veriÔ¨Åer. Unless we employ recursively
composed SNARKs [18], [25] whose costs are signiÔ¨Åcantly
higher, the evaluation key is circuit-dependent, and its size
is proportional to the circuit‚Äôs size.
In comparison, the
veriÔ¨Åcation key is O(|in| + |out|) in size, i.e., depends on
the total length of inputs and outputs, but independent of the
circuit size. We stress that only the veriÔ¨Åcation key portion of
the CRS needs to be included in the public contract that lives
on the blockchain.
We remark that the CRS for protocol UserPcash is shared
globally, and can be generated in a one-time setup. In com-
parison, the CRS for each Hawk contract would depend
on the Hawk contract, and therefore exists per instance of
Hawk contract. To minimize the trust necessary in the CRS
generation, one can employ either trusted hardware or use
secure multi-party computation techniques as described by
Ben-Sasson et al. [13].
Finally, in the future when new primitives become sufÔ¨Å-
ciently fast, it is possible to drop-in and replace our SNARKs
with other primtives that do not require per-circuit preprocess-
ing. Examples include recursively composed SNARKs [18],
[25] or other efÔ¨Åcient PCP constructions [16]. The commu-
nity‚Äôs efforts at optimizing these constructions are underway.
Compile 
Augment 

.. 
.. 
.. 
Private Input 
Private inCoin Values 
Symmetric Enc Key 
Public statement  
(seen by contract) 
randomness 
To Libsnark 
Comm 
Comm 
Comm 
Enc 
Enc 
Balance 
Check 
Comm 

T/F? 
Private outCoin Values 
Program 
Œ¶priv
Fig. 7. Compiler overview. Circuit augmentation for finalize.
VI. IMPLEMENTATION AND EVALUATION
A. Compiler Implementation
Our compiler consists of several steps, which we illustrate
in Figure 7 and describe below:
Preprocessing: First, the input Hawk program is split into its
public contract and private contract components. The public
contract is Serpent code, and can be executed directly atop
an ordinary cryptocurrency platform such as Ethereum. The
private contract is written in a subset of the C language,
and is passed as input to the Pinocchio arithmetic circuit
compiler [49]. Keywords such as HawkDeclareParties are
implemented as C preprocessors macros, and serve to de-
Ô¨Åne the input (Inp) and output (Outp) datatypes. Currently,
our private contract inherits the limitations of the Pinocchio
compiler, e.g., cannot support dynamic-length loops. In the
future, we can relax these limitations by employing recursively
composition of SNARKs.
Circuit Augmentation: After compiling the preprocessed pri-
vate contract code with Pinocchio, we have an arithmetic
circuit representing the input/output relation œÜpriv. This be-
comes a subcomponent of a larger arithmetic circuit, which we
assemble using a customized circuit assembly tool. This tool
is parameterized by the number of parties and the input/output
datatypes, and attaches cryptographic constraints, such as
computing commitments and encryptions over each party‚Äôs
output value, and asserting that the input and output values
satisfy the balance property.
Cryptographic Protocol: Finally, the augmented arithmetic
circuit is used as input to a state-of-the-art zkSNARK library,
Libsnark [15]. To avoid implementing SNARK veriÔ¨Åcation
in Ethereum‚Äôs Serpent language, we must add a SNARK
veriÔ¨Åcation opcode to Ethereum‚Äôs stack machine. We Ô¨Ånally
compile an executable program for the parties to compute the
Libsnark proofs according to our protocol.
B. Additional Examples
Besides our running example of a sealed-bid auction (Fig-
ure 2), we implemented several other examples in Hawk,
demonstrating various capabilities:
Crowdfunding: A Kickstarter-style crowdfunding campaign,
(also known as an assurance contract in economics litera-
ture [9]) overcomes the ‚Äúfree-rider problem,‚Äù allowing a large
851
851
Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA. Downloaded on July 16,2025 at 23:03:37 UTC from IEEE Xplore.  Restrictions apply. 
TABLE I
Performance of the zk-SNARK circuits for the user-side circuits: pour,
freeze AND compute (SAME FOR ALL APPLICATIONS). MUL denotes
multiple (4) cores, and ONE denotes a single core. The mint operation does
not involve any SNARKs, and can be computed within tens of
microseconds. The Proof includes any additional cryptographic material
used for the SNARK-lifting transformation.
80-bit security
112-bit security
pour freeze compute pour freeze compute
KeyGen(s)MUL
26.3
18.2
15.9
36.7
30.5
34.6
ONE
88.2
63.3
54.42 137.2
111.1
131.8
Prove(s)
MUL
12.4
8.4
9.3
18.5
15.7
16.8
ONE
27.5
20.7
22.5
42.2
40.5
41.7
Verify(ms)
9.7
9.1
10.0
9.9
9.3
9.9
EvalKey(MB)
148
106
90
236
189
224
VerKey(KB)
7.3
4.4
7.8
8.7
5.3
8.4
Proof(KB)
0.68
0.68
0.68
0.71
0.71
0.71
Stmt(KB)
0.48
0.16
0.53
0.57
0.19
0.53
number of parties to contribute funds towards some social
good. If the minimum donation target is reached before the
deadline, then the donations are transferred to a designated
party (the entrepreneur); otherwise, the donations are refunded.
Hawk preserves privacy in the following sense: a) the do-
nations pledged are kept private until the deadline; and b)
if the contract fails, only the manager learns the amount by
which the donations were insufÔ¨Åcient. These privacy properties
may conceivably have a positive effect on the willingness
of entrepreneurs to launch a crowdfund campaign and its
likelihood of success.
Rock Paper Scissors: A two-player lottery game, and natu-
rally generalized to an N-player version. Our Hawk imple-
mentation provides the same notion of Ô¨Ånancial fairness as
in [7], [17] and provides stronger security/privacy guarantees.
If any party (including the manager), cheats or aborts, the
remaining honest parties receive the maximum amount they
might have won otherwise. Furthermore, we go beyond prior
works [7], [17] by concealing the players‚Äô moves and the
pseudonym of the winner to everyone except the manager.
‚ÄúSwap‚Äù Financial Instrument: An individual with a risky
investment portfolio (e.g, one who owns a large number
of Bitcoins) may hedge his risks by purchasing insurance
(e.g., by effectively betting against the price of Bitcoin with
another individual). Our example implements a simple swap
instrument where the price of a stock at some future date
(as reported by a trusted authority speciÔ¨Åed in the public
contract) determines which of two parties receives a payout.
The private contract ensures the privacy of both the details of
the agreement (i.e., the price threshold) and the outcome.
The full Hawk programs for these examples are provided in
our online version [37].
C. Performance Evaluation
We evaluated the performance for various examples, using
an Amazon EC2 r3.8xlarge virtual machine. We assume
a maximum of 264 leaves for the Merkle trees, and we
TABLE II
Performance of the zk-SNARK circuits for the manager circuit
finalize for different applications. The manager circuits are the same
for both security levels. MUL denotes multiple (4) cores, and ONE denotes a
single core.
swap rps
auction crowdfund
#Parties
2
2
10
100
10
100
KeyGen(s)MUL
8.6
8.0 32.3 300.4 32.16 298.1
ONE
27.8 24.9 124 996.3 124.4 976.5
Prove(s)
MUL
3.2
3.1 15.4 169.3
15.2 169.2
ONE
7.6
7.4 40.1 384.2
40.3 377.5
Verify(ms)
8.4
8.4
10
19.9
10
19.8
EvalKey(GB)
0.04 0.04 0.21
1.92
0.21
1.91
VerKey(KB)
3.3
2.9 12.9 113.8
12.9 113.8
Proof(KB)
0.28 0.28 0.28
0.28
0.28
0.28
Stmt(KB)
0.22
0.2 1.03
9.47
1.03
9.47
0
0.5
1
1.5
pour
freeze
compute
Number of mul gates (x 1 million)
Na√Øve
SNARK-friendly Impl.
2.3x
1.0x
1.0x
1.0x
2.6x
2.0x
Fig. 8. Gains of using SNARK-friendly implementation for the user-side
circuits: pour, freeze and compute at 80-bit security.
present results for both 80-bit and 112-bit security levels. Our
benchmarks actually consume at most 27GB of memory and 4
cores in the most expensive case. Tables I and II illustrate the
results ‚Äì we focus on evaluating the zk-SNARK performance
since all other computation time is negligible in comparison.
We highlight some important observations:
‚Ä¢ On-chain computation (dominated by zk-SNARK veriÔ¨Åca-
tion time) is very small in all cases, ranging from 9 to 20
milliseconds The running time of the veriÔ¨Åcation algorithm
0
20
40
60
80
Auction (25)
Auction (50)
Auction (100)
Number of mul gates (x 1 million)
Na√Øve
SNARK-friendly Impl.
With Opt 1
With Opt 2 (overall)
1.0x
1.9x
2.8x
10.5x
10.5x
2.8x
1.9x 1.0x
10.5x
2.8x
1.9x
1.0x
Fig. 9.
Gains after adding each optimization to the finalize auction
circuit, with 25, 50 and 100 Bidders. Opt 1 and Opt 2 are two practical
optimizations detailed in Section V.
852
852
Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA. Downloaded on July 16,2025 at 23:03:37 UTC from IEEE Xplore.  Restrictions apply. 
is just linearly dependent on the size of the public statement,
which is far smaller than the size of the computation,
resulting into small veriÔ¨Åcation time.
‚Ä¢ On-chain
public
parameters: As mentioned in Sec-
tion IV-C, not the entire SNARK common reference string
(CRS) need to be on the blockchain, but only the veriÔ¨Åcation
key part of the CRS needs to be on-chain. Our imple-
mentation suggests the following: the private cash protocol
requires a veriÔ¨Åcation key of 23KB to be stored on-chain ‚Äì
this veriÔ¨Åcation key is globally shared and there is only a
single instance. Besides the globally shared public param-
eters, each Hawk contract will additionally require 13-114
KB of veriÔ¨Åcation key to be stored on-chain, for 10 to 100
users. This per-contract veriÔ¨Åcation key is circuit-dependent,
i.e., depends on the contract program. We refer the readers
to Section IV-C for more discussions on techniques for
performing trusted setup.
‚Ä¢ Manager computation: Running private auction or crowd-
funding protocols with 100 participants requires under
6.5min proof time for the manager on a single core, and
under 2.85min on 4 cores. This translates to under $0.14 of
EC2 time [2].
‚Ä¢ User computation: Users‚Äô proof times for pour, freeze
and compute are under one minute, and independent of the
number of parties. Additionally, in the worst case, the peak
memory usage of the user is less than 4 GB.
Savings from protocol optimizations. Figure 8 illustrates
the performance gains attained by using a SNARK-friendly
implementation for the user-side circuits, i.e. pour, freeze
and compute w.r.t. the naive implementation at the 80-bit
security level. We calculate the naive implementation cost
using conservative estimates for the straightforward implemen-
tation of standard cryptographic primitives. The Ô¨Ågure shows a
gain of 2.0-2.6√ó compared to the naive implementation. Fur-
thermore, Figure 9 illustrates the performance gains attained
by our protocol optimizations described in Section V The
Ô¨Ågure considers the sealed-bid auction Ô¨Ånalize circuit at dif-
ferent number of bidders. We show that the SNARK-friendly
implementation along with our two optimizations combined
signiÔ¨Åcantly reduce the SNARK circuit sizes, and achieve a
gain of 10√ó relative to a straightforward implementation. The
Ô¨Ågure also illustrates that the manager‚Äôs cost is proportional
to the number of participants. (By contrast, the user-side costs
are independent of the number of participants).
VII. ADDITIONAL THEORETICAL RESULTS
Last but not the least, we present additional theoretical
results to fruther illustrate the usefulness of our formal block-
chain model. In the interest of space, we defer details to the
online version [37], and only state the main Ô¨Åndings here.
Fair MPC with public deposits in the generic blockchain
model. As is well-understood, fairness is in general impossible
in plain models of multi-party computation when the majority
can be corrupted. This was Ô¨Årst observed by Cleve [24]
and later extended in subsequent papers [8]. Assuming a
TABLE III
Additional theoretical results for fair MPC with public deposits. The
table assumes that N parties wish to securely compute 1 bit of output that
will be revealed to all parties at the end. For collateral, we assume that each
aborting party must pay all honest parties 1 unit of currency.
claim-or-refund [17]
multi-lock [40]
generic
blockchain
On-chain cost
O(N2)
O(N2)
O(N)
# rounds
O(N)
O(1)
O(1)
Total collateral
O(N2)
O(N2)
O(N2)
blockchain trusted for correctness and availability (but not
for privacy), an interesting notion of fairness which we refer
to as ‚ÄúÔ¨Ånancial fairness‚Äù can be attained as shown by recent
works [7], [17], [40]. In particular, the blockchain can Ô¨Ånan-
cially penalize aborting parties by conÔ¨Åscating their deposits.
Earlier works in this space [7], [17], [40], [50] focus on
protocols that retroÔ¨Åt the artifacts of Bitcoin‚Äôs limited scripting
language. SpeciÔ¨Åcally, a few works use Bitcoin‚Äôs scripting
language to construct intermediate abstractions such as ‚Äúclaim-
or-refund‚Äù [17] or ‚Äúmulti-lock‚Äù [40], and build atop these
abstractions to construct protocols. Table VII shows that by
assuming a generic blockchain model where the blockchain
can run Turing-complete programs, we can improve the efÔ¨Å-
ciency of Ô¨Ånancially fair MPC protocols.
Fair MPC with private deposits. We further illustrate how to
perform Ô¨Ånancially fair MPC using private deposits, i.e., where
the amount of deposits cannot be observed by the public. The
formal deÔ¨Ånitions, constructions, and proofs are supplied in
the online version [37].
ACKNOWLEDGMENTS
We gratefully acknowledge Jonathan Katz, Rafael Pass,
and abhi shelat for helpful technical discussions about the
zero-knowledge proof constructions. We also acknowledge
Ari Juels and Dawn Song for general discussions about
cryptocurrency smart contracts. This research is partially sup-
ported by NSF grants CNS-1314857, CNS-1445887, CNS-
1518765, CNS-1514261, CNS-1526950, a Sloan Fellowship,
three Google Research Awards, Yahoo! Labs through the
Faculty Research Engagement Program (FREP) and a NIST
award.
"
pdf//Hybrid_Blockchain_Design_for_Privacy_Preserving_Crowdsourcing_Platform.pdf;First, the traditional crowdsourcing model relies on a centralized trusted third-party platform, which directly leads to a single point of failure.;Never- theless, all of these existing works ignore the scalability and transaction veriÔ¨Åcation efÔ¨Åciency of the blockchain network, limiting the performance of the crowdsourcing systems.;Once the answer collection stage is Ô¨Ånished, the smart contracts compute the reward of each answer and generate a zero-knowledge proof œÄr with the task requester‚Äôs private key skr as the witness to commit the successful running of the reward distribution policy.;Then, to enhance transaction ver- iÔ¨Åcation throughput, Delegated Proof of Stake (DPOS) and Practical Byzantine Fault Tolerance (PBFT) consensuses are respectively deployed on the public chain and the subchains, and smart contracts of the public chain and the subchains are designed accordingly.;[('public', 70), ('transaction', 69), ('task', 68), ('blockchain', 65), ('chain', 63), ('subchain', 62), ('platform', 55), ('validator', 54), ('worker', 48), ('answer', 38)];2018.0;In our future work, we will plan to realize 32 Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA.;"Hybrid Blockchain Design for Privacy Preserving
Crowdsourcing Platform
Saide Zhu, Huafu Hu, Yingshu Li, Wei Li
Department of Computer Science, Georgia State University, Atlanta, GA, USA
Email: szhu5@student.gsu.edu, hhu4@student.gsu.edu, yili@gsu.edu, wli28@gsu.edu
Abstract‚ÄîBlockchain has been treated as one of the most
promising technologies to promote crowdsourcing by providing
new nice features, such as decentralization and accountability.
Unfortunately, some inherent limitations of blockchain have been
rarely addressed by the most existing works when applying
blockchain into crowdsourcing, which becomes the performance
bottleneck of crowdsourcing systems. In this paper, we propose
a novel hybrid blockchain crowdsourcing platform to achieve
decentralization and privacy preservation. Our platform inte-
grates with a hybrid blockchain structure, dual-ledgers, and dual-
consensus algorithms to ensure secure communication between
the requesters and the workers. Moreover, the smart contract and
zero-knowledge proof are employed to ensure automatic opera-
tion of the tasks and the protection users‚Äô privacy, respectively.
Finally, we conduct experiments to conÔ¨Årm the efÔ¨Åciency of the
adopted consensus algorithm on our platform by comparing it
with the state-of-the-art.
Index Terms‚Äîhybrid blockchain, crowdsourcing, smart con-
tract, privacy preservation.
I. INTRODUCTION
Crowdsourcing that outsources tasks to a non-speciÔ¨Åc, and
usually large, mass network has already been popular and
widely applied for years [1]. A typical example is Wikipedia,
which allows everyone to join the platform and answer spe-
ciÔ¨Åc questions, and thus solving diverse customer needs [2].
Another application is Uber, which crowds the passengers‚Äô
post and sends to the social idle drivers‚Äô clients [3]. Recently,
Amazon also provides its crowdsourcing marketplace called
Amazon Mechanical Turk (MTurk) to help companies to
harness intelligence from a global view and enable workers to
work on their interested tasks [4]. As an advanced paradigm,
crowdsourcing is destined to have a bright future for important
real-world applications.
Although crowdsourcing can solve many problems at
present, research shows that there are still many issues in
the traditional crowdsourcing model. First, the traditional
crowdsourcing model relies on a centralized trusted third-party
platform, which directly leads to a single point of failure. For
instance, Wikipedia suffered from 8 service outrage in 2018,
and thus users could not access the data from the server [5].
Second, the centralized platform masters all the transactions,
which may bring silently misbehave problems. Third, when
there is a conÔ¨Çict of opinions between the task requester
and the worker, the problems of Free-riding (receive rewards
without making real efforts) and False-reporting (dishonest
requesters try to repudiate the payment) would happen in the
system [6]. Last but not least, during the communications be-
tween task requesters and workers, their sensitive information
is likely to suffer the threat of privacy leakage; for instance,
Uber disclosed in Nov 2017 due to 57 million driver‚Äôs informa-
tion had been hacked [7]. To tackle the aforementioned issues,
many countermeasures have been proposed. For examples,
in [8], [9], the k-anonymity algorithm and differential privacy
model were adopted to prevent the disclosure of sensitive user
information during the transaction process; and in [10], [11],
the reputation systems were introduced to solve the problems
of free-riding and false-reporting in crowdsourcing. All of
these studies cannot solve the above mentioned issues for the
current crowdsourcing systems at the same time.
With the rapid development of blockchain technology, smart
contracts with many cryptographic tools can be incorporated
into blockchain networks. Thus, by exploiting blockchain
technology, the privacy issues in the traditional crowdsourcing
systems can be solved more effectively and efÔ¨Åciently. The
prior works [12]‚Äì[14] proposed different solutions for location
leakage problems. The identity authentication systems were
designed by [15], [16] to provide a security guarantee for users
who join the blockchain. In [14], the combination of public
and private chains is used to provide private service for some
workers, preventing privacy leakage. However, it is worthy of
deeper discussion on the authority of the agent entity. Never-
theless, all of these existing works ignore the scalability and
transaction veriÔ¨Åcation efÔ¨Åciency of the blockchain network,
limiting the performance of the crowdsourcing systems.
Thus, for the purpose of performance improvement, the ob-
jective of this paper is to develop a distributed crowdsourcing
platform to securely and Ô¨Çexibly process user access control
and task management using blockchain technology. Unavoid-
ably, here are some challenges in building a blockchain-
embedded crowdsourcing platform: (i) The traditional con-
sensus protocols, e.g,,Proof-of-Work (PoW), in the blockchain
network may have the scalability bottleneck and cause a lot of
energy consumption [17]. Thus, adopting suitable consensus
protocols is expected to speed up transaction veriÔ¨Åcation rate.
(ii) In the traditional blockchain networks, all transactions are
public for providing accountability and transparency, which
however, may leak users‚Äô private information. There, the
challenge lies in co-existence of privacy and transparence in
blockchain-based crowdsourcing. (iii) On a hybrid blockchain
platform, the interactions between different blockchains and
the ledger management should be well designed.
26
2019 IEEE International Conference on Blockchain (Blockchain)
978-1-7281-4693-5/19/$31.00 ¬©2019 IEEE
DOI 10.1109/Blockchain.2019.00013
Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA. Downloaded on July 14,2025 at 17:04:21 UTC from IEEE Xplore.  Restrictions apply. 
In order to address these challenges, in this paper, we
propose to carry out the following activities. We Ô¨Årst develop a
framework of the hybrid blockchain-embedded crowdsourcing
platform consisting of a public chain and multiple private
subchains. In particular, the subchains are dynamically estab-
lished to satisfy the needs of private tasks, and the information
of private answers is kept secretly on the subchains but can
be veriÔ¨Åed on the public chain by exploiting dual-ledgers
and zero-knowledge proof. Then, to enhance transaction ver-
iÔ¨Åcation throughput, Delegated Proof of Stake (DPOS) and
Practical Byzantine Fault Tolerance (PBFT) consensuses are
respectively deployed on the public chain and the subchains,
and smart contracts of the public chain and the subchains are
designed accordingly. Finally, intensive experiments are set
up to evaluate the performance of our proposed platform. The
contributions of this paper are summarized as follows.
‚Ä¢ A novel hybrid blockchain platform is proposed for
distributed crowdsourcing, in which transaction privacy
and transparency can be effectively balanced.
‚Ä¢ The transaction veriÔ¨Åcation rate is greatly increased by
deploying DPOS and PBFT consensuses, reducing energy
consumption in crowdsourcing.
‚Ä¢ The smart contracts are developed on both public chain
and subchains to control user access as well as to protect
user privacy.
‚Ä¢ Experiments are conducted to evaluate the effectiveness
of the applied consensus algorithms in terms of execution
time and throughput.
The remainder of this paper is organized as follows. The ex-
isting related works are presented in Section II. In Section III,
the preliminaries are introduced. Our hybrid blockchain plat-
form and the implementation process are proposed in Sec-
tion IV and Section V, respectively. The experiments are
conducted in Section V-F. At last, this paper is concluded in
Section VII.
II. RELATED WORK
In this section, we brieÔ¨Çy summarize the most related
works and discuss how they enlighten us to build a hybrid
blockchain-based crowdsourcing platform.
One of the recent hot topics in mobile crowdsourcing is
incorporating blockchain into the crowdsourcing platform for
performance improvement. Li et al. proposed a blockchain-
based decentralized crowdsourcing framework and implements
several smart contracts to show the effectiveness of their
framework [18]. However, the uploaded information from
system users is recorded on the blockchain in public; thereby
the privacy issue is not considered. Lu et al. designed a
private and anonymous decentralized crowdsourcing platform
called ZebraLancer which increases the privacy level of the
crowdsourcing system but may cause a big data load of the
platform, so the performance of the system‚Äôs efÔ¨Åciency is still
debatable [15]. In [19], blockchain and smart contracts were
used to orchestrate the interactions between mobile crowd-
sensing providers and mobile users, but this work focused
on the smart execution of incentive mechanism not on task
processing. Zou et al. proposed a Proof-of-Trust consensus on
hybrid blockchain to meet the practical requirements in service
industry [20]. Their proposed consensus structure is similar
to Hyperledger Fabric, which can greatly increase the trans-
action veriÔ¨Åcation speed while still lacks privacy-preserving
mechanisms integrated into the system. Jia et al. proposed a
hybrid blockchain platform to achieve secure transaction and
location privacy preservation in crowdsourcing. However, the
centralization problems on their agent nodes still need more
discussion [14].
III. PRELIMINARY
A. DPOS Consensus
The core of the blockchain is the consensus protocol. The
Ô¨Årst generation of digital currency blockchain represented by
Bitcoin that adopts the Proof-of-Work (POW) consensus [21].
POW guarantees that every node in the network can get fair
reward corresponding to their effort made through mining.
However, due to the large energy consumption and slow
transaction veriÔ¨Åcation speed, it is difÔ¨Åcult to meet the needs
of enterprise-level blockchain networks. Therefore, in this
paper, we adopt the Byzantine Fault Tolerance (BFT)-based
Delegated Proof of Stake (DPOS) consensus protocol [22] on
the public chain.
In DPOS consensus, there are three roles, including stake-
holders, witnesses (block producers or validators), and alter-
native nodes. Stakeholders are holders of tokens who have the
right to vote for witnesses in the network. At the beginning of
every time cycle, the stakeholders re-elect the witnesses in the
network. Witnesses are super-nodes in the DPOS blockchain
network and verify the previous transactions and package the
newly generated transactions into blocks. For example, in the
EOS network, there are 21 witnesses nodes that take turns to
share the accounting rights of the blockchain every 3 seconds.
The remaining nodes in the network are called alternative
nodes. Although the alternative nodes do not make transaction
veriÔ¨Åcation, they still need to update the latest information of
the ledgers in time for next round of witnesses election. Since
the witnesses are voted by the stakeholders, it replaced the
POW mining mechanism that needs every node to work for a
computational puzzle. As a result, there is a big reduction in
energy consumption. Witnesses‚Äô faster block generating rate
also drastically reduces the time to complete a transaction‚Äôs
veriÔ¨Åcation. At the same time, the rotation of accounting rights
of the witnesses ensures the distributed characteristics of the
network. It is also worth mentioning that when a witness
fails or does something evil, the stakeholders can re-elect the
witnesses to discharge the abnormal nodes. Similar to POW,
DPOS also treats the longest chain as the only legal one. So,
when the fork appears, a chain with more witnesses working
on it is treated as legal. If all the witnesses work on the same
chain at the same time, the blocks produced at full speed.
The BFT mechanism in DPOS requires that the number of
malicious or faulty nodes in the network does not exceed one-
third of the total number of nodes. So that the evil node cannot
reach the block generating speed of honest nodes even if they
27
Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA. Downloaded on July 14,2025 at 17:04:21 UTC from IEEE Xplore.  Restrictions apply. 
all work on the same fork. Therefore, the security of DPOS is
guaranteed. Many enterprise applications that adopt the DPOS
consensus, such as EOS.io [23] and Bitshares [24], have also
shown its robustness in practice.
In addition to the advantages of DPOS in veriÔ¨Åcation speed
and energy consumption, DPOS provides the Ô¨Ånality feature.
When a block receives an acknowledgment from 2n/3 + 1
nodes (n the number of total nodes in the network), the block
is permanently and legally written into the ledger and will no
longer be replaced by a longer chain.
B. PBFT Consensus
Another consensus that can tolerate Byzantine failures is
Practical Byzantine Fault Tolerance (PBFT). The algorithm
was proposed by Castro and Liskov in 1999, which enhances
the performance of the original Byzantine fault-tolerant al-
gorithm. Each node in the blockchain network shares the
same ledger; essentially the blockchain is a replicated state
machine. Therefore, in recent years, the PBFT algorithm has
been applied to the blockchain applications more widely as a
consensus protocol, such as Zilliqa [25] and Hyperledger [26].
First, the network is required to dynamically select a leader
node, and all nodes in the network can participate in the
election. The election process is repeated in a round-robin
manner. After the leader node gets selected, the leader needs
to send a heartbeat message to the peer nodes to prove its
liveness. If one or more nodes in the network do not receive
the heartbeat message, a new round of leader elections is
performed to ensure the stability of the network.
Roughly speaking, PBFT consensus algorithm can be di-
vided into Ô¨Åve steps: request, pre-prepare, prepare, commit
and reply. In the request phase, a client sends a request to the
leader node. When receiving the request, the leader broadcasts
the pre-prepare massage to inform the entire network that he
is the current leader, and sends the client‚Äôs request to other
peer nodes. All replica nodes authenticate the pre-prepared
messages when receiving them. After accepting 2f + 1 pre-
prepared information, the peer nodes multi-cast a prepare mes-
sage to all other nodes, where f is the number of Byzantine
Failure nodes in the network. In the commit phase, each replica
node veriÔ¨Åes whether more than 2f + 1 of identical requests
have been received. Once the acceptance condition of the
commit message is satisÔ¨Åed, the replica node writes a commit
message to the message log and accepts the command for
execution. In the last phase, the nodes execute the request and
send a reply to the client. And the client should wait for more
than f + 1 replies with the same result from different nodes
to ensure the correctness of the execution.
PBFT consensus, in theory, is more efÔ¨Åcient than Proof-of-
Work consensus and can reach a high transaction veriÔ¨Åcation
speed when the transaction volume is not too high. Another
advantage of PBFT consensus is that the transaction Ô¨Ånality
can be achieved more easily without waiting for multiple
conÔ¨Årmations. Once the transactions are included in a block,
these transactions are immediately considered Ô¨Ånalized and no
one can change them. Last but not least, PBFT can achieve
the network agreement without intensive computations, which
means the energy consumption of executing the PBFT con-
sensus is relatively lower.
C. Smart Contract
The smart contract was introduced at the blockchain 2.0
stage. It was Ô¨Årst implemented based on Ethereum platform
with Solidity language. The smart contract can be written in the
form of code and stored on a blockchain. Once the terms of the
contract trigger a condition, the code is automatically executed,
which saves a lot of artiÔ¨Åcial communication and supervision
costs. Since the smart contract is stored on a blockchain, it
inherits some nice properties, such as the features of account-
ability and decentralization. Once a smart contract is written,
it can be trusted by the users. The blockchain network ensures
that the terms of the contract cannot be changed.
When
combined
with
the
crowdsourcing
systems,
a
blockchain platform should have the ability to process the
crowdsourcing data and assign different permissions to various
entities. Thus a programmable interface should be public to
developers, which can be accomplished via the smart contract.
D. Zero Knowledge Proof
With the widespread use of smart contracts, the privacy
preservation problem for the implementation of smart contracts
has become an emerging topic. Developers are trying to
deploy general cryptography methodology in smart contracts,
including the compilers for multi-party computation [27], [28]
and zero-knowledge proof [29], [30].
Among these approaches, ZK-proof allows a prover to gen-
erate encrypted evidence, and a veriÔ¨Åer performs a veriÔ¨Åcation
of a private state by performing a generated calculation on
the witness without leaking any relevant information. Inspired
by platforms such as Hawk [31], Zcash [32], and Ethereum,
in this paper, we also use Zero-Knowledge Succinct Non-
Interactive Argument of Knowledge (ZK-SNARK) to build
optimized ZK-proof to help verify transactions between the
public chain and the subchains.
SpeciÔ¨Åcally, the ZK-SNARK algorithm on the blockchain
contains three modules. First, there is a setup algorithm gen-
erating a public parameter to establish the SNARK. Then, the
prover module uses the SNARK to generate an attestation to
verify the authenticity of a statement. Finally, the correctness
of the proof can be veriÔ¨Åed by calling the veriÔ¨Åer module on
the chain.
IV. PLATFORM FRAMEWORK
Our crowdsourcing platform is built based on a hybrid
blockchain network that consists of a public chain and multiple
subchains, in which public tasks are posted on the public chain
and private tasks are uploaded to the subchains for privacy
protection. The platform framework is presented in Fig. 1.
On the platform, there are three types of entities, including
requester, worker, and validator, each of which is introduced
in the following.
28
Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA. Downloaded on July 14,2025 at 17:04:21 UTC from IEEE Xplore.  Restrictions apply. 



!##
#!#



!###
#!#
#

!###
#!#
##

!## #
!## #
  ""# #
	#
#
Fig. 1. Framework of our blockchain-embedded crowdsourcing platform
‚Ä¢ Requester: Requesters can announce tasks, collect an-
swers from workers, and make payments to workers. Each
requester is required to make a deposit to the blockchain
via smart contract. The deposit is used to reward the
workers who process tasks as well as the validators
who verify transactions. It is worth emphasizing that any
requester cannot register as a validator for the blockchain
network, but can potentially become a worker. The re-
questers have the rights to vote for public-chain validators
and subchain validators in which they post their private
tasks on the corresponding subchains.
‚Ä¢ Workers: Workers process requesters‚Äô tasks and obtain
payments from the requesters. If a worker implements a
public task, his answers are uploaded to the public chain;
otherwise, his answers are uploaded to a subchain. Each
worker has the right to vote for public-chain validators
and subchain validators in which he implements tasks on
the corresponding subchains. Any worker can not register
as a validator, but can potentially become a requester.
‚Ä¢ Validators: In the blockchain network, there is a set of
nodes working as validators which can be classiÔ¨Åed into
three categories according to their duties, i.e., public-
chain validator, alternative validator, and subchain val-
idator. (i) Public-chain validators work as the veriÔ¨Åcation
nodes for the public chain, which take turns to get the
accounting right. They provide a veriÔ¨Åcation service for
all public transactions and share a public-chain ledger. In
every time cycle, the public validators may change. (ii)
Alternative validators are those nodes who are not se-
lected as the public-chain validators. They do not have the
right to produce blocks, but still need to share the public-
chain ledger. Alternative validators have the potential
to be selected as the subchain validators. (iii) Subchain
validators are elected from current alternative validators.
They perform transaction veriÔ¨Åcation for subchains where
the private tasks are posted and store the information of
both the public-chain and the subchain ledgers.
In order to join the blockchain-embedded crowdsourcing
system, the above three entities should Ô¨Årst register as the
legitimate members of the platform. On a public chain, ev-
eryone can join and generate transactions, greatly increasing
the probability of being attacked by malicious platform users.
Although the blockchain can ensure that all transactions during
the transmission process are recorded and cannot be falsiÔ¨Åed,
the authenticity of entities‚Äô identities cannot be veriÔ¨Åed, so
the blockchain is vulnerable to Sybil attack. Therefore, in this
paper, we employ a trusted third-party CertiÔ¨Åcated Authority
(CA) to verify entities‚Äô identities and issue certiÔ¨Åcates. Only
the entities that have obtained the legal certiÔ¨Åcates can join
the crowdsourcing platform.
Each requester can post public and/or private tasks on the
platform. If a task is public, the validators pass the task
information to the workers on the public chain; otherwise,
the validators send the task information to the workers on the
subchain according to the smart contracts. Then, the workers
choose tasks they are interested to implement. When a public
task is completed, the workers submit the answers to the
public-chain validators for veriÔ¨Åcation, and the transaction
information is recorded in the public-chain ledger. When a
private task is completed, the workers send the answers to
the subchain validators for veriÔ¨Åcation, and the transaction
information is recorded in the subchain ledger. After collecting
the answers, the leader on a subchain extracts the Merkel roots
in all block headers, forms a new Merkel tree with all the
extracted block Merkel roots as leaf nodes, generates a zero-
knowledge proof commitment, and publish it to the public
chain. Since the subchain validators on the same subchain
share the same ledger, this generated commitment can be
checked to prevent the leader node from being malicious. In
this way, the public-chain ledger records the transaction in-
formation of all public tasks and the commitment information
of private tasks on subchains while preserving the answers of
all private tasks. Meanwhile, each subchain copies the public-
chain ledger and records all the transaction information of
its subchain tasks. This information can only be accessed
through the permission of the smart contracts on the subchains.
When the answer collection is completed, the rewards are
distributed to the workers based on the reward policy in the
smart contracts, and the extra deposits are returned to the
corresponding requesters‚Äô accounts.
V. IMPLEMENTATION PROCESS
On our blockchain-embedded crowdsourcing platform, there
are six major phases of the implementation, including: Identity
Authetication, Public Chain Setup, Subchain Setup, Smart
Contract Deployment, Zero-Knowledge Poof, which are illus-
trated in this section.
A. Identity Authentication
Identity authentication has always been a critical part of
crowdsourcing [16]. To ensure the success rate of task comple-
tion, a trusted third-party CA is adopted to verify the identities
of entities who intend to participate into the crowdsourcing
platform as well as to issue certiÔ¨Åcates to indicate their
legitimacy.
At the beginning, each entity generates a pair of keys
(pkut, skut) using RSA algorithm, where ut ‚àà{r, w, v} to
29
Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA. Downloaded on July 14,2025 at 17:04:21 UTC from IEEE Xplore.  Restrictions apply. 
indicate the type of entity (i.e., r, w, and v represent requester,
worker, and validator, respectively.), pkut is the entity‚Äôs public
key, and skut is the entity‚Äôs private key. Then, the entity sends
the encrypted message E(pkc, pkut, IDut, Sig(skut, IDut))
to CA for registration, in which pkc is the public key
of CA, IDut is the entity‚Äôs real identity information, and
Sig(skut, IDut) is the entity‚Äôs digital signature.
When
receiving
an
entity‚Äôs
registration
E(pkc, pkut, IDut, Sig(skut, IDut)), CA veriÔ¨Åes whether
IDut and pkut have been stored in his historic information
as each entity is allowed to use one public key to avoid
sybil
attack.
If
IDut
and
pkut
pass
the
veriÔ¨Åcation,
CA
generates
a
unique
certiÔ¨Åed
identity
IDc
ut
and
a
certiÔ¨Åcation
Certut{IDc
ut, ut, pkut},
and
returns
the
encrypted certiÔ¨Åcation E(pkut, Certut, Sig(skc, Certut)) to
the entity, where skc and Sig(skc, Certut) are respectively the
private key and digital signature of CA. Only the entities who
receive the certiÔ¨Åcations can join the blockchain-embedded
crowdsourcing platform as legitimate users.
B. Public Chain Setup
Once all the validators complete their identity registration,
they start to establish a public chain by running BFT-based
DPOS consensus [22]. The registered requesters and workers
are the stakeholders in the blockchain network and vote for
the public-chain validators. In DPOS, the voting mechanism is
performed round by round. When malicious behavior of any
public-chain validator is detected or the deadline of a round
reaches, the current requesters and workers need to re-vote
for the public-chain validators. During each round of voting,
the 21 validators with the most votes become the public-
chain validators in the system, rotate the accounting rights,
and help verify the public tasks in this round. The remaining
validators become the alternative validators who share the
public-chain ledger and wait for the voting process of the
subchain validators.
C. Subchain Setup
For each private task, a subchain is temporarily created on
the crowdsourcing platform to process answer collection and
transaction veriÔ¨Åcation by running the PBFT consensus [33],
[34]. The subchain validators are elected from the existing
alternative validators. On each subchain, the corresponding
requester and workers are voters for the subchain validators.
According to the PBFT consensus protocol [33], to resist
Byzantine failure attack, the total number of nodes should be
larger than 3 times of the number of the Byzantine failure
nodes in the blockchain network. In other words, to guarantee
the Byzantine Fault Tolerance for the platform, there must have
at least 4 subchain validators on each subchain. If the number
of workers on a subchain is larger than a system threshold
œÑ, the subchain validators are elected by the requester and
corresponding workers, and the number of the validators is
determined by the system based on the expected transaction
volume; if the number of workers on a subchain is smaller than
œÑ, they may not be able to pick sufÔ¨Åcient validators to achieve
Byzantine Fault Tolerance. In this situation, 4 validators are
enough to meet the maximum transaction throughput of the
subchain. Thus, the smart contract will randomly select 4
subchain validators from the existing alternative validators.
When the private task is completed, the corresponding
subchain validators will be released and become the alternative
validators on the public chain.
D. Task Announcement & Response
The
information
of
each
task
is
posted
on
the
platform
in
the
form
of
Task{T, IDt, t1, t2, R, Num, p, pkr, certr, Sig(skc, Certr)},
in which T ‚àà{public, private} denotes the type of the task,
IDt is the ID number of the task, t1 is the deadline for the
workers to make response to the task announcement, t2 is
the deadline for the workers to submit their answers, R is
the total amount of rewards for completing the task, Num
is the maximum number of desired answers for the task, p
implies the task implementation preference (such as location,
working duration, and data quality) that is used by the task
requester to select desired workers, pkr is the task requester‚Äôs
public key, certr is the task requester‚Äôs certiÔ¨Åcation.
If a worker is interested in some tasks, he should
make a response before the deadline in the form of
Res{IDt, IDc
w, tr, cap, pkw, certw, Sig(skc, Certw)}.
SpeciÔ¨Åcally, the response information includes the task
identity IDt, the worker‚Äôs registered identity IDc
w, the
response time tr, the work‚Äôs capacity cap (such as location,
available time, and quality of offered data), the worker‚Äôs
public key pkw, and the worker‚Äôs certiÔ¨Åcation Certw and
digital signature. In addition, the worker‚Äôs certiÔ¨Åcation can be
veriÔ¨Åed with pkc, Certw, and Sig(skc, Certw).
When receiving a worker‚Äôs response message, each re-
quester Ô¨Årst checks whether the reply time tr is prior to
the deadline t1, i.e., ensuring that tr ‚â§t1, and whether the
worker has a valid certiÔ¨Åcation. If the worker passes such
veriÔ¨Åcation process, a permission permit(IDt, IDc
w, certw)
is issued to the worker and is replied in the form of
E(pkw, permit, Sig(skr, permit)), indicating that the worker
can carry out the task. Then, the worker needs to complete
the task and submit the answer before its deadline in the
form of Ans(T, IDt, AIDcw, IDc
w, ta, permit), where AIDcw
records the answer contents, and ta is the submission time.
On the platform, the methods of recording task answers in
the blockchain are determined according to the type of tasks.
If a task belongs to the public type, the answers are directly
veriÔ¨Åed by the public-chain validators and recorded in the
public-chain ledger; otherwise, the answers are submitted via
temporary subchains.
E. Smart Contract Deployment
Different from Bitcoin‚Äôs public chain, smart contracts are
deployed in the proposed hybrid blockchain system to con-
strain entities‚Äô behaviors and provide them with different per-
missions. In this subsection, the deployment of smart contracts
on the platform are detailed.
30
Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA. Downloaded on July 14,2025 at 17:04:21 UTC from IEEE Xplore.  Restrictions apply. 
1) Task Announcement & Response Process: When a re-
quester publishes a task, he needs to make a deposit to the
smart contracts. The blockchain system checks whether the
task is issued by a legitimate requester and has enough amount
of deposit that should be greater than the total task rewards.
If these conditions are satisÔ¨Åed, the task information will be
Ô¨Çooded to the online workers. When the workers reply to
the tasks, the smart contracts verify the workers‚Äô certiÔ¨Åcations
and their response time. Next, for valid responses, the smart
contracts are executed according to the type of tasks.
2) Answer
Collection
&
Reward
Distribution
on
Public
Chain:
When
receiving
an
answer
Ans(T, IDt, AIDcw, IDc
w, ta, permit)
of
a
public
task,
the smart contracts should ensure that i) the answer is
submitted by a permitted worker by verifying permit; ii)
the answer AIDcw is not repeated in the answer pool Poola;
and iii) the answer is submitted on time, i.e., ta ‚â§t2. If the
three constraints simultaneously hold, the answer is treated
as valid. If the number of valid answers exceeds the value of
Num, only the Ô¨Årst Num valid answers are recorded into
blocks; otherwise, all the valid answers are recorded. If a
task belongs to the private type, an attestation œÄa is sent from
the leader of the subchain for veriÔ¨Åcation. Then, the smart
contract runs ZK-SNARK veriÔ¨Åer to check the correctness of
tack completion and records it into the public-chain ledger.
Once the answer collection stage is Ô¨Ånished, the smart
contracts compute the reward of each answer and generate
a zero-knowledge proof œÄr with the task requester‚Äôs private
key skr as the witness to commit the successful running of
the reward distribution policy. Also, a validation fee should
be paid to validators in the blockchain network. In this paper,
we suppose that the requesters are responsible for paying such
validation fee. In reality, different task requesters may adopt
different reward distribution policies and various algorithms
to charge validation fee. After paying rewards and validation
fee, the rest of the deposits are returned back to the requesters‚Äô
account. But, if a malicious requester is detected (e.g., posting
tasks without valid certiÔ¨Åcation), his deposit will be distributed
to the corresponding workers.
3) Answer Collection & Reward Distribution on Subchain:
Since the subchain validators do not need to help verify
the transactions of the public chain, they only copy the
transaction records from the public-chain ledger and record
detailed private answers on the subchain ledgers. It is worth
mentioning that the answers of all private tasks are not visible
on the public chain, but these answers need to be veriÔ¨Åed on
the public chain. Accordingly, on each subchain, the leader
selected by the PBFT consensus can utilize zero-knowledge
proof by generating a commitment on all subchain blocks of
this task and records it on the public chain, which will be
described in Section V-F.
On each subchain, the procedures of answer collection
and reward distribution are similar to those on the public
chain. Furthermore, to achieve a better access control feature,
an access list model can be added into the subchain smart
contracts, which will be investigated in our future work.
F. Zero-Knowledge Proof
The information on the subchains is passed to the public
chain in the form of ZK-SNARK [31] attestation to verify
that all the answers are submitted correctly by the subchain
leaders for the workers. Note that in a block, every transaction
can be tracked using Merkel root. When a task is completed,
one or multiple blocks may be generated on the subchain. In
order to improve the efÔ¨Åciency of the veriÔ¨Åcation, the leader
extracts the Merkel roots in all the block headers to form a new
Merkel tree and computes the root of this new tree. This new
root, denoted by MT.Root(mt.rootIDt), represents that all
the answers are submitted for the private task with identity
IDt. The leader then counts the total number of answers
|A|, generate a pair of keys (epk, esk), a public ZK-SNARK
parameter PP, Ô¨Ånds the latest time tc of all the answers,
and then generates an attestation œÄa. This attestation together
with esk are used as ZK-proof‚Äôs witness uploaded to public
validators. The smart contracts on the public chain directly
call libsnark to verify the validity of attestation [35]. Since
the validators on the subchains can see all the transaction
information of this task, these validators can be employed to
verify the correctness of the attestation by exposing the PP
on the subchain, preventing the leader from doing evil when
submitting the commitment.
VI. PERFORMANCE EVALUATION
In this section, we conduct experiment to evaluate the
performance of PBFT consensus on our proposed crowd-
sourcing platform by comparing with Casper consensuses on
Ethereum (based on POW and POS [36]), and then analyze
the experiment results in detail.
A. Experiment Environment
For the comparison purpose, we build two separate private
blockchains, where one is on Ethereum platform utilizing
Casper consensus and the other is on Hyperledger fabric plat-
form adopting PBFT consensus. The experiment is performed
on the desktops installed with Intel i7-7700k, 32GB RAM,
512 SSD hard drive, and the Ubuntu 16.04 operating system
in VMWare, respectively testing the transaction veriÔ¨Åcation
speed of Ethereum and Hyperledger Fabric private chains.
On Ethereum platform, the Eth Geth 1.8.22-stable application
is installed to establish a connection with Ethereum main
network, and the solidity compiler is deployed locally to
compile the smart contract and create a private chain. On
Hyperledger fabric platform, Hyperledger Fabric V1.4 is in-
stalled, and Hyperledger composer is used to interact with
the built-in private blockchain. On both two private chains,
we use the Go language to deploy smart contracts and a
chaincode to accomplish multiple money transactions in a row
between different accounts. For each blockchain, we create
two accounts to send and receive transactions, respectively.
The performance of Ethereum and Hyperledger Fabrics is
measured in terms of execution time and throughput. (i)
Execution time is the total time interval, during which all
transactions are completed on the platform. (ii) Throughput
31
Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA. Downloaded on July 14,2025 at 17:04:21 UTC from IEEE Xplore.  Restrictions apply. 
1.00
10.00
100.00
1000.00
10
20
30
40
50
100 150 200 300 500 1000 1500 5000
Second
#Transactions
Ethereum
Hyperledger
Fig. 2. Semi-log Plot on Execution Time with Maximum 5000 Transactions
5.29
4.70
4.91
6.65
6.71
1.11
1.37
1.63
1.96
2.15
0.00
1.00
2.00
3.00
4.00
5.00
6.00
7.00
8.00
10
20
40
50
Second
30
Œ∑Transactio≈∂∆ê
Ethereum
Hyperledger
Fig. 3. Execution Time with Maximum 50 Transactions
refers to the number of successful transactions per second,
which can represent the processing capabilities of a system.
B. Result and Analysis
With the same transaction quantity, 20 rounds of exper-
iments on both platforms are performed, and the averaged
results are presented in Figs. 2-5.
Fig. 2 shows the semi-log plot of the execution time corre-
sponding to different numbers of money transfer transactions.
From the results, one can clearly see that as the number of
transactions increases, the execution time of both Ethereum
and Hyperledger platforms shows an increasing trend. With the
number of transactions, the execution time of the Hyperledger
is much smaller than that of Ethereum. In addition, as the
number of transactions increases, the difference between the
execution time of the two platforms increases.
Since the subchain on our proposed hybrid platform is
temporarily constructed based on task service, usually the
transaction volume is not very large on the subchains. Thus,
the performance with small transaction volume should be paid
more attention. In Fig. 3, we extract the results with the
number of transactions less than 50. We Ô¨Ånd that the execution
time of the Hyperledger private chain increases steadily with
the increase of the number of transactions, while the private
chain based on Ethereum has slight Ô¨Çuctuations, which stems
from the randomness of the block producing rate in PoW
consensus mechanism. We also Ô¨Ånd that with small transaction
volume as shown in Fig. 3, Hyperledger‚Äôs execution time is
3-5 seconds faster than Ethereum.
The semi-log plot of the throughput is shown in Fig. 4,
from which it can be seen that Hyperledger outperforms
Ethereum. The throughput of both Hyperledger Fabric and
Ethereum platforms is increased Ô¨Årst when the transaction
volume grows up and then is reduced when the transaction
volume is larger than a certain value. In our experiments,
0.00
5.00
10.00
15.00
20.00
25.00
30.00
35.00
40.00
45.00
10
20
30
40
50
100 150 200 300 500 10001500 5000
#Transactions/Second
#Transactions
Ethereum
Hyperledger
Fig. 4. Semi-log Plot on Throughput with Maximum 5000 Transactions
3.07
5.37
6.62
6.95
7.82
9.00
14.64
18.46
20.37
23.27
0.00
5.00
10.00
15.00
20.00
25.00
10
20
30
40
50
#Transactions/Second
#Transactions
Ethereum
Hyperledger
Fig. 5. Throughput with Maximum 50 Transactions
Hyperledger achieves the maximum throughput when the
transaction volume is around 1,500, and Ethereum reaches
its maximum when the transaction volume is 1,000. Such
a certain value to obtain the maximum throughput indicates
the platform capacity, and performance bottleneck will appear
when the transaction volume becomes larger than this certain
value.
Moreover, the throughput with the number of transactions
smaller than 50 are extracted. From Fig. 5, we can conclude
that (i) the throughput of both Hyperledger and Ethereum
increases steadily with the increase of the transaction volume;
and (ii) the throughput of Hyperledger is about three times of
the throughput in Ethereum.
Remarks: Our experimental environment is built on local
VMware, which to a certain extent limits the performance of
Hyperledger and Ethereum private chains. The hardware con-
Ô¨Åguration also greatly affects the efÔ¨Åciency of the transaction
veriÔ¨Åcation process. Nevertheless, these experiment settings do
not affect the comparison between the performance of the two
blockchains.
VII. CONCLUSION
In this paper, we propose a hybrid blockchain platform
for crowdsourcing. By respectively employing DPOS and
PBFT consensuses on the public chain and the subchains,
our platform can achieve higher transaction throughput and
less execution time compared with traditional PoW/PoS-based
blockchain. In addition, our platform can realize permission
control and privacy protection by deploying smart contracts
and zero knowledge proof. Finally, we conduct intensive
experiments to validate the efÔ¨Åciency of our platform through
showing the superiority of Hyperledger over Ethereum.
As our preliminary work, the experiment in this paper
mainly focuses on the efÔ¨Åciency of PBFT consensus used
on our platform. In our future work, we will plan to realize
32
Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA. Downloaded on July 14,2025 at 17:04:21 UTC from IEEE Xplore.  Restrictions apply. 
the fundamental functions of our crowdsourcing platform and
further test the performance of the public chain as well as the
interaction between the public chain and the subchains.
ACKNOWLEDGMENT
This research work is partly supported by the U.S. Na-
tional Science Foundation under Grant No.1829674 and
No.1741277.
"
pdf//Performance_Analysis_of_a_Hyperledger_Fabric_Blockchain_Framework_Throughput_Latency_and_Scalability.pdf;This paper aims to present a method that can be used to  investigate the impact of the blockchain network workloads on  the performance of the most recent Hyperledger Fabric  platform, v.1.4 ‚Äì the first long term support release [27].;Findings indicate that the  performance of Hyperdeger Fabric outperform that of  Ethereum in terms of latency, throughput and execution time.;V.  EXPERIMENTAL RESULTS  Results obtained from the Hyperledger Caliper test  benchmark were interpreted to evaluate the performance of a  specific blockchain implementation.;This paper aims to present a method that can be used to  investigate the impact of the blockchain network workloads on  the performance of the most recent Hyperledger Fabric  platform, v.1.4 ‚Äì the first long term support release [27].;[('transaction', 111), ('blockchain', 69), ('number', 45), ('latency', 41), ('hyperledger', 40), ('performance', 36), ('network', 36), ('throughput', 33), ('fabric', 32), ('hyperledger fabric', 25)];2019.0;;"Performance Analysis of a Hyperledger Fabric Blockchain 
Framework: Throughput, Latency and Scalability
 
 
Murat Kuzlu1, Manisa Pipattanasomporn2,3, Levent Gurses4 and Saifur Rahman2 
1 Electrical Engineering Technology, Old Dominion University, Norfolk, VA, USA 
2 Bradley Department of Electrical and Computer Engineering, Virginia Tech ‚Äì Advanced Research Institute, Arlington, VA, USA 
3Smart Grid Research Unit, Chulalongkorn University, Bangkok, THAILAND 
4Movel, Inc., Sterling, VA 
 
  
Abstract‚Äî Focusing on one of the most popular open source 
blockchain 
frameworks‚ÄîHyperledger 
Fabric, 
this 
paper 
evaluates the impact of network workload on performance of a 
blockchain platform. In particular, the performance of the 
Hyperledger Fabric platform is evaluated in terms of: (a) 
throughput, i.e., successful transactions per second; (b) latency, 
i.e., response time per transaction in seconds; and (c) scalability, 
i.e., number of participants serviceable by the platform. The 
results indicate that the instance of Hyperledger Fabric platform 
being implemented can support up to 100,000 participants on the 
selected AWS EC2 instance.  As long as the transaction rate is 
maintained within 200 transactions per seconds, the network 
latency is in the order of fraction of a second.  
Index Terms‚ÄîBlockchain; Hyperledger fabric; throughput; 
latency. 
I. 
INTRODUCTION  
Blockchain is the distributed ledger technology (DLT) 
having significant features, such as decentralized and trustable 
ledger of records. Since It was first introduced in 2008 [1], the 
blockchain technology today goes far beyond Bitcoin 
cryptocurrency applications. It has become one of the emerging 
and leading techologies that has revolutionized financial 
services [2], supply chains [3], healtcare [4], energy [5] and  
public services [6].  The main advantage of using the 
blockchain technology is its ability to support a publicly 
distributed ledger, where an identical copy of the ledger is 
replicated throughout a blockchain network. It also allows 
transactions to be anonymously secured among business 
partners, and automatically verifies and records data using 
cryptographic algorithms without the need for a central 
authority or intermediary.   
So far, several blockchain frameworks have become 
available that provide adaptable and flexible platforms 
supporting various applications.  These platforms include 
Hyperledger Fabric [7], Ethereum [8], Corda [9], Omni [10], 
Ripple [11], MultiChain [12], OpenChain [13] and Chain Core 
[14]. While there are already several blockchain projects being 
piloted, there exist some concerns about the technical 
challenges of a blockchain platform in terms of its throughput, 
latency and its ability to scale [15].  
In the literature, several studies discussed the scalability and 
performance analysis of different blockchain platforms. 
Performance metrics of different blockchain platforms, mainly 
Hyperledger Fabric and Ethereum, were compared in [16, 17]. 
Authors in [16] introduced BLOCKBENCH ‚Äì the evaluation 
framework for private blockchains, to analyze major 
blockchain platforms: Ethereum, Parity and Hyperledger 
Fabric. In [17], the performance analyses of both Hyperledger 
Fabric and Ethereum were presented.  Findings indicate that the 
performance of Hyperdeger Fabric outperform that of 
Ethereum in terms of latency, throughput and execution time.   
Performance evaluation of the Hyperledger Fabric platform 
was discussed in [18-22]. Authors in [18] analyzed the 
performance of two Hyperledger Fabric versions (v0.6 and 
v1.0). Results indicate that, for Fabric v1.0, number of nodes 
did not impact throughput, latency and scalability; while the 
performance of Fabric v0.6, on the other hand, decreased with 
the increasing number of nodes. Authors in [19] studied 
throughput and latency of Hyperledger Fabric v1.0 by varying 
the network workloads, including number of chaincodes, 
channels and peers. In [20], the authors investigated the 
performance of the Hyperledger Fabric blockchain platform 
v1.0 considering different block sizes, endorsement policies, 
number of channels, resource allocation and state database 
choices. In [21], focusing on Hyperledger Fabric v1.1, authors 
presented the impact of block size (i.e., size of transactions), 
peer CPU, and SSD vs RAM disk on blockchain latency and 
throughput. Scalability was also tested by increasing number of 
peers. Stochastic Reward Nets were used to analyze throughput, 
utlization and queue length for each peer of Hyperledger Fabric 
v1.0 [22]. Additionally, authors in [23] recommended 
performance metrics for performance evaluation of the 
Hyperledger Fabric blockchain platform. 
Performance evaluation of the Ethereum platform was 
discussed in [24, 25]. In [24], authors evaluated the 
performance of the Ethereum blockchain for Geth and Parity 
536
2019 IEEE International Conference on Blockchain (Blockchain)
978-1-7281-4693-5/19/$31.00 ¬©2019 IEEE
DOI 10.1109/Blockchain.2019.00003
Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA. Downloaded on July 14,2025 at 17:00:31 UTC from IEEE Xplore.  Restrictions apply. 
(which are most popular Ethereum clients), and investigated the 
impact of different transaction types on the blockchain 
performance. Results indicate that the Parity client can support 
faster transactions than the Geth client. In [25], the test was 
conducted to analyze the performance of Ethereum blockchain 
related to its ability to read/write data on a relational database, 
i.e., MySQL.   
A prototype blockchain network was implemented for 
storing personal health information as discussed in [26].  
Performance analysis was conduted and findings indicated low 
response time (<500 ms) and high availability (98%).  
This paper aims to present a method that can be used to 
investigate the impact of the blockchain network workloads on 
the performance of the most recent Hyperledger Fabric 
platform, v.1.4 ‚Äì the first long term support release [27]. The 
network workload refers to varying number of transactions, 
transaction rate and transaction types.  Performance of the 
blockchain network being evaluated include the throughput (in 
transactions per second, tps), latency (in seconds) and 
scalability (i.e., number of participants that the blockchain 
network can serve). 
II. 
HYPERLEDGER FABRIC PLATFORM DEPLOYMENT 
To evaluate the platform performance, an instance of a 
Hyperledger Fabric platform was deployed.  The deployment 
model is depicted in Fig. 1, illustrating major blockchain 
components, together with the tools used.  
 
 
 
Fig. 1. The Hyperledger Fabric deployment model (top) with its development 
tools (bottom). 
 
In this study, the entire Hyperledger Fabric deployment was 
installed and run on the Linux-Ubuntu operating system. Each 
component of the Hyperledger Fabric, including peers, 
Ordering Service (OS) and Certificate Authority (CA), was 
launched as a Docker container. Note that: a peer managed by 
each group of participants is responsible for executing 
transactions and maintaining its ledger; an OS provides 
services, such as broadcasting messages, guaranteeing 
message delivery, etc.; and a CA provides certificate services 
to blockchain participants.  
Hyperledger Fabric allows developers to select either Solo 
or Kafka to provide an ordering service to the blockchain 
network. Solo and Kafka are consensus plugin interfaces 
available for the Hyperledger ordering service. In this 
development environment, Solo was used as the blockchain 
network has only one orderer. The Hyperledger Fabric 
supports either LevelDB or CouchDB as state database 
options; and CouchDB was used in deployment model.  
The Hyperledger Fabric also supports Golang, Javascript 
and Java programming languages to execute smart contracts. 
The smart contracts in this study were written in Javascript and 
the Hyperledger Fabric Client SDK for Node.js was used to 
interact with the Hyperledger Fabric blockchain network. 
III. 
THE BENCHMARK TOOL AND TEST ENVIRONMENT  
This section discusses the Hyperledger benchmark tool 
selected for the experiment, its setup and the test environment. 
A. Hyperledger Benchmark Tool  
Hyperledger Caliper [28]‚Äìa blockchain benchmark tool‚Äì 
was selected for evaluating the blockchain implementation 
performance. The main advantage of using Hyperledger 
Caliper is that it represents many clients that can inject 
workloads in the blockchain network, i.e., multiple client 
threads. Fig. 2 depicts the deployment model of the 
Hyperledger Caliper platform for performance evaluation.  
 
Fig. 2. The deployment model of Hyperledger Caliper for performance 
evaluation. 
 
B. Setup of the Hyperledger Caliper Benchmark Tool 
To set up the test benchmark tool, the benchmark 
configuration file was configured to vary transaction rates, 
transaction numbers, and transaction types.  
‚Ä¢ Transaction number (txNumber) defines the number of 
transactions generated in each round, i.e., txNumber = 
[1000, 5000] means that 1000 transactions are generated in 
the first round; and 5000 are generated in the second.  
‚Ä¢ Transaction rate (rateControl) defines the transaction rate 
during the benchmarking test sub-rounds. For the 
conducted experiments, the fixed-rate controller was used, 
in which input transactions were sent at fixed intervals 
specified as transactions per second, tps.  
‚Ä¢ Transaction type has two options as specified by Caliper, 
i.e., open and query. An ‚Äúopen‚Äù transaction performs one 
537
Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA. Downloaded on July 14,2025 at 17:00:31 UTC from IEEE Xplore.  Restrictions apply. 
read and one write operations in one transaction, while a 
‚Äúquery‚Äù transaction simply reads the state from CouchDB. 
The blockchain network configuration file was also 
configured, which defines the network parameters, such as the 
organizations, peers, nodes, the channel name, etc.  
In this study, the impact of varying transaction numbers, 
transaction rates and transaction types on blockchain 
performance is of interest.  Hence, these are parameters to be 
varied in the experiment, while network configuration remains 
fixed throughout the experiment. 
C. Test Environment 
AWS EC2 instance having 16 vCPUs, 3.0 GHz Intel Xeon 
Platinum processors and 32GB RAM was used to run the test 
benchmark platform. The AWS EC2 instance ran Ubuntu 
16.04 LTS and peers, CA, OS, and Caliper with Fabric release 
v1.4. This test environment was used to understand the impact 
of the hardware selection, i.e., CPU and RAM, on the 
throughput, latency, and scalability, of the blockchain 
deployment. 
IV. 
CASE STUDY DESCRIPTION 
To conduct the performance test on Hyperledger Caliper, 
several use cases were defined by varying specifications of key 
parameters.  The resulting performance of the blockchain 
platform was then recorded and analyzed, against three 
performance metrics:   
‚Ä¢ 
Throughput ‚Äì successful transactions per second 
‚Ä¢ 
Latency ‚Äì response time per transaction 
‚Ä¢ 
Scalability ‚Äì the ability to support increasing number 
of participants.   
Specific parameters used for performance evaluation are 
summarized in Table I.   
TABLE I. PARAMETERS FOR PERFORMANCE EVALUATION 
Key parameters 
Transaction per 
second (tps)
Number of 
transactions 
Simul-
taneous 
transactions 
Case I: Impact of 
test environment 
and transaction 
rates  
 
100, 150, 200,  
250, 300tps
1,000 
 
N/A 
Case II: Impact 
of number of 
transactions 
200tps
1,000 
10,000 
100,000 
 
N/A 
Case III: Impact 
of simultaneous 
transactions 
Equivalent to number 
of simultaneous 
transactions
N/A 
100 
200 
300 
 
In Case I, the objective is to study the impact of varying 
transaction rates on the performance of the blockchain 
network. Hence, several transaction rates were used, which are 
100,150, 200, 250 and 300 tps. Total number of transactions 
was fixed at 1000. Simultaneous transactions were not defined. 
In Case II, the experiment was conducted to understand the 
impact of large-scale transactions on cloud-based blockchain 
throughput and latency.  The total number of transactions was 
varied from 1000, 10000 to 100000. The transaction rate was 
fixed at 200 tps.  Number of simultaneous transactions was not 
defined.  
In Case III, the impact of simultaneous transactions on 
blockchain performance was evaluated by varying the number 
of simultaneous transactions (100, 200 and 300).   
In all scenarios, both types of transactions (open and query) 
were tested, and the number of organizations was fixed at two, 
as this is our expected deployment scenario. 
V. 
EXPERIMENTAL RESULTS 
Results obtained from the Hyperledger Caliper test 
benchmark were interpreted to evaluate the performance of a 
specific blockchain implementation. Experimental results are 
discussed below.   
A. Case I: Impact of Transaction Rates 
Fig. 3 shows the average throughput (in tps) and latency (in 
seconds) at different transaction rates, varying from 100, 150, 
200, 250 and 300tps. 
 
Fig. 3. Impact of transaction rates and transaction types on the blockchain 
throughput and latency. 
 
It can be seen that, with the ‚Äúopen‚Äù type of transaction 
(where one read and one write were performed per 
transaction), the blockchain network could only handle up to 
200 tps without any significant network latency. When the 
transaction rate increased above 200 tps, the blockchain 
throughput decreased as the transaction rate increased and the 
latency significantly increased.  This implies that this specific 
test environment could handle up to 200 tps of the ‚Äúopen‚Äù 
transaction type without any significant network delay. 
For the ‚Äúquery‚Äù type of transaction (where only one read 
was performed in a transaction), the blockchain network 
obviously could handle 300 tps without any delay.  The 
average latency was still close to zero. This implies that the test 
environment did not reach its maximum limit, and it could 
support higher transaction rates.   
538
Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA. Downloaded on July 14,2025 at 17:00:31 UTC from IEEE Xplore.  Restrictions apply. 
B. Case II: Impact of the Number of Transactions 
To understand the impact of the total number of 
transactions on blockchain throughput and latency, the total 
number of transactions was varied from 1,000, 10,000 to 
100,000 and these transactions were sent to blockchain at the 
rate of 200 tps (which was the upper transaction rate limit 
identified in Case I).  Fig. 4 shows the average throughput and 
latency for both ‚Äúopen‚Äù and ‚Äúquery‚Äù transaction types at 
different numbers of transactions.  
The experimental results indicate that the total number of 
transactions has no significant impact on the throughput and 
latency if the selected transaction rate (tps) can be handled by 
the hardware. As shown in Fig. 4, the throughput was flat in all 
cases at 200 tps, which was the transaction rate used. The 
latency was also flat for ‚Äúquery‚Äù transaction at 0.01 seconds, 
while it was slightly higher for ‚Äúopen‚Äù transaction at 0.13-0.16 
seconds. For the ‚Äúopen‚Äù transaction case, the latency slightly 
increased when a very high number of transactions was used. 
The increase in latency was however still considered very 
small, i.e., 0.03 seconds.   
 
Fig. 4. Impact of the number of transactions on the throughput and latency for 
‚Äúopen‚Äù and ‚Äúquery‚Äù transactions. 
 
These results can be generalized as follows: 
‚Ä¢ A very high number of transactions can be supported, 
i.e., 100,000, at a very low latency when the transactions 
have less operations (only read, not both read and write). 
‚Ä¢ The type of transactions affects the network latency due 
to complexity and the number of operations involved 
even though the blockchain platform is hosted by a high 
capability hardware system. 
In a blockchain network, the scalability can be measured in 
different ways, i.e., based on the number of channels, the 
number of peers, the number of organizations, the number of 
nodes, the number of transactions, the consensus protocol, etc. 
In this `study, the total number of transactions was selected as 
the measurement parameter of the scalability. It is assumed 
that each transaction represents a participant.  Based on the 
results, the implemented Hyperledger platform can support 
100,000 participants with the selected hardware configuration. 
If the hardware configuration has higher spec, higher number 
of participants can be supported.  Hence, there is in fact no 
limit on the number of participants that can take part in the 
Hyperledger Blockchain network. It depends on the selected 
hardware and the blockchain network configurations.   
C. Impact of Multiple Simultaneous Transactions  
To evaluate the impact of transactions simultaneously 
submitted by many participants on the blockchain throughput 
and latency, additional use cases were run under the same test 
environment. It is assumed that there are 100, 200 and 300 
participants, each of which sent a request to blockchain 
simultaneously. Blockchain throughputs and latency were 
recorded for both ‚Äúopen‚Äù and ‚Äúquery‚Äù transactions.  Results are 
shown in Fig. 5.  It can be seen that both throughput and 
latency increase with the increasing number of simultaneous 
transactions.  
 
Fig. 5. Impact of the number of participants on throughput and latency. 
 
With ‚Äúopen‚Äù transactions, throughputs were 34.6, 40.3 and 
44.8 tps for 100, 200 and 300 simultaneous transactions, 
respectively. Latency also increased with the increasing 
number of simultaneous transactions. This implies that the 
system has already reached its maximum capability to handle 
such number of simultaneous transactions as the blockchain 
throughput could not catch up with many simultaneous 
transactions given as the inputs.  The increasing latency 
implies that the blockchain network had to queue the 
remaining transactions for later processing. 
On the other hand, with ‚Äúquery‚Äù transactions, the throughput 
was higher than the ‚Äúopen‚Äù transaction, and the latency was 
significantly lower. This is as expected as ‚Äúquery‚Äù transactions 
perform only one read operation per transaction.  Under this 
case, the system could handle 200 simultaneous transactions 
without any queuing requirement as the throughput appeared 
to be higher than 200tps. While at 300 simultaneous 
transactions, queuing was needed and hence the latency started 
to increase.  
These results can be generalized as follows: 
‚Ä¢ Under this specific test environment, an increase in 
simultaneous transactions significantly affects the 
performance of the blockchain network, in particular the 
latency.  
539
Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA. Downloaded on July 14,2025 at 17:00:31 UTC from IEEE Xplore.  Restrictions apply. 
‚Ä¢ Transaction type has a significant influence on the 
performance of the blockchain network. 
‚Ä¢ Throughput is relatively flat as the number of 
simultaneous transactions increases if the system has 
already reached at its maximum limit. 
‚Ä¢ Latency increases with the increase in simultaneous   
transactions if the system has already reached at its 
maximum limit. 
VI. 
CONCLUSION 
This paper discusses the impacts of the blockchain network 
workload on performance of the Hyperledger Fabric blockchain 
framework in terms of throughput, latency and scalability. 
Several use cases were performed by varying transaction rates 
(tps), total number of transactions, number of simultaneous 
transactions and type of transactions in the simulated 
environment.  
Under the test environment with the AWS EC2 instance 
having 16 vCPUs, 3.0 GHz Intel Xeon Platinum processors and 
32GB RAM, the blockchain network could support up to 
200tps.  This was the transaction rate that the specific 
blockchain network could support without any significant 
latency.  At 200tps, the blockchain network of interest could 
easily support 100,000 transactions, i.e., 100,000 participants. 
The average response time was quite less than anticipated, i.e., 
0.01 and 0.16 seconds for 100,000 ‚Äúquery‚Äù and ‚Äúopen‚Äù 
transaction requests, respectively. There existed however the 
impact of simultaneous transactions on network latency and 
throughput.   
In summary, the throughput, latency and scalability of a 
blockchain network depend on hardware configuration, 
blockchain network design and smart contact complexity/ 
operations. These results may be different under different test 
environments. It is expected that the findings reported in this 
paper can serve as a guideline that can help select a suitable 
hardware configuration, as well as a blockchain network and its 
parameters 
that 
can 
support 
a 
specific 
blockchain 
implementation and requirements. 
VII. "
pdf//Performance_Analysis_of_a_Hyperledger_Iroha_Blockchain_Framework_Used_in_the_UK_Livestock_Industry.pdf;In such a setting,  this research presents a unique report of the performance of this  Blockchain framework in a major real-world commercial  situation.;One of the  earliest manifestations of the power of this technology is Bitcoin  which is a self-regulated currency platform capable of handling  transactions remarkably faster, safer, cheaper, and more  traceable than conventional legacy financial systems [5].;Also, we utilized  Locust as our testing framework for the purpose of consistency.;Overall, Hyperledger Iroha outperformed other  alternatives in our case because of its consensus algorithm (also  referred to as YAC or Yet-Another-Consensus algorithm),  highly supportive community, robust permission system, simple  deployment as well as ease of maintenance.;[('blockchain', 49), ('iroha', 45), ('performance', 30), ('hyperledger', 27), ('framework', 25), ('time', 19), ('hyperledger iroha', 19), ('network', 18), ('result', 18), ('transaction', 17)];2018.0;For future work, we have a plan to assess newer versions of  Hyperledger Iroha, and we are interested in comparing the  performance results of Hyperledger Iroha with more common  Blockchain frameworks such as Hyperledger Fabric and  Ethereum.;"Performance Analysis of a Hyperledger Iroha 
Blockchain Framework Used in the UK Livestock 
Industry
Konstantinos Ntolkeras
Blockchain Department
Breedr Ltd
London, UK
kostas@breedr.co
Hossein Sharif
Newcastle Business School
Northumbria University
Newcastle upon Tyne, UK
hossein.sharif@northumbria.ac.uk
Soroush Dehghan Salmasi
Newcastle Business School
Northumbria University
Newcastle upon Tyne, UK
soroush.salmasi@northumbria.ac.uk
William Knottenbelt
Department of Computing
Imperial College London
London, UK
w.knottenbelt@imperial.ac.uk
 
Abstract‚Äî This investigation focuses on the performance 
analysis of one of the most nascent Blockchain frameworks, 
Hyperledger Iroha. This paper evaluates the performance of the 
Hyperledger Iroha framework based on three parameters: (a) 
total requests per seconds (RPS) over time; (b) response times in 
milliseconds over time; and (c) number of users in the network 
over time. The results indicate that the integration of Hyperledger 
Iroha with a major livestock management and trading platform in
the UK, can support at least 200 participants with no errors in the 
network. Additionally, the total requests per second can reach as 
high as 40.6, and the response times are in the order of a fraction 
of a second. This research and its results can assist scholars and 
practitioners regarding selection of an ideal Blockchain 
framework for their problem setting.
Keywords‚Äî Blockchain, Supply Chain Management, Livestock 
Industry, Hyperledger Iroha, Response Time, Scalability
I.
INTRODUCTION 
Recently, there has been an increasing surge of attention to 
digitizing supply chains with the aim of increasing transparency 
and visibility, while enhancing profits by improving the 
matchmaking of its participants and allowing access to credit by 
using supply chain records. This is especially important now as 
Covid-19 has severely plagued supply chains throughout the 
world [1]. In this light, many supply chains have embraced 
Blockchain technologies so as to guarantee further transparency 
and trust within the industry [2].
Blockchain, at its heart, is about maintaining a distributed 
record of transactions in lieu of the central architecture which 
has been prevalent until now [3]. Technologically, Blockchain 
reckons aspects of distributed computing and cryptography 
which 
implement 
an 
operational 
protocol 
(incentive 
mechanism) based on Game Theory principles [4]. One of the 
earliest manifestations of the power of this technology is Bitcoin 
which is a self-regulated currency platform capable of handling 
transactions remarkably faster, safer, cheaper, and more 
traceable than conventional legacy financial systems [5]. Having 
gained ground in financial industries
[6], Blockchain 
technologies have enthralled many minds in other fields whose 
problem domains can benefit from increased transparency 
and/or more efficient transactions. Based on these new 
application domains, Blockchain‚Äôs annual expansion rate in the 
supply chain has been estimated to grow by 87% which 
increases from $45 million in 2018 to $3,314.6 million by 2023
[7]. The escalating adoption rate of the Blockchain-powered 
solutions within supply chains have been substantiated through 
increased transparency and more streamlined transactions which 
all lead higher productivity and profitability. 
One of the sectors that most recently has started exploring 
the potential of Blockchain is the livestock industry. The present 
research provides a report on the first major application of 
Blockchain technology for the livestock industry in the UK 
which is now active and running. The project was envisioned 
and then executed through a consortium comprising of one of
the leading Blockchain research centres in the UK, a global 
livestock tracing and trading platform (Breedr), one of Europe‚Äôs 
largest meat processors and the UK government. After much 
deliberation and consultation with industry experts, Hyperledger 
Iroha was chosen as the Blockchain framework for this project 
to be implemented within Breedr. This is despite much more 
widespread usage of other Blockchain frameworks, such as 
Ethereum and Hyperledger Fabric, for a similar problem 
domain. Overall, Hyperledger Iroha outperformed other 
alternatives in our case because of its consensus algorithm (also 
referred to as YAC or Yet-Another-Consensus algorithm), 
highly supportive community, robust permission system, simple 
deployment as well as ease of maintenance. Despite its superior 
performance, Hyperledger Iroha has not received significant 
attention among researchers and practitioners. In such a setting, 
this research presents a unique report of the performance of this 
Blockchain framework in a major real-world commercial 
situation. 
The rest of the paper is organized as follows. Section II 
explains the integration of Iroha with the UK‚Äôs major livestock 
tracing and trading platform (Breedr). Section III describes the 
methodology in three steps: The Blockchain Framework and 
456
2021 IEEE International Conference on Blockchain (Blockchain)
978-1-6654-1760-0/21/$31.00 ¬©2021 IEEE
DOI 10.1109/Blockchain53845.2021.00070
2021 IEEE International Conference on Blockchain (Blockchain) | 978-1-6654-1760-0/21/$31.00 ¬©2021 IEEE | DOI: 10.1109/BLOCKCHAIN53845.2021.00070
Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA. Downloaded on July 14,2025 at 17:04:27 UTC from IEEE Xplore.  Restrictions apply. 
Hardware Setup, Benchmark Framework Implementation, and 
Performance Results. The results obtained from these tests are 
presented and discussed in Section VI. Lastly, Section V 
provides conclusions, limitations, and future work. 
II.
THE INTEGRATION OF IROHA WITHIN THE BREEDR 
LIVESTOCK PLATFORM
The Livestock in the UK predominantly reliant on small 
farmers whose approach to their farming activity is more of a 
lifestyle choice rather than a profit-driven business. This can be 
observed through families who have been running small 
livestock farms across multiple generations spanning going as 
far back as 1700s. Another feature of this sector has been their 
resistance towards technology adoption, for business reasons, 
e.g. costs and sophistication, and non-business reasons, e.g. 
preserving their way of life and social structure. On the other 
hand, changes in governance philosophies and economic 
policies, e.g. market-driven policies and increased privatization, 
as well as major events, such as Bovine Spongiform 
Encephalopathy (BSE or the Mad Cow Disease), Foot and 
Mouth Disease and most recently exiting of the EU (Brexit) and 
the Covid-19 pandemic and the subsequent changes in 
regulation and consumer behavior have acted as major drivers 
for technology adoption.
All the aforementioned drivers have let do more adaptive 
atmosphere in the UK‚Äôs livestock sector for disruptive 
innovation through platform business models and Blockchain 
technology. In this regard, government funding and regulatory 
support for this specific project, have acted as catalysts further
facilitating the transformation of the UK‚Äôs livestock sector.
On a more specific note, considering the actual 
implementation of a commercial Blockchain-based solution, 
project partners conducted an evaluation of existing Blockchain 
frameworks and none proved to be mature and/or resilient 
enough to address project requirements. Eventually, after 
consultation with industry experts, Hyperledger Iroha was 
identified as a promising option. This framework was then 
adopted for development of a prototype solution. Consequently, 
given the satisfactory results of this prototype, Hyperledger 
Iroha was then formally adopted as part of the Breedr livestock 
tracing and trading platform.
System configuration of the Blockchain solution is presented 
in Fig. 1. Firstly, we developed and employed an Iroha network 
so as to foster trust among stakeholders and also to guarantee the 
transparency and security of interactions. Also, an Application 
Programming Interface (API) was developed via the Iroha 
Python library [8], to ensure the accessibility of the Iroha 
Blockchain through web-based and other applications.
Furthermore, a stand-alone web application was developed 
in order to address information inquiries, retrieval, and display 
from the Iroha network. The Blockchain Explorer, which 
utilizes the API generated by us to interact with Iroha, was 
developed based on the Flask web framework [9]. The 
Blockchain Explorer can be employed for data retrieval from the 
Blockchain, by such system stakeholders as farmers, lenders, 
regulators, and processors, according to their permissions.
Additionally, the main functionality of our solution was 
integrated into the Breedr platform. Thus, the Breedr back-end, 
which is built utilizing Django [10], was modified and 
developed. Also, the platform database, PostgreSQL [11], was 
utilized to store and retrieve the details of certain user and 
animals. Moreover, the Breedr Administrator Interface was 
modified so as to interact with the Blockchain and also to 
facilitate software integration. However, we were not able to 
modify the Breedr client interface as they did not have access to 
it.  
Fig. 1. System configuration demonstrating the interaction of various 
elements. Blue elements are created; green elements are modified, and red 
elements are existing and unmodified.
III.
METHODOLOGY
As mentioned previously, evaluating the performance of a 
Hyperledger Iroha Blockchain framework is unique to this 
research, and is not addressed in any other research paper. For 
this project, we intend to evaluate the performance the 
Hyperledger Iroha using Locust. All the steps taken to execute 
this benchmark testing and performance evaluation are 
described thoroughly in this section.
A. Step 1: The Blockchain Framework and Hardware Setup
This performance evaluation experiment is conducted on a 
MacBook Pro, Retina, 2015 model, with the Intel¬Æ Core‚Ñ¢ i5
Dual-Core CPU @ 2.7GHz, 8 GB RAM, 121 GB hard disk drive 
and running macOS Catalina Version 10.15.4. The Blockchain 
framework that we have chosen to test for this experiment is 
Hyperledger Iroha. More specifically, Hyperledger Iroha is one 
of several Blockchain frameworks and tools managed by the 
Linux Foundation. This is based on the adoption of the source 
code originally developed by the Japanese FinTech company 
Soramitsu after they made it available to the public as an open 
source project [12]. Iroha is constructed as a general purpose 
permissioned Blockchain framework developed in C++. It uses 
a Byzantine Fault Tolerant (BFT) ordering service and a BFT 
consensus algorithm referred to as Yet-Another-Consensus 
(YAC) algorithm. More specifically, Hyperledger Iroha offers 
special support and features for development of mobile 
applications and provides a modular design that adopts the 
457
Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA. Downloaded on July 14,2025 at 17:04:27 UTC from IEEE Xplore.  Restrictions apply. 
command-query separation principle. The initial design and 
architecture of this framework was heavily inspired by 
Hyperledger Fabric [13], while attempting to outperform it 
through a simple, reliable and high-throughput solution 
supporting 
permissioned 
Blockchain 
web and 
mobile 
applications. Moreover, this framework provides a set of C++ 
libraries to other Hyperledger projects [14]. One the key features 
of Iroha compared to other frameworks is that it enables a 
situation where each user can be given varying permissions 
when transacting within the Blockchain network [12]. In this 
project, we have tested the Hyperledger Iroha version 1.1.
B. Step 2: Benchmark Framework Implementation
The performance of the Iroha network transaction speed as 
measured by Garifullina [15] and Dimant [16]. The conditions 
of conducting the performance tests were as follows: 1. One 
node in the network; 2. Eight different clients with a total of 
32,000 requests; and 3. One transaction sent per request in which
0.01 USD was transferred to a test account. The testing 
framework which was employed to simulate users and 
transactions was Locust [17]. The results of a performance test 
conducted by Garifullina [15] and Dimant [16] showed that 
Iroha can support about 300 Transactions Per Seconds (TPS).
The results of the performance test are presented in Fig. 2.
We took this analysis a step further by testing the 
performance of Iroha for a specific use case, the Blockchain API 
that was developed for the livestock industry. Also, we utilized 
Locust as our testing framework for the purpose of consistency. 
Given the available computing power, the configuration below 
was used to make the test scalable:
x
1. Users to simulate: 200
x
2. Hatch rate (users spawned per second): 5
x
3. 1 Atomic Batch of transactions sent per request. For 
every request an atomic batch of transactions was sent as 
defined in our API implementation. We test for (a) 
Generating a farmer or processor account; (b) 
Registering an animal to a farmer‚Äôs account, and (c) 
Querying and retrieving the account information from 
the Blockchain.
C. Step 3: Performance Results
In this step, we have collected our experimental performance 
outputs in one table and three graphs, which were generated by 
Locust. As mentioned before, we measured performance in 
terms of three metrics including 1. total requests per seconds 
over time; 2. response times in milliseconds over time; and 3. 
number of users in the network over time.
IV.
RESULTS AND DISSCUSION
Performance test results are illustrated in Fig. 3. There were 
0 failures in the transactions sent to and processed by the 
network, with the total RPS reaching as high as 41. A more in-
depth analysis of our results indicates that Iroha can settle about 
7 RPS for generating farmer or processor accounts and 10 RPS 
for registering animals to farmer accounts. Furthermore, Iroha is 
quite high-performant in querying and retrieving information 
from the Blockchain. As Fig. 3 illustrates, Iroha can obtain about 
24 RPS in retrieving account information from the Blockchain. 
A more thorough analysis of the results can be offered by 
examining Figs. 4, 5, and 6. Fig. 4 shows the total requests per 
second, while Figure 5 demonstrates the response times in 
milliseconds, and Fig. 6 the number of network users. These 
figures make a comparative analysis of the results possible and 
elaborate on the performance of our software.
Another significant factor that should be taken into 
consideration when opting for a particular Blockchain 
technology is its scalability potential. Figs. 3, 4, 5, and 6 
illustrate the results of the performance tests conducted against 
our software. The results assure us that our solution can scale up 
well to multiple network users and can support many RPS. 
Furthermore, as Fig. 3 demonstrates, since our software faces 0 
failures in the performance tests conducted, it can be concluded 
that it is completely robust. 
Moreover, Iroha makes the configuration of the network 
before utilization possible so as to better meet the particular 
needs, requirements, and features of the use case in question. A 
very significant factor affecting network scalability is the max 
proposal size, which determines the maximum number of 
transactions that can be stored in one proposal. If the system 
faces many transactions per second, then it is essential to 
increase this factor when the network is configured. This makes 
greater performance and better scalability of our solution 
possible. Lastly, vote delay is another important factor that 
should be configured before employing the Blockchain solution. 
The vote delay factor determines the waiting time before a peer 
sends its vote to the next node. When this factor is being 
configured, we should consider for the overall number of nodes 
within the system. This factor expresses the trade-off between 
high throughput performance and the frequency of failures in the 
consensus mechanism. Thus, vote delay is another essential 
factor in determining solution scalability.  TABLE
I
demonstrates a general evaluation of the Hyperledger Iroha.
458
Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA. Downloaded on July 14,2025 at 17:04:27 UTC from IEEE Xplore.  Restrictions apply. 
Fig. 2. Performance tests on Iroha recording the TPS of the network 
 
Fig. 3. Requests per second (RPS) supported by Iroha for 1. Generating a farmer or processor account; 2. Registering an animal to a farmer‚Äôs account; and 3. 
Querying and retrieving the account information from the Blockchain
Fig. 4. Total requests per seconds over time
459
Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA. Downloaded on July 14,2025 at 17:04:27 UTC from IEEE Xplore.  Restrictions apply. 
Fig. 5. Response times in milliseconds over time 
Fig. 6. Number of users in the network over time 
TABLE I. 
A GENERAL EVALUATION OF THE HYPERLEDGER IROHA FRAMEWORK INTEGRATED WITH BREEDR PLATFORM
Parameter
Hyperledger Iroha
Requests Per Second (RPS)
40.6
Response time
A fraction of a second
Scalability
Good (Our implementation scaled up to 200 users with 5 users spawned per second) + reconfigurable
Robustness
Good (our implementation scaled up to 200 users with 5 users spawned per second with 0 failures) + YAC 
(Yet Another Consensus) Byzantine fault tolerant algorithm
Industrial Use
Medium (e.g. Soramitsu, Cambodian Payment System, xor crypto)
Data Security
Advanced ‚Äì 2 Layers of Access Control (our implementation)
Costs
Nodes running + Labour
Integration
Advanced
Labour Force
Potentially less (+Much bigger after integration with Burrow and smart contracts written in Solidity)
Business Perspective
Innovative, faster development (at least in the beginning)
Technical Maturity
Medium
Issues reported
9 Open ‚Äì 35 Closed
460
Authorized licensed use limited to: UNIVERSIDADE ESTADUAL DE MARINGA. Downloaded on July 14,2025 at 17:04:27 UTC from IEEE Xplore.  Restrictions apply. 
V.
CONCLUSIONS, LIMITATIONS, FURTUR WORK 
This research seeks to investigate the performance 
analysis and full potentials of Hyperledger Iroha and add to 
the current academic literature and industrial work. This 
technology offers a high performance, novel BFT algorithm 
and guarantees low response times and finality of transactions. 
It provides a secure and easy-to-use API to interact with the 
Blockchain. Furthermore, developers can take advantage of a 
collaborative and active community and are encouraged to 
contribute themselves to make the community develop and 
prosper. Iroha makes the relatively simple utilization and 
maintenance of the network possible, while encouraging the 
development of mobile applications. Additionally, it offers a 
completely operational mechanism for multi-signature 
transactions, which are extensively utilized in our application. 
However, it is important to bear in mind that Iroha is a novel 
and, thus, not fully-fledged technology. There are not many 
resources available and even though the community is active 
and collaborative, it is not as large as that of other Blockchain 
technologies that have been around much longer in the market. 
Lastly, Iroha v.1 does not yet offer a facility for the generation 
and deployment of smart contracts. However, Hyperledger 
Iroha v.2 provides such a facility [18].
As limitations of this project, it should be noted that these 
results 
are 
contingent 
upon 
software 
design 
and 
implementation as well as the API calls produced. They are 
specific to our use case and implementation and also represent 
the time complexity of our software. Furthermore, it should be 
stressed that each request does not correspond to one 
transaction only, but rather to multiple transactions organized 
in an atomic batch and signed by different network users. This 
fact should be taken into consideration when comparing the 
software performance with other Blockchains or other 
implementations in Iroha. It should also be noted that these 
results are subject to hardware restrictions of the devices used.
For future work, we have a plan to assess newer versions of 
Hyperledger Iroha, and we are interested in comparing the 
performance results of Hyperledger Iroha with more common 
Blockchain frameworks such as Hyperledger Fabric and 
Ethereum. Moreover, given that we only have a single node at
the moment for each environment, we can potentially deploy 
more nodes then compare and contrast the performance with 
our current setting.
ACKNOWLEDGMENT
The authors would like to acknowledge the financial 
support and funding of the UK Research and Innovation 
(UKRI), Imperial College London, Breedr Ltd and the 
Northumbria University.
"
